{"version":3,"file":"moveable.cjs.js","sources":["../src/react-moveable/ables/AbleManager.ts","../src/react-moveable/consts.ts","../src/react-moveable/gesto/CustomGesto.ts","../src/react-moveable/gesto/GestoUtils.ts","../src/react-moveable/utils.tsx","../src/react-moveable/ables/Pinchable.ts","../src/react-moveable/groupUtils.ts","../src/react-moveable/ables/snappable/utils.ts","../src/react-moveable/ables/snappable/snap.ts","../src/react-moveable/ables/snappable/innerBounds.ts","../src/react-moveable/ables/snappable/bounds.ts","../src/react-moveable/ables/snappable/render.tsx","../src/react-moveable/ables/snappable/snapBounds.ts","../src/react-moveable/ables/snappable/getTotalGuidelines.ts","../src/react-moveable/ables/Snappable.tsx","../src/react-moveable/renderDirections.tsx","../src/react-moveable/ables/Draggable.tsx","../src/react-moveable/ables/Resizable.ts","../src/react-moveable/ables/Rotatable.tsx","../src/react-moveable/ables/Scalable.ts","../src/react-moveable/ables/Warpable.tsx","../src/react-moveable/classNames.ts","../src/react-moveable/ables/DragArea.tsx","../src/react-moveable/ables/Origin.tsx","../src/react-moveable/ables/Scrollable.ts","../src/react-moveable/ables/Default.ts","../src/react-moveable/ables/Padding.tsx","../src/react-moveable/ables/roundable/borderRadius.tsx","../src/react-moveable/ables/Clippable.tsx","../src/react-moveable/ables/OriginDraggable.tsx","../src/react-moveable/ables/Roundable.tsx","../src/react-moveable/ables/BeforeRenderable.ts","../src/react-moveable/ables/Renderable.ts","../src/react-moveable/gesto/getAbleGesto.ts","../src/react-moveable/EventManager.ts","../src/react-moveable/utils/calculateMatrixStack.ts","../src/react-moveable/utils/getElementInfo.ts","../src/react-moveable/utils/getMoveableTargetInfo.ts","../src/react-moveable/MoveableManager.tsx","../src/react-moveable/ables/Groupable.tsx","../src/react-moveable/ables/Clickable.ts","../src/react-moveable/ables/edgeDraggable.tsx","../src/react-moveable/ables/IndividualGroupable.tsx","../src/react-moveable/ables/consts.ts","../src/react-moveable/MoveableGroup.tsx","../src/react-moveable/MoveableIndividualGroup.tsx","../src/react-moveable/InitialMoveable.tsx","../src/react-moveable/Moveable.tsx","../src/react-moveable/makeMoveable.ts","../src/react-moveable/index.umd.ts"],"sourcesContent":["import { Able, DefaultProps } from \"../types\";\n\nexport function makeAble<\n    Name extends string,\n    AbleObject extends Partial<Able<any, any>>,\n    Props extends DefaultProps<Name, AbleObject>,\n>(name: Name, able: AbleObject) {\n    return {\n        events: {} as const,\n        props: {\n            [name]: Boolean,\n        } as Props,\n        name,\n        ...able,\n    } as const;\n}\n","import getAgent from \"@egjs/agent\";\nimport { IObject } from \"@daybrush/utils\";\nimport { MoveableInterface } from \"./types\";\n\nfunction getSVGCursor(scale: number, degree: number) {\n    return `data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${32 * scale}px\" height=\"${32 * scale}px\" viewBox=\"0 0 32 32\" ><path d=\"M 16,5 L 12,10 L 14.5,10 L 14.5,22 L 12,22 L 16,27 L 20,22 L 17.5,22 L 17.5,10 L 20, 10 L 16,5 Z\" stroke-linejoin=\"round\" stroke-width=\"1.2\" fill=\"black\" stroke=\"white\" style=\"transform:rotate(${degree}deg);transform-origin: 16px 16px\"></path></svg>`;\n}\nfunction getCursorCSS(degree: number) {\n    const x1 = getSVGCursor(1, degree);\n    // const x2 = getSVGCursor(2, degree);\n    const degree45 = (Math.round(degree / 45) * 45) % 180;\n    let defaultCursor = \"ns-resize\";\n\n    if (degree45 === 135) {\n        defaultCursor = \"nwse-resize\";\n    } else if (degree45 === 45) {\n        defaultCursor = \"nesw-resize\";\n    } else if (degree45 === 90) {\n        defaultCursor = \"ew-resize\";\n    }\n\n    // tslint:disable-next-line: max-line-length\n    return `cursor:${defaultCursor};cursor: url('${x1}') 16 16, ${defaultCursor};`;\n}\n\nexport const agent = getAgent();\nexport const IS_WEBKIT = agent.browser.webkit;\nexport const IS_WEBKIT605 = IS_WEBKIT && (() => {\n    const navi = typeof window === \"undefined\" ? { userAgent: \"\" } : window.navigator;\n    const res = /applewebkit\\/([^\\s]+)/g.exec(navi.userAgent.toLowerCase());\n\n    return res ? parseFloat(res[1]) < 605 : false;\n})();\nexport const IS_SAFARI_ABOVE15\n    = parseInt(agent.browser.webkitVersion, 10) >= 612\n    || parseInt(agent.browser.version, 10) >= 15;\n\nexport const PREFIX = \"moveable-\";\nexport const MOVEABLE_CSS = `\n{\n\tposition: absolute;\n\twidth: 1px;\n\theight: 1px;\n\tleft: 0;\n\ttop: 0;\n    z-index: 3000;\n    --moveable-color: #4af;\n    --zoom: 1;\n    --zoompx: 1px;\n    will-change: transform;\n}\n.control-box {\n    z-index: 0;\n}\n.line, .control {\n    position: absolute;\n\tleft: 0;\n    top: 0;\n    will-change: transform;\n}\n.control {\n\twidth: 14px;\n\theight: 14px;\n\tborder-radius: 50%;\n\tborder: 2px solid #fff;\n\tbox-sizing: border-box;\n    background: #4af;\n    background: var(--moveable-color);\n\tmargin-top: -7px;\n    margin-left: -7px;\n    border: 2px solid #fff;\n    z-index: 10;\n}\n.padding {\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    width: 100px;\n    height: 100px;\n    transform-origin: 0 0;\n}\n.line {\n\twidth: 1px;\n    height: 1px;\n    background: #4af;\n    background: var(--moveable-color);\n\ttransform-origin: 0px 50%;\n}\n.line.edge {\n    z-index: 1;\n    background: transparent;\n}\n.line.dashed {\n    box-sizing: border-box;\n    background: transparent;\n}\n.line.dashed.horizontal {\n    border-top: 1px dashed #4af;\n    border-top-color: #4af;\n    border-top-color: var(--moveable-color);\n}\n.line.dashed.vertical {\n    border-left: 1px dashed #4af;\n    border-left-color: #4af;\n    border-left-color: var(--moveable-color);\n}\n.line.vertical {\n    transform: translateX(-50%);\n}\n.line.horizontal {\n    transform: translateY(-50%);\n}\n.line.vertical.bold {\n    width: 2px;\n}\n.line.horizontal.bold {\n    height: 2px;\n}\n\n.control.origin {\n\tborder-color: #f55;\n\tbackground: #fff;\n\twidth: 12px;\n\theight: 12px;\n\tmargin-top: -6px;\n    margin-left: -6px;\n\tpointer-events: none;\n}\n${[0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165].map(degree => `\n.direction[data-rotation=\"${degree}\"] {\n\t${getCursorCSS(degree)}\n}\n`).join(\"\\n\")}\n.group {\n    z-index: -1;\n}\n.area {\n    position: absolute;\n}\n.area-pieces {\n    position: absolute;\n    top: 0;\n    left: 0;\n    display: none;\n}\n.area.avoid, .area.pass {\n    pointer-events: none;\n}\n.area.avoid+.area-pieces {\n    display: block;\n}\n.area-piece {\n    position: absolute;\n}\n\n${IS_WEBKIT605 ? `:global svg *:before {\n\tcontent:\"\";\n\ttransform-origin: inherit;\n}` : \"\"}\n`;\nexport const DRAGGER_EVENTS = [\"dragstart\", \"drag\", \"dragend\", \"pinchstart\", \"pinch\", \"pinchend\"];\n\nexport const NEARBY_POS = [\n    [0, 1, 2],\n    [1, 0, 3],\n    [2, 0, 3],\n    [3, 1, 2],\n];\n\nexport const FLOAT_POINT_NUM = 0.0001;\nexport const TINY_NUM = 0.0000001;\nexport const MIN_SCALE = 0.000000001;\nexport const MAX_NUM = Math.pow(10, 10);\nexport const MIN_NUM = -MAX_NUM;\n\n\nexport const DIRECTIONS4 = [\"n\", \"w\", \"s\", \"e\"];\nexport const DIRECTIONS = [\"n\", \"w\", \"s\", \"e\", \"nw\", \"ne\", \"sw\", \"se\"];\n\nexport const DIRECTION_REGION_TO_DIRECTION: Record<string, number[]> = {\n    n: [0, -1],\n    e: [1, 0],\n    s: [0, 1],\n    w: [-1, 0],\n    nw: [-1, -1],\n    ne: [1, -1],\n    sw: [-1, 1],\n    se: [1, 1],\n};\n\nexport const DIRECTION_INDEXES: IObject<number[]> = {\n    n: [0, 1],\n    e: [1, 3],\n    s: [3, 2],\n    w: [2, 0],\n    nw: [0],\n    ne: [1],\n    sw: [2],\n    se: [3],\n};\nexport const DIRECTION_ROTATIONS: IObject<number> = {\n    n: 0,\n    s: 180,\n    w: 270,\n    e: 90,\n    nw: 315,\n    ne: 45,\n    sw: 225,\n    se: 135,\n};\n\nexport const MOVEABLE_METHODS: Array<keyof MoveableInterface> = [\n    \"isMoveableElement\",\n    \"updateRect\",\n    \"updateTarget\",\n    \"destroy\",\n    \"dragStart\",\n    \"isInside\",\n    \"hitTest\",\n    \"setState\",\n    \"getRect\",\n    \"request\",\n    \"isDragging\",\n    \"getManager\",\n    \"forceUpdate\",\n];\n","import { MoveableManagerState, OnCustomDrag } from \"../types\";\nimport { convertDragDist } from \"../utils\";\n\nexport function setCustomDrag(\n    e: any,\n    state: MoveableManagerState<any>,\n    delta: number[],\n    isPinch: boolean,\n    isConvert: boolean,\n    ableName = \"draggable\",\n) {\n    const result = state.gestos[ableName].move(delta, e.inputEvent);\n    const datas = result.originalDatas || result.datas;\n    const ableDatas = datas[ableName] || (datas[ableName] = {});\n\n    return {\n        ...(isConvert ? convertDragDist(state, result) : result),\n        isPinch: !!isPinch,\n        parentEvent: true,\n        datas: ableDatas,\n        originalDatas: e.originalDatas,\n    };\n}\n\nexport default class CustomGesto {\n    private prevX = 0;\n    private prevY = 0;\n    private startX = 0;\n    private startY = 0;\n    private isDrag = false;\n    private isFlag = false;\n    private datas: any = {\n        draggable: {},\n    };\n    constructor(private ableName = \"draggable\") {\n        this.datas = {\n            [ableName]: {},\n        };\n    }\n\n    public dragStart(client: number[], e: any) {\n        this.isDrag = false;\n        this.isFlag = false;\n        const originalDatas = e.originalDatas;\n\n        this.datas = originalDatas;\n        if (!originalDatas[this.ableName]) {\n            originalDatas[this.ableName] = {};\n        }\n        return {\n            ...this.move(client, e.inputEvent),\n            type: \"dragstart\",\n        };\n    }\n    public drag(client: number[], inputEvent: any) {\n        return this.move([\n            client[0] - this.prevX,\n            client[1] - this.prevY,\n        ], inputEvent);\n    }\n    public move(delta: number[], inputEvent: any): OnCustomDrag {\n        let clientX!: number;\n        let clientY!: number;\n        if (!this.isFlag) {\n            this.prevX = delta[0];\n            this.prevY = delta[1];\n            this.startX = delta[0];\n            this.startY = delta[1];\n\n            clientX = delta[0];\n            clientY = delta[1];\n\n            this.isFlag = true;\n        } else {\n            clientX = this.prevX + delta[0];\n            clientY = this.prevY + delta[1];\n\n            if (delta[0] || delta[1]) {\n                this.isDrag = true;\n            }\n        }\n\n        this.prevX = clientX;\n        this.prevY = clientY;\n\n        return {\n            type: \"drag\",\n            clientX,\n            clientY,\n            inputEvent,\n            isDrag: this.isDrag,\n            distX: clientX - this.startX,\n            distY: clientY - this.startY,\n            deltaX: delta[0],\n            deltaY: delta[1],\n            datas: this.datas[this.ableName],\n            originalDatas: this.datas,\n            parentEvent: true,\n            parentGesto: this,\n        };\n    }\n}\n","\nimport {\n    invert, calculate, minus, plus,\n    convertPositionMatrix,\n    createScaleMatrix, multiply, fromTranslation, convertDimension,\n} from \"@scena/matrix\";\nimport {\n    calculatePoses, getAbsoluteMatrix, getAbsolutePosesByState,\n    calculatePosition, calculateInversePosition, calculateMoveablePosition, convertTransformInfo, fillCSSObject,\n} from \"../utils\";\nimport { splitUnit, isArray, splitSpace, findIndex, dot, find } from \"@daybrush/utils\";\nimport {\n    MoveableManagerState, ResizableProps, MoveableManagerInterface,\n    OnTransformEvent, OnTransformStartEvent, DraggableProps, OnDrag,\n} from \"../types\";\nimport { setCustomDrag } from \"./CustomGesto\";\nimport { parse, parseMat } from \"css-to-mat\";\nimport { Draggable } from \"../index.esm\";\n\nexport function calculatePointerDist(moveable: MoveableManagerInterface, e: any) {\n    const { clientX, clientY, datas } = e;\n    const {\n        moveableClientRect,\n        rootMatrix,\n        is3d,\n        pos1,\n    } = moveable.state;\n    const { left, top } = moveableClientRect;\n    const n = is3d ? 4 : 3;\n    const [posX, posY] = minus(calculateInversePosition(rootMatrix, [clientX - left, clientY - top], n), pos1);\n    const [distX, distY] = getDragDist({ datas, distX: posX, distY: posY });\n\n    return [distX, distY];\n}\n\nexport function setDragStart(moveable: MoveableManagerInterface<any>, { datas }: any) {\n    const {\n        allMatrix,\n        beforeMatrix,\n        is3d,\n        left,\n        top,\n        origin,\n        offsetMatrix,\n        targetMatrix,\n        transformOrigin,\n    } = moveable.state;\n    const n = is3d ? 4 : 3;\n\n    datas.is3d = is3d;\n    datas.matrix = allMatrix;\n    datas.targetMatrix = targetMatrix;\n    datas.beforeMatrix = beforeMatrix;\n    datas.offsetMatrix = offsetMatrix;\n    datas.transformOrigin = transformOrigin;\n    datas.inverseMatrix = invert(allMatrix, n);\n    datas.inverseBeforeMatrix = invert(beforeMatrix, n);\n    datas.absoluteOrigin = convertPositionMatrix(plus([left, top], origin), n);\n    datas.startDragBeforeDist = calculate(datas.inverseBeforeMatrix, datas.absoluteOrigin, n);\n    datas.startDragDist = calculate(datas.inverseMatrix, datas.absoluteOrigin, n);\n}\nexport function getTransformDirection(e: any) {\n    return calculateMoveablePosition(e.datas.beforeTransform, [50, 50], 100, 100).direction;\n}\nexport function resolveTransformEvent(event: any, functionName: string) {\n    const {\n        datas,\n        originalDatas: {\n            beforeRenderable: originalDatas,\n        },\n    } = event;\n\n    const index = datas.transformIndex;\n\n\n    const nextTransforms = originalDatas.nextTransforms;\n    const length = nextTransforms.length;\n    const nextTransformAppendedIndexes: any[] = originalDatas.nextTransformAppendedIndexes;\n    let nextIndex = 0;\n\n    if (index === -1) {\n        nextIndex = nextTransforms.length;\n        datas.transformIndex = nextIndex;\n    } else if (find(nextTransformAppendedIndexes, info => info.index === index && info.functionName === functionName)) {\n        nextIndex = index;\n    } else {\n        nextIndex = index + nextTransformAppendedIndexes.filter(info => info.index < index).length;\n    }\n\n    const result = convertTransformInfo(nextTransforms, nextIndex);\n    const targetFunction = result.targetFunction;\n    const matFunctionName = functionName === \"rotate\" ? \"rotateZ\" : functionName;\n\n    datas.beforeFunctionTexts = result.beforeFunctionTexts;\n    datas.afterFunctionTexts = result.afterFunctionTexts;\n    datas.beforeTransform = result.beforeFunctionMatrix;\n    datas.beforeTransform2 = result.beforeFunctionMatrix2;\n    datas.targetTansform = result.targetFunctionMatrix;\n    datas.afterTransform = result.afterFunctionMatrix;\n    datas.afterTransform2 = result.afterFunctionMatrix2;\n    datas.targetAllTransform = result.allFunctionMatrix;\n\n    if (targetFunction.functionName === matFunctionName) {\n        datas.afterFunctionTexts.splice(0, 1);\n        datas.isAppendTransform = false;\n    } else if (length > nextIndex) {\n        datas.isAppendTransform = true;\n\n        originalDatas.nextTransformAppendedIndexes = [...nextTransformAppendedIndexes, {\n            functionName,\n            index: nextIndex,\n            isAppend: true,\n        }];\n    }\n}\n\nexport function convertTransformFormat(datas: any, value: any, dist: any) {\n    return `${datas.beforeFunctionTexts.join(\" \")} ${datas.isAppendTransform ? dist : value} ${datas.afterFunctionTexts.join(\" \")}`;\n}\nexport function getTransformDist({ datas, distX, distY }: any) {\n    const [bx, by] = getBeforeDragDist({ datas, distX, distY });\n    // B * [tx, ty] * A = [bx, by] * targetMatrix;\n    // [tx, ty] = B-1 * [bx, by] * targetMatrix * A-1 * [0, 0];\n\n    const res = getTransfromMatrix(datas, fromTranslation([bx, by], 4));\n\n    return calculate(res, convertPositionMatrix([0, 0, 0], 4), 4);\n}\nexport function getTransfromMatrix(datas: any, targetMatrix: number[], isAfter?: boolean) {\n    const {\n        beforeTransform,\n        afterTransform,\n        beforeTransform2,\n        afterTransform2,\n        targetAllTransform,\n    } = datas;\n\n    // B * afterTargetMatrix * A = (targetMatrix * targetAllTransform)\n    // afterTargetMatrix = B-1 * targetMatrix * targetAllTransform * A-1\n    // nextTargetMatrix = (targetMatrix * targetAllTransform)\n    const nextTargetMatrix\n        = isAfter\n            ? multiply(targetAllTransform, targetMatrix, 4)\n            : multiply(targetMatrix, targetAllTransform, 4);\n\n    // res1 = B-1 * nextTargetMatrix\n    const res1 = multiply(invert(isAfter ? beforeTransform2 : beforeTransform, 4), nextTargetMatrix, 4);\n\n    // res3 = res2 * A-1\n    const afterTargetMatrix = multiply(res1, invert(isAfter ? afterTransform2 : afterTransform, 4), 4);\n\n    return afterTargetMatrix;\n}\nexport function getBeforeDragDist({ datas, distX, distY }: any) {\n    // TT = BT\n    const {\n        inverseBeforeMatrix,\n        is3d,\n        startDragBeforeDist,\n        absoluteOrigin,\n    } = datas;\n    const n = is3d ? 4 : 3;\n\n    // ABS_ORIGIN * [distX, distY] = BM * (ORIGIN + [tx, ty])\n    // BM -1 * ABS_ORIGIN * [distX, distY] - ORIGIN = [tx, ty]\n    return minus(\n        calculate(\n            inverseBeforeMatrix,\n            plus(absoluteOrigin, [distX, distY]),\n            n,\n        ),\n        startDragBeforeDist,\n    );\n}\nexport function getDragDist({ datas, distX, distY }: any, isBefore?: boolean) {\n    const {\n        inverseBeforeMatrix,\n        inverseMatrix,\n        is3d,\n        startDragBeforeDist,\n        startDragDist,\n        absoluteOrigin,\n    } = datas;\n    const n = is3d ? 4 : 3;\n\n    return minus(\n        calculate(\n            isBefore ? inverseBeforeMatrix : inverseMatrix,\n            plus(absoluteOrigin, [distX, distY]),\n            n,\n        ),\n        isBefore ? startDragBeforeDist : startDragDist,\n    );\n}\nexport function getInverseDragDist({ datas, distX, distY }: any, isBefore?: boolean) {\n    const {\n        beforeMatrix,\n        matrix,\n        is3d,\n        startDragBeforeDist,\n        startDragDist,\n        absoluteOrigin,\n    } = datas;\n    const n = is3d ? 4 : 3;\n\n    return minus(\n        calculate(\n            isBefore ? beforeMatrix : matrix,\n            plus(isBefore ? startDragBeforeDist : startDragDist, [distX, distY]),\n            n,\n        ),\n        absoluteOrigin,\n    );\n}\n\nexport function calculateTransformOrigin(\n    transformOrigin: string[],\n    width: number,\n    height: number,\n    prevWidth: number = width,\n    prevHeight: number = height,\n    prevOrigin: number[] = [0, 0],\n) {\n\n    if (!transformOrigin) {\n        return prevOrigin;\n    }\n    return transformOrigin.map((pos, i) => {\n        const { value, unit } = splitUnit(pos);\n\n        const prevSize = (i ? prevHeight : prevWidth);\n        const size = (i ? height : width);\n        if (pos === \"%\" || isNaN(value)) {\n            // no value but %\n\n            const measureRatio = prevSize ? prevOrigin[i] / prevSize : 0;\n\n            return size * measureRatio;\n        } else if (unit !== \"%\") {\n            return value;\n        }\n        return size * value / 100;\n    });\n}\nexport function getPosIndexesByDirection(direction: number[]) {\n    const indexes: number[] = [];\n\n    if (direction[1] >= 0) {\n        if (direction[0] >= 0) {\n            indexes.push(3);\n        }\n        if (direction[0] <= 0) {\n            indexes.push(2);\n        }\n    }\n    if (direction[1] <= 0) {\n        if (direction[0] >= 0) {\n            indexes.push(1);\n        }\n        if (direction[0] <= 0) {\n            indexes.push(0);\n        }\n    }\n    return indexes;\n}\nexport function getPosesByDirection(\n    poses: number[][],\n    direction: number[],\n) {\n    /*\n    [-1, -1](pos1)       [0, -1](pos1,pos2)       [1, -1](pos2)\n    [-1, 0](pos1, pos3)                           [1, 0](pos2, pos4)\n    [-1, 1](pos3)        [0, 1](pos3, pos4)       [1, 1](pos4)\n    */\n    return getPosIndexesByDirection(direction).map(index => poses[index]);\n}\nexport function getPosByDirection(\n    poses: number[][],\n    direction: number[],\n) {\n    const xRatio = (direction[0] + 1) / 2;\n    const yRatio = (direction[1] + 1) / 2;\n\n    const top = [\n        dot(poses[0][0], poses[1][0], xRatio, 1 - xRatio),\n        dot(poses[0][1], poses[1][1], xRatio, 1 - xRatio),\n    ];\n    const bottom = [\n        dot(poses[2][0], poses[3][0], xRatio, 1 - xRatio),\n        dot(poses[2][1], poses[3][1], xRatio, 1 - xRatio),\n    ];\n    return [\n        dot(top[0], bottom[0], yRatio, 1 - yRatio),\n        dot(top[1], bottom[1], yRatio, 1 - yRatio),\n    ];\n}\n\nfunction getDist(\n    startPos: number[],\n    matrix: number[],\n    width: number,\n    height: number,\n    n: number,\n    fixedDirection: number[],\n) {\n    const poses = calculatePoses(matrix, width, height, n);\n    const fixedPos = getPosByDirection(poses, fixedDirection);\n    const distX = startPos[0] - fixedPos[0];\n    const distY = startPos[1] - fixedPos[1];\n\n    return [distX, distY];\n}\nexport function getNextMatrix(\n    offsetMatrix: number[],\n    targetMatrix: number[],\n    origin: number[],\n    n: number,\n) {\n    return multiply(\n        offsetMatrix,\n        getAbsoluteMatrix(targetMatrix, n, origin),\n        n,\n    );\n}\nexport function getNextTransformMatrix(\n    state: MoveableManagerState<any>,\n    datas: any,\n    transform: string,\n) {\n    const {\n        transformOrigin,\n        offsetMatrix,\n        is3d,\n    } = state;\n    const {\n        beforeTransform,\n        afterTransform,\n    } = datas;\n    const n = is3d ? 4 : 3;\n    const targetTransform = parseMat([transform]);\n\n    return getNextMatrix(\n        offsetMatrix,\n        convertDimension(multiply(multiply(beforeTransform, targetTransform as any, 4), afterTransform, 4), 4, n),\n        transformOrigin,\n        n,\n    );\n}\nexport function scaleMatrix(\n    state: MoveableManagerState<any>,\n    scale: number[],\n) {\n    const {\n        transformOrigin,\n        offsetMatrix,\n        is3d,\n        targetMatrix,\n    } = state;\n    const n = is3d ? 4 : 3;\n\n    return getNextMatrix(\n        offsetMatrix,\n        multiply(targetMatrix, createScaleMatrix(scale, n), n),\n        transformOrigin,\n        n,\n    );\n}\n\nexport function fillTransformStartEvent(e: any): OnTransformStartEvent {\n    const originalDatas = getBeforeRenderableDatas(e);\n    return {\n        setTransform: (transform: string | string[], index = -1) => {\n            originalDatas.startTransforms = isArray(transform) ? transform : splitSpace(transform);\n            setTransformIndex(e, index);\n        },\n        setTransformIndex: (index: number) => {\n            setTransformIndex(e, index);\n        },\n    };\n}\nexport function setDefaultTransformIndex(e: any, property: string) {\n    const originalDatas = getBeforeRenderableDatas(e);\n    const startTransforms = originalDatas.startTransforms;\n\n    setTransformIndex(e, findIndex<string>(startTransforms, func => func.indexOf(`${property}(`) === 0));\n}\nexport function setTransformIndex(e: any, index: number) {\n    const originalDatas = getBeforeRenderableDatas(e);\n    const datas = e.datas;\n\n    datas.transformIndex = index;\n    if (index === -1) {\n        return;\n    }\n    const transform = originalDatas.startTransforms[index];\n\n    if (!transform) {\n        return;\n    }\n    const info = parse([transform]);\n\n    datas.startValue = info[0].functionValue;\n}\nexport function fillOriginalTransform(\n    e: any,\n    transform: string,\n) {\n    const originalDatas = getBeforeRenderableDatas(e);\n\n    originalDatas.nextTransforms = splitSpace(transform);\n    // originalDatas.nextTargetMatrix = parseMat(transform);\n}\nexport function getBeforeRenderableDatas(e: any) {\n    return e.originalDatas.beforeRenderable;\n}\nexport function getNextTransforms(e: any) {\n    const {\n        originalDatas: {\n            beforeRenderable: originalDatas,\n        },\n    } = e;\n\n    return originalDatas.nextTransforms;\n}\nexport function getNextTransformText(e: any) {\n    return getNextTransforms(e).join(\" \");\n}\n\nexport function getNextStyle(e: any) {\n    return getBeforeRenderableDatas(e).nextStyle;\n}\n\nexport function fillTransformEvent(\n    moveable: MoveableManagerInterface<DraggableProps>,\n    nextTransform: string,\n    delta: number[],\n    isPinch: boolean,\n    e: any,\n): OnTransformEvent {\n    fillOriginalTransform(e, nextTransform);\n\n    const drag = Draggable.drag!(\n        moveable,\n        setCustomDrag(e, moveable.state, delta, isPinch, false),\n    ) as OnDrag;\n    const afterTransform = drag ? drag.transform : nextTransform;\n    return {\n        transform: nextTransform,\n        drag: drag as OnDrag,\n        ...fillCSSObject({\n            transform: afterTransform,\n        }, e),\n        afterTransform,\n    };\n}\nexport function getTranslateDist(\n    moveable: MoveableManagerInterface<any>,\n    transform: string,\n    fixedDirection: number[],\n    fixedPosition: number[],\n    datas: any,\n) {\n    const state = moveable.state;\n    const {\n        left,\n        top,\n    } = state;\n\n    const groupable = moveable.props.groupable;\n    const nextMatrix = getNextTransformMatrix(moveable.state, datas, transform);\n    const groupLeft = groupable ? left : 0;\n    const groupTop = groupable ? top : 0;\n    const nextFixedPosition = getDirectionOffset(moveable, fixedDirection, nextMatrix);\n    const dist = minus(fixedPosition, nextFixedPosition);\n    return minus(dist, [groupLeft, groupTop]);\n}\nexport function getScaleDist(\n    moveable: MoveableManagerInterface<any>,\n    scaleDist: number[],\n    fixedDirection: number[],\n    fixedPosition: number[],\n    datas: any,\n) {\n    const dist = getTranslateDist(\n        moveable,\n        `scale(${scaleDist.join(\", \")})`,\n        fixedDirection,\n        fixedPosition,\n        datas,\n    );\n\n    return dist;\n}\nexport function getOriginDirection(moveable: MoveableManagerInterface<any>) {\n    const {\n        width,\n        height,\n        transformOrigin,\n    } = moveable.state;\n    return [\n        -1 + transformOrigin[0] / (width / 2),\n        -1 + transformOrigin[1] / (height / 2),\n    ];\n}\nexport function getDirectionOffset(\n    moveable: MoveableManagerInterface, direction: number[],\n    nextMatrix: number[] = moveable.state.allMatrix,\n) {\n    const {\n        width,\n        height,\n        is3d,\n    } = moveable.state;\n    const n = is3d ? 4 : 3;\n    const nextFixedOffset = [\n        width / 2 * (1 + direction[0]),\n        height / 2 * (1 + direction[1]),\n    ];\n    return calculatePosition(nextMatrix, nextFixedOffset, n);\n}\nexport function getRotateDist(\n    moveable: MoveableManagerInterface<any>,\n    rotateDist: number,\n    datas: any,\n) {\n    const fixedDirection = datas.fixedDirection;\n    const fixedPosition = datas.fixedPosition;\n\n    return getTranslateDist(\n        moveable,\n        `rotate(${rotateDist}deg)`,\n        fixedDirection,\n        fixedPosition,\n        datas,\n    );\n}\nexport function getResizeDist(\n    moveable: MoveableManagerInterface<any>,\n    width: number,\n    height: number,\n    fixedPosition: number[],\n    transformOrigin: string[],\n    datas: any,\n) {\n    const {\n        groupable,\n    } = moveable.props;\n    const state = moveable.state;\n    const {\n        transformOrigin: prevOrigin,\n        offsetMatrix,\n        is3d,\n        width: prevWidth,\n        height: prevHeight,\n        left,\n        top,\n    } = state;\n    const fixedDirection = datas.fixedDirection;\n    const targetMatrix = datas.nextTargetMatrix || state.targetMatrix;\n    const n = is3d ? 4 : 3;\n    const nextOrigin = calculateTransformOrigin(\n        transformOrigin!,\n        width,\n        height,\n        prevWidth,\n        prevHeight,\n        prevOrigin,\n    );\n    const groupLeft = groupable ? left : 0;\n    const groupTop = groupable ? top : 0;\n    const nextMatrix = getNextMatrix(offsetMatrix, targetMatrix, nextOrigin, n);\n    const dist = getDist(fixedPosition, nextMatrix, width, height, n, fixedDirection);\n\n    return minus(dist, [groupLeft, groupTop]);\n}\nexport function getAbsolutePosition(\n    moveable: MoveableManagerInterface<ResizableProps>,\n    direction: number[],\n) {\n    return getPosByDirection(getAbsolutePosesByState(moveable.state), direction);\n}\n","import { PREFIX, IS_WEBKIT605, TINY_NUM, IS_WEBKIT, IS_SAFARI_ABOVE15 } from \"./consts\";\nimport { prefixNames, InvertObject } from \"framework-utils\";\nimport {\n    isUndefined, isObject, splitUnit,\n    IObject, hasClass, isArray, isString, getRad,\n    getShapeDirection, isFunction, convertUnitSize, between, getKeys,\n} from \"@daybrush/utils\";\nimport {\n    multiply, invert,\n    convertDimension, createIdentityMatrix,\n    createOriginMatrix, convertPositionMatrix, calculate,\n    multiplies,\n    minus,\n    createScaleMatrix,\n    plus,\n    convertCSStoMatrix,\n    convertMatrixtoCSS,\n} from \"@scena/matrix\";\nimport {\n    MoveableManagerState, Able, MoveableClientRect,\n    MoveableProps, ArrayFormat, MoveableRefType,\n    MatrixInfo, ExcludeEndParams, ExcludeParams,\n    ElementSizes, MoveablePosition, TransformObject,\n} from \"./types\";\nimport { parse, toMat, calculateMatrixDist, parseMat } from \"css-to-mat\";\nimport { getBeforeRenderableDatas, getDragDist } from \"./gesto/GestoUtils\";\n\nexport function round(num: number) {\n    return Math.round(num);\n}\nexport function multiply2(pos1: number[], pos2: number[]) {\n    return [\n        pos1[0] * pos2[0],\n        pos1[1] * pos2[1],\n    ];\n}\nexport function prefix(...classNames: string[]) {\n    return prefixNames(PREFIX, ...classNames);\n}\n\nexport function defaultSync(fn: () => void) {\n    fn();\n}\n\nexport function createIdentityMatrix3() {\n    return createIdentityMatrix(3);\n}\n\nexport function getTransformMatrix(transform: string | number[]) {\n    if (!transform || transform === \"none\") {\n        return [1, 0, 0, 1, 0, 0];\n\n    }\n    if (isObject(transform)) {\n        return transform;\n    }\n    return parseMat(transform);\n}\nexport function getAbsoluteMatrix(matrix: number[], n: number, origin: number[]) {\n    return multiplies(\n        n,\n        createOriginMatrix(origin, n),\n        matrix,\n        createOriginMatrix(origin.map(a => -a), n),\n    );\n}\nexport function measureSVGSize(el: SVGElement, unit: string, isHorizontal: boolean) {\n    if (unit === \"%\") {\n        const viewBox = getSVGViewBox(el.ownerSVGElement!);\n\n        return viewBox[isHorizontal ? \"width\" : \"height\"] / 100;\n    }\n    return 1;\n}\nexport function getBeforeTransformOrigin(el: SVGElement) {\n    const relativeOrigin = getTransformOrigin(getComputedStyle(el, \":before\"));\n\n    return relativeOrigin.map((o, i) => {\n        const { value, unit } = splitUnit(o);\n\n        return value * measureSVGSize(el, unit, i === 0);\n    });\n}\nexport function getTransformOrigin(style: CSSStyleDeclaration) {\n    const transformOrigin = style.transformOrigin;\n\n    return transformOrigin ? transformOrigin.split(\" \") : [\"0\", \"0\"];\n}\nexport function getElementTransform(\n    target: HTMLElement | SVGElement,\n    computedStyle = getComputedStyle(target),\n) {\n    const computedTransform = computedStyle.transform;\n\n    if (computedTransform && computedTransform !== \"none\") {\n        return computedStyle.transform;\n    }\n    if (\"transform\" in target) {\n        const list = (target as any).transform as SVGAnimatedTransformList;\n        const baseVal = list.baseVal;\n\n        if (!baseVal) {\n            return \"\";\n        }\n        const length = baseVal.length;\n\n        if (!length) {\n            return \"\";\n        }\n\n        const matrixes: string[] = [];\n\n        for (let i = 0; i < length; ++i) {\n            const matrix = baseVal[i].matrix;\n\n            matrixes.push(`matrix(${([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"] as const).map(chr => matrix[chr]).join(\", \")})`);\n        }\n        return matrixes.join(\" \");\n\n    }\n    return \"\";\n}\nexport function getOffsetInfo(\n    el: SVGElement | HTMLElement | null | undefined,\n    lastParent: SVGElement | HTMLElement | null | undefined,\n    isParent?: boolean,\n) {\n    const body = document.body;\n    let target = !el || isParent\n        ? el\n        : el?.assignedSlot?.parentElement || el.parentElement;\n\n    let isCustomElement = false;\n    let isEnd = el === lastParent || target === lastParent;\n    let position = \"relative\";\n\n\n\n    while (target && target !== body) {\n        if (lastParent === target) {\n            isEnd = true;\n        }\n        const style = getComputedStyle(target);\n        const tagName = target.tagName.toLowerCase();\n        const transform = getElementTransform(target as SVGElement, style);\n        const willChange = style.willChange;\n        position = style.position!;\n\n        if (\n            tagName === \"svg\"\n            || position !== \"static\"\n            || (transform && transform !== \"none\")\n            || willChange === \"transform\"\n        ) {\n            break;\n        }\n        const parentNode = target.parentNode;\n\n        if (parentNode && parentNode.nodeType === 11) {\n            // Shadow Root\n            target = (parentNode as ShadowRoot).host as HTMLElement;\n            console.log('target (shadow root):', target);\n            isCustomElement = true;\n            break;\n        }\n        \n        target = parentNode as HTMLElement | SVGElement;\n        console.log('target (not shadow root):', target);\n        position = \"relative\";\n    }\n    return {\n        isCustomElement,\n        isStatic: position === \"static\",\n        isEnd: isEnd || !target || target === body,\n        offsetParent: target as HTMLElement || body,\n    };\n\n}\nexport function getOffsetPosInfo(\n    el: HTMLElement | SVGElement,\n    style: CSSStyleDeclaration,\n) {\n    const tagName = el.tagName.toLowerCase();\n    let offsetLeft = (el as HTMLElement).offsetLeft;\n    let offsetTop = (el as HTMLElement).offsetTop;\n\n    // svg\n    const isSVG = isUndefined(offsetLeft);\n    let hasOffset = !isSVG;\n    let origin: number[];\n    let targetOrigin: number[];\n    // inner svg element\n    if (!hasOffset && tagName !== \"svg\") {\n        origin = IS_WEBKIT605\n            ? getBeforeTransformOrigin(el as SVGElement)\n            : getTransformOrigin(style).map(pos => parseFloat(pos));\n\n        targetOrigin = origin.slice();\n        hasOffset = true;\n\n        [\n            offsetLeft, offsetTop, origin[0], origin[1],\n        ] = getSVGGraphicsOffset(el as SVGGraphicsElement, origin);\n    } else {\n        origin = getTransformOrigin(style).map(pos => parseFloat(pos));\n        targetOrigin = origin.slice();\n    }\n    return {\n        tagName,\n        isSVG,\n        hasOffset,\n        offset: [offsetLeft || 0, offsetTop || 0],\n        origin,\n        targetOrigin,\n    };\n}\nexport function getBodyOffset(\n    el: HTMLElement | SVGElement,\n    isSVG: boolean,\n    style: CSSStyleDeclaration = getComputedStyle(el),\n) {\n    const bodyStyle = getComputedStyle(document.body);\n    const bodyPosition = bodyStyle.position;\n    if (!isSVG && (!bodyPosition || bodyPosition === \"static\")) {\n        return [0, 0];\n    }\n\n    let marginLeft = parseInt(bodyStyle.marginLeft, 10);\n    let marginTop = parseInt(bodyStyle.marginTop, 10);\n\n    if (style.position === \"absolute\") {\n        if (style.top !== \"auto\" || style.bottom !== \"auto\") {\n            marginTop = 0;\n        }\n        if (style.left !== \"auto\" || style.right !== \"auto\") {\n            marginLeft = 0;\n        }\n    }\n\n    return [marginLeft, marginTop];\n}\nexport function convert3DMatrixes(matrixes: MatrixInfo[]) {\n    matrixes.forEach(info => {\n        const matrix = info.matrix;\n\n        if (matrix) {\n            info.matrix = convertDimension(matrix, 3, 4);\n        }\n    });\n}\n\nexport function getBodyScrollPos() {\n    return [\n        document.documentElement.scrollLeft || document.body.scrollLeft,\n        document.documentElement.scrollTop || document.body.scrollTop,\n    ];\n}\n\nexport function getPositionFixedInfo(el: HTMLElement | SVGElement) {\n    let fixedContainer = el.parentElement;\n    let hasTransform = false;\n\n    while (fixedContainer) {\n        const transform = getComputedStyle(fixedContainer).transform;\n\n\n        if (transform && transform !== \"none\") {\n            hasTransform = true;\n            break;\n        }\n        if (fixedContainer === document.body) {\n            break;\n        }\n        fixedContainer = fixedContainer.parentElement;\n    }\n\n    return {\n        fixedContainer: fixedContainer || document.body,\n        hasTransform,\n    };\n}\n\nexport function getMatrixStackInfo(\n    target: SVGElement | HTMLElement,\n    container?: SVGElement | HTMLElement | null,\n    checkContainer?: boolean,\n) {\n    let el: SVGElement | HTMLElement | null = target;\n    const matrixes: MatrixInfo[] = [];\n    let requestEnd = !checkContainer && target === container || target === document.body;\n    let isEnd = requestEnd;\n    let is3d = false;\n    let n = 3;\n    let transformOrigin!: number[];\n    let targetTransformOrigin!: number[];\n    let targetMatrix!: number[];\n\n    let hasFixed = false;\n    let offsetContainer = getOffsetInfo(container, container, true).offsetParent;\n\n    while (el && !isEnd) {\n        isEnd = requestEnd;\n        const style: CSSStyleDeclaration = getComputedStyle(el);\n        const position = style.position;\n        const transform = getElementTransform(el, style);\n        let matrix: number[] = convertCSStoMatrix(getTransformMatrix(transform));\n        const isFixed = position === \"fixed\";\n        let fixedInfo: {\n            hasTransform: boolean;\n            fixedContainer: HTMLElement | null;\n        } = {\n            hasTransform: false,\n            fixedContainer: null,\n        };\n        if (isFixed) {\n            hasFixed = true;\n            fixedInfo = getPositionFixedInfo(el);\n\n            offsetContainer = fixedInfo.fixedContainer!;\n        }\n\n        // convert 3 to 4\n        const length = matrix.length;\n\n        if (!is3d && length === 16) {\n            is3d = true;\n            n = 4;\n\n            convert3DMatrixes(matrixes);\n            if (targetMatrix) {\n                targetMatrix = convertDimension(targetMatrix, 3, 4);\n            }\n        }\n        if (is3d && length === 9) {\n            matrix = convertDimension(matrix, 3, 4);\n        }\n        const {\n            tagName,\n            hasOffset,\n            isSVG,\n            origin,\n            targetOrigin,\n            offset: offsetPos,\n        } = getOffsetPosInfo(el, style);\n        let [\n            offsetLeft,\n            offsetTop,\n        ] = offsetPos;\n        if (tagName === \"svg\" && targetMatrix) {\n            // scale matrix for svg's SVGElements.\n            matrixes.push({\n                type: \"target\",\n                target: el,\n                matrix: getSVGMatrix(el as SVGSVGElement, n),\n            });\n            matrixes.push({\n                type: \"offset\",\n                target: el,\n                matrix: createIdentityMatrix(n),\n            });\n        } else if (tagName === \"g\" && target !== el) {\n            offsetLeft = 0;\n            offsetTop = 0;\n        }\n\n        let offsetParent: HTMLElement;\n        let isOffsetEnd = false;\n        let isStatic = false;\n\n        if (isFixed) {\n            offsetParent = fixedInfo.fixedContainer!;\n            isOffsetEnd = true;\n        } else {\n            const offsetInfo = getOffsetInfo(el, container);\n\n            offsetParent = offsetInfo.offsetParent;\n            isOffsetEnd = offsetInfo.isEnd;\n            isStatic = offsetInfo.isStatic;\n        }\n\n        if (\n            IS_WEBKIT && !IS_SAFARI_ABOVE15\n            && hasOffset && !isSVG && isStatic\n            && (position === \"relative\" || position === \"static\")\n        ) {\n            offsetLeft -= offsetParent.offsetLeft;\n            offsetTop -= offsetParent.offsetTop;\n            requestEnd = requestEnd || isOffsetEnd;\n        }\n        let parentClientLeft = 0;\n        let parentClientTop = 0;\n        let fixedClientLeft = 0;\n        let fixedClientTop = 0;\n\n        if (isFixed) {\n            if (hasOffset && fixedInfo.hasTransform) {\n                // border\n                fixedClientLeft = offsetParent.clientLeft;\n                fixedClientTop = offsetParent.clientTop;\n            }\n        } else {\n            if (hasOffset && offsetContainer !== offsetParent) {\n                // border\n                parentClientLeft = offsetParent.clientLeft;\n                parentClientTop = offsetParent.clientTop;\n            }\n            if (hasOffset && offsetParent === document.body) {\n                const margin = getBodyOffset(el, false, style);\n\n                offsetLeft += margin[0];\n                offsetTop += margin[1];\n            }\n        }\n\n        matrixes.push({\n            type: \"target\",\n            target: el,\n            matrix: getAbsoluteMatrix(matrix, n, origin),\n        });\n        if (hasOffset) {\n            matrixes.push({\n                type: \"offset\",\n                target: el,\n                matrix: createOriginMatrix([\n                    offsetLeft - el.scrollLeft + parentClientLeft - fixedClientLeft,\n                    offsetTop - el.scrollTop + parentClientTop - fixedClientTop,\n                ], n),\n            });\n        } else {\n            // svg\n            matrixes.push({\n                type: \"offset\",\n                target: el,\n                origin,\n            });\n        }\n        if (!targetMatrix) {\n            targetMatrix = matrix;\n        }\n        if (!transformOrigin) {\n            transformOrigin = origin;\n        }\n        if (!targetTransformOrigin) {\n            targetTransformOrigin = targetOrigin;\n        }\n\n        if (isEnd || isFixed) {\n            break;\n        } else {\n            el = offsetParent;\n            requestEnd = isOffsetEnd;\n        }\n        if (!checkContainer || el === document.body) {\n            isEnd = requestEnd;\n        }\n    }\n    if (!targetMatrix) {\n        targetMatrix = createIdentityMatrix(n);\n    }\n    if (!transformOrigin) {\n        transformOrigin = [0, 0];\n    }\n    if (!targetTransformOrigin) {\n        targetTransformOrigin = [0, 0];\n    }\n\n    return {\n        offsetContainer,\n        matrixes,\n        targetMatrix,\n        transformOrigin,\n        targetOrigin: targetTransformOrigin,\n        is3d,\n        hasFixed,\n    };\n}\n\nexport function makeMatrixCSS(matrix: number[], is3d: boolean = matrix.length > 9) {\n    return `${is3d ? \"matrix3d\" : \"matrix\"}(${convertMatrixtoCSS(matrix, !is3d).join(\",\")})`;\n}\nexport function getSVGViewBox(el: SVGSVGElement) {\n    const clientWidth = el.clientWidth;\n    const clientHeight = el.clientHeight;\n\n    if (!el) {\n        return { x: 0, y: 0, width: 0, height: 0, clientWidth, clientHeight };\n    }\n    const viewBox = el.viewBox;\n    const baseVal = (viewBox && viewBox.baseVal) || { x: 0, y: 0, width: 0, height: 0 };\n\n    return {\n        x: baseVal.x,\n        y: baseVal.y,\n        width: baseVal.width || clientWidth,\n        height: baseVal.height || clientHeight,\n        clientWidth,\n        clientHeight,\n    };\n}\nexport function getSVGMatrix(\n    el: SVGSVGElement,\n    n: number,\n) {\n    const {\n        width: viewBoxWidth,\n        height: viewBoxHeight,\n        clientWidth,\n        clientHeight,\n    } = getSVGViewBox(el);\n    const scaleX = clientWidth / viewBoxWidth;\n    const scaleY = clientHeight / viewBoxHeight;\n\n    const preserveAspectRatio = el.preserveAspectRatio.baseVal;\n    // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/preserveAspectRatio\n    const align = preserveAspectRatio.align;\n    // 1 : meet 2: slice\n    const meetOrSlice = preserveAspectRatio.meetOrSlice;\n    const svgOrigin = [0, 0];\n    const scale = [scaleX, scaleY];\n    const translate = [0, 0];\n\n    if (align !== 1) {\n        const xAlign = (align - 2) % 3;\n        const yAlign = Math.floor((align - 2) / 3);\n\n        svgOrigin[0] = viewBoxWidth * xAlign / 2;\n        svgOrigin[1] = viewBoxHeight * yAlign / 2;\n\n        const scaleDimension = meetOrSlice === 2 ? Math.max(scaleY, scaleX) : Math.min(scaleX, scaleY);\n\n        scale[0] = scaleDimension;\n        scale[1] = scaleDimension;\n\n        translate[0] = (clientWidth - viewBoxWidth) / 2 * xAlign;\n        translate[1] = (clientHeight - viewBoxHeight) / 2 * yAlign;\n    }\n    const scaleMatrix = createScaleMatrix(scale, n);\n    [\n        scaleMatrix[n * (n - 1)],\n        scaleMatrix[n * (n - 1) + 1],\n    ] = translate;\n\n    return getAbsoluteMatrix(\n        scaleMatrix,\n        n,\n        svgOrigin,\n    );\n}\nexport function getSVGGraphicsOffset(\n    el: SVGGraphicsElement,\n    origin: number[],\n) {\n    if (!el.getBBox || el.tagName.toLowerCase() === \"g\") {\n        return [0, 0, 0, 0];\n    }\n    const bbox = el.getBBox();\n    const viewBox = getSVGViewBox(el.ownerSVGElement!);\n    const left = bbox.x - viewBox.x;\n    const top = bbox.y - viewBox.y;\n\n    return [\n        left,\n        top,\n        origin[0] - left,\n        origin[1] - top,\n    ];\n}\nexport function calculatePosition(matrix: number[], pos: number[], n: number) {\n    return calculate(matrix, convertPositionMatrix(pos, n), n);\n}\nexport function calculatePoses(matrix: number[], width: number, height: number, n: number) {\n    return [[0, 0], [width, 0], [0, height], [width, height]].map(pos => calculatePosition(matrix, pos, n));\n}\nexport function getRect(poses: number[][]) {\n    const posesX = poses.map(pos => pos[0]);\n    const posesY = poses.map(pos => pos[1]);\n    const left = Math.min(...posesX);\n    const top = Math.min(...posesY);\n    const right = Math.max(...posesX);\n    const bottom = Math.max(...posesY);\n    const rectWidth = right - left;\n    const rectHeight = bottom - top;\n\n    return {\n        left, top,\n        right, bottom,\n        width: rectWidth,\n        height: rectHeight,\n    };\n}\nexport function calculateRect(matrix: number[], width: number, height: number, n: number) {\n    const poses = calculatePoses(matrix, width, height, n);\n\n    return getRect(poses);\n}\nexport function getSVGOffset(\n    offsetInfo: MatrixInfo,\n    targetInfo: MatrixInfo,\n    container: HTMLElement | SVGElement,\n    n: number,\n    beforeMatrix: number[],\n) {\n    const target = offsetInfo.target;\n    const origin = offsetInfo.origin!;\n    const targetMatrix = targetInfo.matrix!;\n    const {\n        offsetWidth: width,\n        offsetHeight: height,\n    } = getSize(target);\n    const containerClientRect = container.getBoundingClientRect();\n    let margin = [0, 0];\n\n    if (container === document.body) {\n        margin = getBodyOffset(target, true);\n    }\n\n    const rect = target.getBoundingClientRect();\n    const rectLeft\n        = rect.left - containerClientRect.left + container.scrollLeft\n        - (container.clientLeft || 0) + margin[0];\n    const rectTop\n        = rect.top - containerClientRect.top + container.scrollTop\n        - (container.clientTop || 0) + margin[1];\n    const rectWidth = rect.width;\n    const rectHeight = rect.height;\n\n    const mat = multiplies(\n        n,\n        beforeMatrix,\n        targetMatrix,\n    );\n    const {\n        left: prevLeft,\n        top: prevTop,\n        width: prevWidth,\n        height: prevHeight,\n    } = calculateRect(mat, width, height, n);\n    const posOrigin = calculatePosition(mat, origin, n);\n    const prevOrigin = minus(posOrigin, [prevLeft, prevTop]);\n    const rectOrigin = [\n        rectLeft + prevOrigin[0] * rectWidth / prevWidth,\n        rectTop + prevOrigin[1] * rectHeight / prevHeight,\n    ];\n    const offset = [0, 0];\n    let count = 0;\n\n    while (++count < 10) {\n        const inverseBeforeMatrix = invert(beforeMatrix, n);\n        [offset[0], offset[1]] = minus(\n            calculatePosition(inverseBeforeMatrix, rectOrigin, n),\n            calculatePosition(inverseBeforeMatrix, posOrigin, n),\n        );\n        const mat2 = multiplies(\n            n,\n            beforeMatrix,\n            createOriginMatrix(offset, n),\n            targetMatrix,\n        );\n        const {\n            left: nextLeft,\n            top: nextTop,\n        } = calculateRect(mat2, width, height, n);\n        const distLeft = nextLeft - rectLeft;\n        const distTop = nextTop - rectTop;\n\n        if (Math.abs(distLeft) < 2 && Math.abs(distTop) < 2) {\n            break;\n        }\n        rectOrigin[0] -= distLeft;\n        rectOrigin[1] -= distTop;\n    }\n    return offset.map(p => Math.round(p));\n}\n\nexport function calculateMoveableClientPositions(\n    rootMatrix: number[],\n    poses: number[][],\n    rootClientRect: MoveableClientRect,\n) {\n    const is3d = rootMatrix.length === 16;\n    const n = is3d ? 4 : 3;\n    const rootPoses = poses.map(pos => calculatePosition(rootMatrix, pos, n));\n    const { left, top } = rootClientRect;\n\n    return rootPoses.map(pos => {\n        return [pos[0] + left, pos[1] + top];\n    });\n\n}\nexport function calculateMoveablePosition(\n    matrix: number[],\n    origin: number[],\n    width: number,\n    height: number,\n): MoveablePosition {\n    const is3d = matrix.length === 16;\n    const n = is3d ? 4 : 3;\n    const poses = calculatePoses(matrix, width, height, n);\n    let [\n        [x1, y1],\n        [x2, y2],\n        [x3, y3],\n        [x4, y4],\n    ] = poses;\n    let [originX, originY] = calculatePosition(matrix, origin, n);\n\n    const left = Math.min(x1, x2, x3, x4);\n    const top = Math.min(y1, y2, y3, y4);\n    const right = Math.max(x1, x2, x3, x4);\n    const bottom = Math.max(y1, y2, y3, y4);\n\n    x1 = (x1 - left) || 0;\n    x2 = (x2 - left) || 0;\n    x3 = (x3 - left) || 0;\n    x4 = (x4 - left) || 0;\n\n    y1 = (y1 - top) || 0;\n    y2 = (y2 - top) || 0;\n    y3 = (y3 - top) || 0;\n    y4 = (y4 - top) || 0;\n\n    originX = (originX - left) || 0;\n    originY = (originY - top) || 0;\n\n    const direction = getShapeDirection(poses);\n\n    return {\n        left,\n        top,\n        right,\n        bottom,\n        origin: [originX, originY],\n        pos1: [x1, y1],\n        pos2: [x2, y2],\n        pos3: [x3, y3],\n        pos4: [x4, y4],\n        direction,\n    };\n}\nexport function getDistSize(vec: number[]) {\n    return Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1]);\n}\nexport function getDiagonalSize(pos1: number[], pos2: number[]) {\n    return getDistSize([\n        pos2[0] - pos1[0],\n        pos2[1] - pos1[1],\n    ]);\n}\nexport function getLineStyle(pos1: number[], pos2: number[], zoom = 1, rad: number = getRad(pos1, pos2)) {\n    const width = getDiagonalSize(pos1, pos2);\n\n    return {\n        transform: `translateY(-50%) translate(${pos1[0]}px, ${pos1[1]}px) rotate(${rad}rad) scaleY(${zoom})`,\n        width: `${width}px`,\n    };\n}\nexport function getControlTransform(rotation: number, zoom: number, ...poses: number[][]) {\n    const length = poses.length;\n\n    const x = poses.reduce((prev, pos) => prev + pos[0], 0) / length;\n    const y = poses.reduce((prev, pos) => prev + pos[1], 0) / length;\n    return {\n        transform: `translateZ(0px) translate(${x}px, ${y}px) rotate(${rotation}rad) scale(${zoom})`,\n    };\n}\nexport function getCSSSize(target: SVGElement | HTMLElement) {\n    const style = getComputedStyle(target);\n\n    return [\n        parseFloat(style.width!),\n        parseFloat(style.height!),\n    ];\n}\n\nexport function getProps<Props>(props: Props, ableName: keyof Props): Props {\n    const self = props[ableName];\n\n    if (isObject(self)) {\n        return {\n            ...props,\n            ...self,\n        };\n    }\n    return props;\n}\n\nexport function getSize(\n    target?: SVGElement | HTMLElement | null,\n    style: CSSStyleDeclaration | null = target ? getComputedStyle(target) : null,\n): ElementSizes {\n    const hasOffset = target && !isUndefined((target as any).offsetWidth);\n\n    let offsetWidth = 0;\n    let offsetHeight = 0;\n    let clientWidth = 0;\n    let clientHeight = 0;\n    let cssWidth = 0;\n    let cssHeight = 0;\n    let contentWidth = 0;\n    let contentHeight = 0;\n\n    let minWidth = 0;\n    let minHeight = 0;\n    let minOffsetWidth = 0;\n    let minOffsetHeight = 0;\n\n    let maxWidth = Infinity;\n    let maxHeight = Infinity;\n    let maxOffsetWidth = Infinity;\n    let maxOffsetHeight = Infinity;\n    let svg = false;\n\n    if (target) {\n        if (!hasOffset && target!.tagName.toLowerCase() !== \"svg\") {\n            const bbox = (target as SVGGraphicsElement).getBBox();\n\n            svg = true;\n            offsetWidth = bbox.width;\n            offsetHeight = bbox.height;\n            cssWidth = offsetWidth;\n            cssHeight = offsetHeight;\n            contentWidth = offsetWidth;\n            contentHeight = offsetHeight;\n            clientWidth = offsetWidth;\n            clientHeight = offsetHeight;\n        } else {\n            const targetStyle = target.style;\n            const boxSizing = style!.boxSizing === \"border-box\";\n            const borderLeft = parseFloat(style!.borderLeftWidth!) || 0;\n            const borderRight = parseFloat(style!.borderRightWidth!) || 0;\n            const borderTop = parseFloat(style!.borderTopWidth!) || 0;\n            const borderBottom = parseFloat(style!.borderBottomWidth!) || 0;\n            const paddingLeft = parseFloat(style!.paddingLeft!) || 0;\n            const paddingRight = parseFloat(style!.paddingRight!) || 0;\n            const paddingTop = parseFloat(style!.paddingTop!) || 0;\n            const paddingBottom = parseFloat(style!.paddingBottom!) || 0;\n\n            const horizontalPadding = paddingLeft + paddingRight;\n            const verticalPadding = paddingTop + paddingBottom;\n            const horizontalBorder = borderLeft + borderRight;\n            const verticalBorder = borderTop + borderBottom;\n            const horizontalOffset = horizontalPadding + horizontalBorder;\n            const verticalOffset = verticalPadding + verticalBorder;\n\n            minWidth = Math.max(horizontalPadding, convertUnitSize(style!.minWidth, 0) || 0);\n            minHeight = Math.max(verticalPadding, convertUnitSize(style!.minHeight, 0) || 0);\n            maxWidth = convertUnitSize(style!.maxWidth, 0);\n            maxHeight = convertUnitSize(style!.maxHeight, 0);\n\n            if (isNaN(maxWidth)) {\n                maxWidth = Infinity;\n                maxHeight = Infinity;\n            }\n            const inlineCSSWidth = convertUnitSize(targetStyle.width, 0) || 0;\n            const inlineCSSHeight = convertUnitSize(targetStyle.height, 0) || 0;\n            const computedWidth = parseFloat(style!.width) || 0;\n            const computedHeight = parseFloat(style!.height) || 0;\n\n            cssWidth = parseFloat(style!.width);\n            cssHeight = parseFloat(style!.height);\n\n            contentWidth = Math.abs(computedWidth - inlineCSSWidth) < 1\n                ? between(minWidth, inlineCSSWidth || cssWidth, maxWidth)\n                : computedWidth;\n            contentHeight = Math.abs(computedHeight - inlineCSSHeight) < 1\n                ? between(minHeight, inlineCSSHeight || cssHeight, maxHeight)\n                : computedHeight;\n\n            offsetWidth = contentWidth;\n            offsetHeight = contentHeight;\n            clientWidth = contentWidth;\n            clientHeight = contentHeight;\n\n            if (boxSizing) {\n                maxOffsetWidth = maxWidth;\n                maxOffsetHeight = maxHeight;\n                minOffsetWidth = minWidth;\n                minOffsetHeight = minHeight;\n                contentWidth = offsetWidth - horizontalOffset;\n                contentHeight = offsetHeight - verticalOffset;\n            } else {\n                maxOffsetWidth = maxWidth + horizontalOffset;\n                maxOffsetHeight = maxHeight + verticalOffset;\n                minOffsetWidth = minWidth + horizontalOffset;\n                minOffsetHeight = minHeight + verticalOffset;\n                offsetWidth = contentWidth + horizontalOffset;\n                offsetHeight = contentHeight + verticalOffset;\n            }\n            clientWidth = contentWidth + horizontalPadding;\n            clientHeight = contentHeight + verticalPadding;\n        }\n    }\n\n    return {\n        svg,\n        offsetWidth,\n        offsetHeight,\n        clientWidth,\n        clientHeight,\n        contentWidth,\n        contentHeight,\n        cssWidth,\n        cssHeight,\n        minWidth,\n        minHeight,\n        maxWidth,\n        maxHeight,\n        minOffsetWidth,\n        minOffsetHeight,\n        maxOffsetWidth,\n        maxOffsetHeight,\n    };\n}\nexport function getRotationRad(\n    poses: number[][],\n    direction: number,\n) {\n    return getRad(direction > 0 ? poses[0] : poses[1], direction > 0 ? poses[1] : poses[0]);\n}\n\nexport function resetClientRect(): MoveableClientRect {\n    return {\n        left: 0, top: 0,\n        width: 0, height: 0,\n        right: 0,\n        bottom: 0,\n        clientLeft: 0, clientTop: 0,\n        clientWidth: 0, clientHeight: 0,\n        scrollWidth: 0, scrollHeight: 0,\n    };\n}\nexport function getClientRect(el: HTMLElement | SVGElement, isExtends?: boolean) {\n    let left = 0;\n    let top = 0;\n    let width = 0;\n    let height = 0;\n\n    if (el) {\n        if (el === document.body || el === document.documentElement) {\n            width = window.innerWidth;\n            height = window.innerHeight;\n            const scrollPos = getBodyScrollPos();\n\n            [left, top] = [-scrollPos[0], -scrollPos[1]];\n        } else {\n            const clientRect = el.getBoundingClientRect();\n\n            left = clientRect.left;\n            top = clientRect.top;\n            width = clientRect.width;\n            height = clientRect.height;\n        }\n    }\n\n    const rect: MoveableClientRect = {\n        left,\n        top,\n        width,\n        height,\n        right: left + width,\n        bottom: top + height,\n    };\n\n    if (el && isExtends) {\n        rect.clientLeft = el.clientLeft;\n        rect.clientTop = el.clientTop;\n        rect.clientWidth = el.clientWidth;\n        rect.clientHeight = el.clientHeight;\n        rect.scrollWidth = el.scrollWidth;\n        rect.scrollHeight = el.scrollHeight;\n        rect.overflow = getComputedStyle(el).overflow !== \"visible\";\n    }\n    return rect;\n}\nexport function getDirection(target: SVGElement | HTMLElement) {\n    if (!target) {\n        return;\n    }\n    const direciton = target.getAttribute(\"data-direction\")!;\n\n    if (!direciton) {\n        return;\n    }\n    const dir = [0, 0];\n\n    (direciton.indexOf(\"w\") > -1) && (dir[0] = -1);\n    (direciton.indexOf(\"e\") > -1) && (dir[0] = 1);\n    (direciton.indexOf(\"n\") > -1) && (dir[1] = -1);\n    (direciton.indexOf(\"s\") > -1) && (dir[1] = 1);\n\n    return dir;\n}\nexport function getAbsolutePoses(poses: number[][], dist: number[]) {\n    return [\n        plus(dist, poses[0]),\n        plus(dist, poses[1]),\n        plus(dist, poses[2]),\n        plus(dist, poses[3]),\n    ];\n}\nexport function getAbsolutePosesByState({\n    left,\n    top,\n    pos1,\n    pos2,\n    pos3,\n    pos4,\n}: {\n    left: number,\n    top: number,\n    pos1: number[],\n    pos2: number[],\n    pos3: number[],\n    pos4: number[],\n}) {\n    return getAbsolutePoses([pos1, pos2, pos3, pos4], [left, top]);\n}\n\nexport function roundSign(num: number) {\n    return Math.round(num % 1 === -0.5 ? num - 1 : num);\n}\n\nexport function unset(self: any, name: string) {\n    self[name]?.unset();\n    self[name] = null;\n}\n\nexport function fillCSSObject(style: Record<string, any>, resolvedEvent?: any) {\n    if (resolvedEvent) {\n        const originalDatas = getBeforeRenderableDatas(resolvedEvent);\n\n        originalDatas.nextStyle = {\n            ...originalDatas.nextStyle,\n            ...style,\n        };\n    }\n    return {\n        style,\n        cssText: getKeys(style).map(name => `${name}: ${style[name]};`).join(\"\"),\n    };\n}\n\nexport function fillAfterTransform(\n    prevEvent: { style: Record<string, string>, transform: string },\n    nextEvent: { style: Record<string, string>, transform: string, afterTransform?: string },\n    resolvedEvent?: any\n): TransformObject {\n    const afterTransform = nextEvent.afterTransform || nextEvent.transform;\n\n    return {\n        ...fillCSSObject({\n            ...prevEvent.style,\n            ...nextEvent.style,\n            transform: afterTransform,\n        }, resolvedEvent),\n        afterTransform,\n        transform: prevEvent.transform,\n    };\n}\n\nexport function fillParams<T extends IObject<any>>(\n    moveable: any,\n    e: any,\n    params: ExcludeParams<T>,\n    isBeforeEvent?: boolean,\n): T {\n    const datas = e.datas;\n\n    if (!datas.datas) {\n        datas.datas = {};\n    }\n    const nextParams = {\n        ...params,\n        target: moveable.state.target,\n        clientX: e.clientX,\n        clientY: e.clientY,\n        inputEvent: e.inputEvent,\n        currentTarget: moveable,\n        moveable,\n        datas: datas.datas,\n    } as any;\n\n    if (!datas.isStartEvent) {\n        datas.isStartEvent = true;\n    } else if (!isBeforeEvent) {\n        datas.lastEvent = nextParams;\n    }\n    return nextParams;\n}\nexport function fillEndParams<T extends IObject<any>>(\n    moveable: any,\n    e: any,\n    params: ExcludeEndParams<T> & { isDrag?: boolean },\n): T {\n    const datas = e.datas;\n    const isDrag = \"isDrag\" in params ? params.isDrag : e.isDrag;\n\n    if (!datas.datas) {\n        datas.datas = {};\n    }\n\n    return {\n        isDrag,\n        ...params,\n        moveable,\n        target: moveable.state.target,\n        clientX: e.clientX,\n        clientY: e.clientY,\n        inputEvent: e.inputEvent,\n        currentTarget: moveable,\n        lastEvent: datas.lastEvent,\n        isDouble: e.isDouble,\n        datas: datas.datas,\n    } as any;\n}\nexport function catchEvent<EventName extends keyof Props, Props extends IObject<any> = MoveableProps>(\n    moveable: any,\n    name: EventName,\n    callback: (e: Props[EventName] extends ((e: infer P) => any) | undefined ? P : IObject<any>) => void,\n): any {\n    moveable._emitter.on(name, callback);\n}\n\nexport function triggerEvent<EventName extends keyof Props, Props extends IObject<any> = MoveableProps>(\n    moveable: any,\n    name: EventName,\n    params: Props[EventName] extends ((e: infer P) => any) | undefined ? P : IObject<any>,\n    isManager?: boolean,\n): any {\n    return moveable.triggerEvent(name, params, isManager);\n}\n\nexport function getComputedStyle(el: Element, pseudoElt?: string | null) {\n    return window.getComputedStyle(el, pseudoElt);\n}\n\nexport function filterAbles(\n    ables: Able[], methods: Array<keyof Able>,\n    triggerAblesSimultaneously?: boolean,\n) {\n    const enabledAbles: IObject<boolean> = {};\n    const ableGroups: IObject<boolean> = {};\n\n    return ables.filter(able => {\n        const name = able.name;\n\n        if (enabledAbles[name] || !methods.some(method => able[method])) {\n            return false;\n        }\n        if (!triggerAblesSimultaneously && able.ableGroup) {\n            if (ableGroups[able.ableGroup]) {\n                return false;\n            }\n            ableGroups[able.ableGroup] = true;\n        }\n        enabledAbles[name] = true;\n        return true;\n    });\n}\n\nexport function equals(a1: any, a2: any) {\n    return a1 === a2 || (a1 == null && a2 == null);\n}\n\nexport function selectValue<T = any>(...values: any[]): T {\n    const length = values.length - 1;\n    for (let i = 0; i < length; ++i) {\n        const value = values[i];\n\n        if (!isUndefined(value)) {\n            return value;\n        }\n    }\n\n    return values[length];\n}\n\nexport function groupBy<T>(arr: T[], func: (el: T, index: number, arr: T[]) => any) {\n    const groups: T[][] = [];\n    const groupKeys: any[] = [];\n\n    arr.forEach((el, index) => {\n        const groupKey = func(el, index, arr);\n        const keyIndex = groupKeys.indexOf(groupKey);\n        const group = groups[keyIndex] || [];\n\n        if (keyIndex === -1) {\n            groupKeys.push(groupKey);\n            groups.push(group);\n        }\n        group.push(el);\n    });\n    return groups;\n}\nexport function groupByMap<T>(arr: T[], func: (el: T, index: number, arr: T[]) => string | number) {\n    const groups: T[][] = [];\n    const groupKeys: IObject<T[]> = {};\n\n    arr.forEach((el, index) => {\n        const groupKey = func(el, index, arr);\n        let group = groupKeys[groupKey];\n\n        if (!group) {\n            group = [];\n            groupKeys[groupKey] = group;\n            groups.push(group);\n        }\n        group.push(el);\n    });\n    return groups;\n}\nexport function flat<T>(arr: T[][]): T[] {\n    return arr.reduce((prev, cur) => {\n        return prev.concat(cur);\n    }, []);\n}\n\nexport function equalSign(a: number, b: number) {\n    return (a >= 0 && b >= 0) || (a < 0 && b < 0);\n}\n\nexport function maxOffset(...args: number[]) {\n    args.sort((a, b) => Math.abs(b) - Math.abs(a));\n\n    return args[0];\n}\nexport function minOffset(...args: number[]) {\n    args.sort((a, b) => Math.abs(a) - Math.abs(b));\n\n    return args[0];\n}\n\nexport function calculateInversePosition(matrix: number[], pos: number[], n: number) {\n    return calculate(\n        invert(matrix, n),\n        convertPositionMatrix(pos, n),\n        n,\n    );\n}\nexport function convertDragDist(state: MoveableManagerState, e: any) {\n    const {\n        is3d,\n        rootMatrix,\n    } = state;\n    const n = is3d ? 4 : 3;\n    [\n        e.distX, e.distY,\n    ] = calculateInversePosition(rootMatrix, [e.distX, e.distY], n);\n\n    return e;\n}\n\nexport function calculatePadding(\n    matrix: number[], pos: number[],\n    transformOrigin: number[], origin: number[], n: number,\n) {\n    return minus(calculatePosition(matrix, plus(transformOrigin, pos), n), origin);\n}\n\nexport function convertCSSSize(value: number, size: number, isRelative?: boolean) {\n    return isRelative ? `${value / size * 100}%` : `${value}px`;\n}\n\nexport function getTinyDist(v: number) {\n    return Math.abs(v) <= TINY_NUM ? 0 : v;\n}\n\nexport function getDirectionCondition(ableName: string, checkAbles: string[] = [ableName]) {\n    return (moveable: any, e: any) => {\n        if (e.isRequest) {\n            if (checkAbles.some(name => e.requestAble === name)) {\n                return e.parentDirection!;\n            } else {\n                return false;\n            }\n        }\n        const target = e.inputEvent.target;\n\n        return hasClass(target, prefix(\"direction\")) && (!ableName || hasClass(target, prefix(ableName)));\n    };\n}\n\nexport function invertObject<T extends IObject<any>>(obj: T): InvertObject<T> {\n    const nextObj: IObject<any> = {};\n\n    for (const name in obj) {\n        nextObj[obj[name]] = name;\n    }\n    return nextObj as any;\n}\n\nexport function convertTransformInfo(transforms: string[], index: number) {\n    const beforeFunctionTexts = transforms.slice(0, index < 0 ? undefined : index);\n    const beforeFunctionTexts2 = transforms.slice(0, index < 0 ? undefined : index + 1);\n    const targetFunctionText = transforms[index] || \"\";\n    const afterFunctionTexts = index < 0 ? [] : transforms.slice(index);\n    const afterFunctionTexts2 = index < 0 ? [] : transforms.slice(index + 1);\n\n    const beforeFunctions = parse(beforeFunctionTexts);\n    const beforeFunctions2 = parse(beforeFunctionTexts2);\n    const targetFunctions = parse([targetFunctionText]);\n    const afterFunctions = parse(afterFunctionTexts);\n    const afterFunctions2 = parse(afterFunctionTexts2);\n\n\n    const beforeFunctionMatrix = toMat(beforeFunctions);\n    const beforeFunctionMatrix2 = toMat(beforeFunctions2);\n    const afterFunctionMatrix = toMat(afterFunctions);\n    const afterFunctionMatrix2 = toMat(afterFunctions2);\n    const allFunctionMatrix = multiply(\n        beforeFunctionMatrix,\n        afterFunctionMatrix,\n        4,\n    );\n    return {\n        transforms,\n        beforeFunctionMatrix,\n        beforeFunctionMatrix2,\n        targetFunctionMatrix: toMat(targetFunctions),\n        afterFunctionMatrix,\n        afterFunctionMatrix2,\n        allFunctionMatrix,\n        beforeFunctions,\n        beforeFunctions2,\n        targetFunction: targetFunctions[0],\n        afterFunctions,\n        afterFunctions2,\n        beforeFunctionTexts,\n        beforeFunctionTexts2,\n        targetFunctionText,\n        afterFunctionTexts,\n        afterFunctionTexts2,\n    };\n}\n\nexport function isArrayFormat<T = any>(arr: any): arr is ArrayFormat<T> {\n    if (!arr || !isObject(arr)) {\n        return false;\n    }\n    if (arr instanceof Element) {\n        return false;\n    }\n    return isArray(arr) || \"length\" in arr;\n}\n\nexport function getRefTarget<T extends Element = HTMLElement | SVGElement>(\n    target: MoveableRefType<T>, isSelector: true): T | null;\nexport function getRefTarget<T extends Element = HTMLElement | SVGElement>(\n    target: MoveableRefType<T>, isSelector?: boolean): T | string | null;\nexport function getRefTarget<T extends Element = HTMLElement | SVGElement>(\n    target: MoveableRefType<T>,\n    isSelector?: boolean,\n): any {\n    if (!target) {\n        return null;\n    }\n    if (target instanceof Element) {\n        return target;\n    }\n    if (isString(target)) {\n        if (isSelector) {\n            return document.querySelector(target);\n        }\n        return target;\n    }\n    if (isFunction(target)) {\n        return target();\n    }\n    if (\"current\" in target) {\n        return target.current;\n    }\n    return target;\n}\n\nexport function getRefTargets(\n    targets: MoveableRefType | ArrayFormat<MoveableRefType>,\n    isSelector: true): Array<HTMLElement | SVGElement | null>;\nexport function getRefTargets(\n    targets: MoveableRefType | ArrayFormat<MoveableRefType>,\n    isSelector?: boolean): Array<HTMLElement | SVGElement | string | null>;\nexport function getRefTargets(targets: MoveableRefType | ArrayFormat<MoveableRefType>, isSelector?: boolean) {\n    if (!targets) {\n        return [];\n    }\n    const userTargets = isArrayFormat(targets) ? [].slice.call(targets) : [targets];\n\n    return userTargets.reduce((prev, target) => {\n        if (isString(target) && isSelector) {\n            return [...prev, ...[].slice.call(document.querySelectorAll<HTMLElement>(target))];\n        }\n        prev.push(getRefTarget(target, isSelector));\n        return prev;\n    }, [] as Array<SVGElement | HTMLElement | string | null | undefined>);\n}\n\nexport function getElementTargets(\n    targets: Array<SVGElement | HTMLElement | string | null | undefined>,\n    selectorMap: IObject<Array<HTMLElement | SVGElement>>,\n) {\n    const elementTargets: Array<SVGElement | HTMLElement> = [];\n    targets.forEach(target => {\n        if (!target) {\n            return;\n        }\n        if (isString(target)) {\n            if (selectorMap[target]) {\n                elementTargets.push(...selectorMap[target]);\n            }\n            return;\n        }\n        elementTargets.push(target);\n    });\n\n    return elementTargets;\n}\n\nexport function minmax(...values: number[]) {\n    return [Math.min(...values), Math.max(...values)];\n}\n\n\nexport function getAbsoluteRotation(pos1: number[], pos2: number[], direction: number) {\n    let deg = getRad(pos1, pos2) / Math.PI * 180;\n\n    deg = direction >= 0 ? deg : 180 - deg;\n    deg = deg >= 0 ? deg : 360 + deg;\n\n    return deg;\n}\n\n\nexport function getDragDistByState(state: MoveableManagerState, dist: number[]) {\n    const {\n        rootMatrix,\n        is3d,\n    } = state;\n    const n = is3d ? 4 : 3;\n\n    let inverseMatrix = invert(rootMatrix, n);\n\n    if (!is3d) {\n        inverseMatrix = convertDimension(inverseMatrix, 3, 4);\n    }\n    inverseMatrix[12] = 0;\n    inverseMatrix[13] = 0;\n    inverseMatrix[14] = 0;\n\n    return calculateMatrixDist(inverseMatrix, dist);\n}\n\nexport function getSizeDistByDist(\n    startSize: number[],\n    dist: number[],\n    ratio: number,\n    direction: number[],\n    keepRatio?: boolean,\n) {\n    const [startOffsetWidth, startOffsetHeight] = startSize;\n    let distWidth = 0;\n    let distHeight = 0;\n\n    if (keepRatio && startOffsetWidth && startOffsetHeight) {\n        const rad = getRad([0, 0], dist);\n        const standardRad = getRad([0, 0], direction);\n        const size = getDistSize(dist);\n        const signSize = Math.cos(rad - standardRad) * size;\n\n        if (!direction[0]) {\n            // top, bottom\n            distHeight = signSize;\n            distWidth = distHeight * ratio;\n        } else if (!direction[1]) {\n            // left, right\n            distWidth = signSize;\n            distHeight = distWidth / ratio;\n        } else {\n            // two-way\n            const startWidthSize = direction[0] * 2 * startOffsetWidth;\n            const startHeightSize = direction[1] * 2 * startOffsetHeight;\n            const distSize = getDistSize([startWidthSize + dist[0], startHeightSize + dist[1]])\n                - getDistSize([startWidthSize, startHeightSize]);\n            const ratioRad = getRad([0, 0], [ratio, 1]);\n\n            distWidth = Math.cos(ratioRad) * distSize;\n            distHeight = Math.sin(ratioRad) * distSize;\n        }\n    } else {\n        distWidth = direction[0] * dist[0];\n        distHeight = direction[1] * dist[1];\n    }\n\n    return [distWidth, distHeight];\n}\nexport function getOffsetSizeDist(\n    sizeDirection: number[],\n    keepRatio: boolean,\n    datas: any,\n    e: any,\n) {\n    const {\n        ratio,\n        startOffsetWidth,\n        startOffsetHeight,\n    } = datas;\n    let distWidth = 0;\n    let distHeight = 0;\n    const {\n        distX,\n        distY,\n        parentDistance,\n        parentDist,\n        parentScale,\n    } = e;\n    const startFixedDirection = datas.fixedDirection;\n    const directionsDists = [0, 1].map(index => {\n        return Math.abs(sizeDirection[index] - startFixedDirection[index]);\n    });\n    const directionRatios = [0, 1].map(index => {\n        let dist = directionsDists[index];\n\n        if (dist !== 0) {\n            dist = 2 / dist;\n        }\n        return dist;\n    });\n    if (parentDist) {\n        distWidth = parentDist[0];\n        distHeight = parentDist[1];\n\n        if (keepRatio) {\n            if (!distWidth) {\n                distWidth = distHeight * ratio;\n            } else if (!distHeight) {\n                distHeight = distWidth / ratio;\n            }\n        }\n    } else if (parentScale) {\n        distWidth = (parentScale[0] - 1) * startOffsetWidth;\n        distHeight = (parentScale[1] - 1) * startOffsetHeight;\n    } else if (parentDistance) {\n        const scaleX = startOffsetWidth * directionsDists[0];\n        const scaleY = startOffsetHeight * directionsDists[1];\n        const ratioDistance = getDistSize([scaleX, scaleY]);\n\n        distWidth = parentDistance / ratioDistance * scaleX * directionRatios[0];\n        distHeight = parentDistance / ratioDistance * scaleY * directionRatios[1];\n    } else {\n        let dist = getDragDist({ datas, distX, distY });\n\n        dist = directionRatios.map((ratio, i) => {\n            return dist[i] * ratio;\n        });\n\n        [distWidth, distHeight] = getSizeDistByDist(\n            [startOffsetWidth, startOffsetHeight],\n            dist,\n            ratio,\n            sizeDirection,\n            keepRatio,\n        );\n    }\n    return {\n        // direction,\n        // sizeDirection,\n        distWidth,\n        distHeight,\n    };\n}\n","import { makeAble } from \"./AbleManager\";\nimport { triggerEvent, fillParams, fillEndParams } from \"../utils\";\nimport {\n    PinchableProps, Able, SnappableState,\n    OnPinchStart, OnPinch, OnPinchEnd, MoveableManagerInterface, MoveableGroupInterface,\n} from \"../types\";\n\n/**\n * @namespace Moveable.Pinchable\n * @description Whether or not target can be pinched with draggable, resizable, scalable, rotatable (default: false)\n */\nexport default makeAble(\"pinchable\", {\n    events: {\n        onPinchStart: \"pinchStart\",\n        onPinch: \"pinch\",\n        onPinchEnd: \"pinchEnd\",\n        onPinchGroupStart: \"pinchGroupStart\",\n        onPinchGroup: \"pinchGroup\",\n        onPinchGroupEnd: \"pinchGroupEnd\",\n    } as const,\n    dragStart() {\n        return true;\n    },\n    pinchStart(\n        moveable: MoveableManagerInterface<PinchableProps, SnappableState>,\n        e: any,\n    ) {\n        const { datas, targets, angle, originalDatas } = e;\n        const { pinchable, ables } = moveable.props;\n\n        if (!pinchable) {\n            return false;\n        }\n        const eventName = `onPinch${targets ? \"Group\" : \"\"}Start` as \"onPinchStart\";\n        const controlEventName = `drag${targets ? \"Group\" : \"\"}ControlStart` as \"dragControlStart\";\n\n        const pinchAbles = (pinchable === true ? moveable.controlAbles : ables!.filter(able => {\n            return pinchable.indexOf(able.name as any) > -1;\n        })).filter(able => able.canPinch && able[controlEventName]);\n\n        const params = fillParams<OnPinchStart>(moveable, e, {}) as any;\n\n        if (targets) {\n            params.targets = targets;\n        }\n        const result = triggerEvent(moveable, eventName, params);\n\n        datas.isPinch = result !== false;\n        datas.ables = pinchAbles;\n\n        const isPinch = datas.isPinch;\n\n        if (!isPinch) {\n            return false;\n        }\n        pinchAbles.forEach(able => {\n            originalDatas[able.name] = originalDatas[able.name] || {};\n\n            if (!able[controlEventName]) {\n                return;\n            }\n            const ableEvent: any = {\n                ...e,\n                datas: originalDatas[able.name],\n                parentRotate: angle,\n                isPinch: true,\n            };\n            able[controlEventName]!(moveable, ableEvent);\n        });\n\n        moveable.state.snapRenderInfo = {\n            request: e.isRequest,\n            direction: [0, 0],\n        };\n        return isPinch;\n    },\n    pinch(\n        moveable: MoveableManagerInterface<PinchableProps>,\n        e: any,\n    ) {\n        const {\n            datas, scale: pinchScale, distance,\n            originalDatas,\n            inputEvent, targets,\n            angle,\n        } = e;\n        if (!datas.isPinch) {\n            return;\n        }\n        const parentDistance = distance * (1 - 1 / pinchScale);\n        const params = fillParams<OnPinch>(moveable, e, {}) as any;\n\n        if (targets) {\n            params.targets = targets;\n        }\n        const eventName = `onPinch${targets ? \"Group\" : \"\"}` as \"onPinch\";\n        triggerEvent(moveable, eventName, params);\n\n        const ables: Able[] = datas.ables;\n        const controlEventName = `drag${targets ? \"Group\" : \"\"}Control` as \"dragControl\";\n\n        ables.forEach(able => {\n            if (!able[controlEventName]) {\n                return;\n            }\n            able[controlEventName]!(moveable, {\n                ...e,\n                datas: originalDatas[able.name],\n                inputEvent,\n                parentDistance,\n                parentRotate: angle,\n                isPinch: true,\n            } as any);\n        });\n        return params;\n    },\n    pinchEnd(\n        moveable: MoveableManagerInterface<PinchableProps>,\n        e: any,\n    ) {\n        const { datas, isPinch, inputEvent, targets, originalDatas } = e;\n        if (!datas.isPinch) {\n            return;\n        }\n        const eventName = `onPinch${targets ? \"Group\" : \"\"}End` as \"onPinchEnd\";\n\n        const params = fillEndParams<OnPinchEnd>(moveable, e, { isDrag: isPinch }) as any;\n\n        if (targets) {\n            params.targets = targets;\n        }\n        triggerEvent(moveable, eventName, params);\n        const ables: Able[] = datas.ables;\n        const controlEventName = `drag${targets ? \"Group\" : \"\"}ControlEnd` as \"dragControlEnd\";\n\n        ables.forEach(able => {\n            if (!able[controlEventName]) {\n                return;\n            }\n            able[controlEventName]!(moveable, {\n                ...e,\n                isDrag: isPinch,\n                datas: originalDatas[able.name],\n                inputEvent,\n                isPinch: true,\n            } as any);\n        });\n        return isPinch;\n    },\n    pinchGroupStart(moveable: MoveableGroupInterface<any, any>, e: any) {\n        return this.pinchStart!(moveable, { ...e, targets: moveable.props.targets });\n    },\n    pinchGroup(moveable: MoveableGroupInterface, e: any) {\n        return this.pinch!(moveable, { ...e, targets: moveable.props.targets });\n    },\n    pinchGroupEnd(moveable: MoveableGroupInterface, e: any) {\n        return this.pinchEnd!(moveable, { ...e, targets: moveable.props.targets });\n    },\n});\n\n/**\n * Whether or not target can be pinched with draggable, resizable, scalable, rotatable (default: false)\n * @name Moveable.Pinchable#pinchable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.pinchable = true;\n */\n\n/**\n * When the pinch starts, the pinchStart event is called with part of scaleStart, rotateStart, resizeStart\n * @memberof Moveable.Pinchable\n * @event pinchStart\n * @param {Moveable.Pinchable.OnPinchStart} - Parameters for the pinchStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     rotatable: true,\n *     scalable: true,\n *     pinchable: true, // [\"rotatable\", \"scalable\"]\n * });\n * moveable.on(\"pinchStart\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"rotateStart\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"scaleStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When pinching, the pinch event is called with part of scale, rotate, resize\n * @memberof Moveable.Pinchable\n * @event pinch\n * @param {Moveable.Pinchable.OnPinch} - Parameters for the pinch event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     rotatable: true,\n *     scalable: true,\n *     pinchable: true, // [\"rotatable\", \"scalable\"]\n * });\n * moveable.on(\"pinch\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"rotate\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"scale\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When the pinch finishes, the pinchEnd event is called.\n * @memberof Moveable.Pinchable\n * @event pinchEnd\n * @param {Moveable.Pinchable.OnPinchEnd} - Parameters for the pinchEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     rotatable: true,\n *     scalable: true,\n *     pinchable: true, // [\"rotatable\", \"scalable\"]\n * });\n * moveable.on(\"pinchEnd\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"rotateEnd\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"scaleEnd\", ({ target }) => {\n *     console.log(target);\n * });\n */\n\n/**\n * When the group pinch starts, the `pinchGroupStart` event is called.\n * @memberof Moveable.Pinchable\n * @event pinchGroupStart\n * @param {Moveable.Pinchable.OnPinchGroupStart} - Parameters for the `pinchGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     pinchable: true\n * });\n * moveable.on(\"pinchGroupStart\", ({ targets }) => {\n *     console.log(\"onPinchGroupStart\", targets);\n * });\n */\n\n/**\n * When the group pinch, the `pinchGroup` event is called.\n * @memberof Moveable.Pinchable\n * @event pinchGroup\n * @param {Moveable.Pinchable.OnPinchGroup} - Parameters for the `pinchGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     pinchable: true\n * });\n * moveable.on(\"pinchGroup\", ({ targets, events }) => {\n *     console.log(\"onPinchGroup\", targets);\n * });\n */\n\n/**\n * When the group pinch finishes, the `pinchGroupEnd` event is called.\n * @memberof Moveable.Pinchable\n * @event pinchGroupEnd\n * @param {Moveable.Pinchable.OnPinchGroupEnd} - Parameters for the `pinchGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     pinchable: true\n * });\n * moveable.on(\"pinchGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onPinchGroupEnd\", targets, isDrag);\n * });\n */\n","import { Able, MoveableGroupInterface, MoveableManagerInterface, MoveableManagerState } from \"./types\";\nimport CustomGesto, { setCustomDrag } from \"./gesto/CustomGesto\";\n\nexport function fillChildEvents(\n    moveable: MoveableGroupInterface<any, any>,\n    name: string,\n    e: any,\n): any[] {\n    const datas = e.originalDatas;\n\n    datas.groupable = datas.groupable || {};\n\n    const groupableDatas = datas.groupable;\n\n    groupableDatas.childDatas = groupableDatas.childDatas || [];\n\n    const childDatas = groupableDatas.childDatas;\n\n    return moveable.moveables.map((_, i) => {\n        childDatas[i] = childDatas[i] || {};\n        childDatas[i][name] = childDatas[i][name] || {};\n\n        return {\n            ...e,\n            datas: childDatas[i][name],\n            originalDatas: childDatas[i],\n        };\n    });\n}\nexport function triggerChildGesto(\n    moveable: MoveableGroupInterface<any, any>,\n    able: Able,\n    type: string,\n    delta: number[],\n    e: any,\n    isConvert: boolean,\n    ableName: string,\n) {\n    const isStart = !!type.match(/Start$/g);\n    const isEnd = !!type.match(/End$/g);\n    const isPinch = e.isPinch;\n    const datas = e.datas;\n    const events = fillChildEvents(moveable, able.name, e);\n    const moveables = moveable.moveables;\n    const childs = events.map((ev, i) => {\n        const childMoveable = moveables[i];\n        const state = childMoveable.state as MoveableManagerState<any>;\n        const gestos = state.gestos;\n        let childEvent: any = ev;\n\n        if (isStart) {\n            childEvent = new CustomGesto(ableName).dragStart(delta, ev);\n        } else {\n\n\n            if (!gestos[ableName]) {\n                gestos[ableName] = datas.childGestos[i];\n            }\n            if (!gestos[ableName]) {\n                return;\n            }\n            childEvent = setCustomDrag(ev, state, delta, isPinch, isConvert, ableName);\n        }\n        const result = (able as any)[type]!(childMoveable,  { ...childEvent, parentFlag: true });\n\n        if (isEnd) {\n            gestos[ableName] = null;\n        }\n        return result;\n    });\n    if (isStart) {\n        datas.childGestos = moveables.map(child => child.state.gestos[ableName]);\n    }\n    return childs;\n}\nexport function triggerChildAbles<T extends Able>(\n    moveable: MoveableGroupInterface<any, any>,\n    able: T,\n    type: keyof T & string,\n    e: any,\n    eachEvent: (movebale: MoveableManagerInterface<any, any>, ev: any) => any = (_, ev) => ev,\n    callback?: (moveable: MoveableManagerInterface<any, any>, ev: any, result: any, index: number) => any,\n) {\n    const isEnd = !!type.match(/End$/g);\n    const events = fillChildEvents(moveable, able.name, e);\n    const moveables = moveable.moveables;\n    const childs = events.map((ev, i) => {\n        const childMoveable = moveables[i];\n        let childEvent = ev;\n\n        childEvent = eachEvent(childMoveable, ev);\n\n        const result = (able as any)[type]!(childMoveable,  { ...childEvent, parentFlag: true });\n\n        result && callback && callback(childMoveable, ev, result, i);\n\n        if (isEnd) {\n            childMoveable.state.gestos = {};\n        }\n        return result;\n    });\n\n    return childs;\n}\n","import { TINY_NUM } from \"@daybrush/utils\";\nimport { throttle } from \"@daybrush/utils\";\nimport {\n    MoveableClientRect, MoveableManagerInterface,\n    SnapDirectionPoses,\n    SnapDirections, SnappableProps,\n    SnappableState,\n} from \"../../types\";\nimport {\n    calculatePosition,\n} from \"../../utils\";\nexport const VERTICAL_NAMES = [\"left\", \"right\", \"center\"] as const;\nexport const HORIZONTAL_NAMES = [\"top\", \"bottom\", \"middle\"] as const;\nexport const VERTICAL_NAMES_MAP = {\n    start: \"left\",\n    end: \"right\",\n    center: \"center\",\n} as const;\nexport const HORIZONTAL_NAMES_MAP = {\n    start: \"top\",\n    end: \"bottom\",\n    center: \"middle\",\n} as const;\n\n\nexport function hasGuidelines(\n    moveable: MoveableManagerInterface<any, any>,\n    ableName: string\n): moveable is MoveableManagerInterface<SnappableProps, SnappableState> {\n    const {\n        props: {\n            snappable,\n            bounds,\n            innerBounds,\n            verticalGuidelines,\n            horizontalGuidelines,\n            snapGridWidth,\n            snapGridHeight,\n        },\n        state: { guidelines, enableSnap },\n    } = moveable;\n\n    if (\n        !snappable ||\n        !enableSnap ||\n        (ableName && snappable !== true && snappable.indexOf(ableName) < 0)\n    ) {\n        return false;\n    }\n    if (\n        snapGridWidth ||\n        snapGridHeight ||\n        bounds ||\n        innerBounds ||\n        (guidelines && guidelines.length) ||\n        (verticalGuidelines && verticalGuidelines.length) ||\n        (horizontalGuidelines && horizontalGuidelines.length)\n    ) {\n        return true;\n    }\n    return false;\n}\n\nexport function getSnapDirections(snapDirections: SnapDirections | boolean | undefined): SnapDirections {\n    if (snapDirections === false) {\n        return {};\n    } else if (snapDirections === true || !snapDirections) {\n        return { left: true, right: true, top: true, bottom: true };\n    }\n    return snapDirections;\n}\n\nexport function mapSnapDirectionPoses(\n    snapDirections: SnapDirections | boolean | undefined,\n    snapPoses: SnapDirectionPoses,\n) {\n    const nextSnapDirections = getSnapDirections(snapDirections);\n    const nextSnapPoses: SnapDirectionPoses = {};\n\n    for (const name in nextSnapDirections) {\n        if (name in snapPoses && (nextSnapDirections as any)[name]) {\n            (nextSnapPoses as any)[name] = (snapPoses as any)[name];\n        }\n    }\n    return nextSnapPoses;\n}\n\nexport function splitSnapDirectionPoses(\n    snapDirections: SnapDirections | boolean | undefined,\n    snapPoses: SnapDirectionPoses,\n) {\n    const nextSnapPoses = mapSnapDirectionPoses(snapDirections, snapPoses);\n    const horizontalNames = HORIZONTAL_NAMES.filter(name => name in nextSnapPoses);\n    const verticalNames = VERTICAL_NAMES.filter(name => name in nextSnapPoses);\n\n    return {\n        horizontal: horizontalNames.map(name => nextSnapPoses[name]!),\n        vertical: verticalNames.map(name => nextSnapPoses[name]!),\n    };\n}\n\nexport function calculateContainerPos(\n    rootMatrix: number[],\n    containerRect: MoveableClientRect,\n    n: number,\n) {\n    const clientPos = calculatePosition(\n        rootMatrix, [containerRect.clientLeft!, containerRect.clientTop!], n);\n\n    return [\n        containerRect.left + clientPos[0],\n        containerRect.top + clientPos[1],\n    ];\n}\n\nexport function solveLineConstants([point1, point2]: number[][]): [number, number, number] {\n    let dx = point2[0] - point1[0];\n    let dy = point2[1] - point1[1];\n\n    if (Math.abs(dx) < TINY_NUM) {\n        dx = 0;\n    }\n    if (Math.abs(dy) < TINY_NUM) {\n        dy = 0;\n    }\n\n    // b > 0\n    // ax + by + c = 0\n    let a = 0;\n    let b = 0;\n    let c = 0;\n\n    if (!dx) {\n        // -x + 1 = 0\n        a = -1;\n        c = point1[0];\n    } else if (!dy) {\n        // y - 1 = 0\n        b = 1;\n        c = -point1[1];\n    } else {\n        // y = -a(x - x1) + y1\n        // ax + y + a * x1 - y1 = 0\n        a = -dy / dx;\n        b = 1;\n        c = a * point1[0] - point1[1];\n    }\n\n    return [a, b, c].map(v => throttle(v, TINY_NUM)) as [number, number, number];\n}\n","import {\n    SnapInfo, SnappableProps, SnappableState,\n    SnapGuideline, ResizableProps, ScalableProps,\n    SnapOffsetInfo, MoveableManagerInterface, SnapDirectionPoses,\n} from \"../../types\";\nimport {\n    selectValue, getTinyDist,\n} from \"../../utils\";\nimport { getPosByDirection, getPosesByDirection } from \"../../gesto/GestoUtils\";\nimport { TINY_NUM } from \"../../consts\";\nimport { minus } from \"@scena/matrix\";\nimport { splitSnapDirectionPoses } from \"./utils\";\n\n\n\nexport function checkMoveableSnapPoses(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    posesX: number[],\n    posesY: number[],\n    customSnapThreshold?: number,\n) {\n    const props = moveable.props;\n    const snapThreshold = selectValue<number>(customSnapThreshold, props.snapThreshold, 5);\n\n    return checkSnapPoses(\n        moveable.state.guidelines,\n        posesX,\n        posesY,\n        snapThreshold,\n    );\n}\n\nexport function checkSnapPoses(\n    guidelines: SnapGuideline[],\n    posesX: number[],\n    posesY: number[],\n    snapThreshold: number,\n) {\n    return {\n        vertical: checkSnap(guidelines, \"vertical\", posesX, snapThreshold),\n        horizontal: checkSnap(guidelines, \"horizontal\", posesY, snapThreshold),\n    };\n}\nexport function checkSnapKeepRatio(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    startPos: number[],\n    endPos: number[],\n): { vertical: SnapOffsetInfo, horizontal: SnapOffsetInfo } {\n    const [endX, endY] = endPos;\n    const [startX, startY] = startPos;\n    let [dx, dy] = minus(endPos, startPos);\n    const isBottom = dy > 0;\n    const isRight = dx > 0;\n\n    dx = getTinyDist(dx);\n    dy = getTinyDist(dy);\n\n    const verticalInfo: SnapOffsetInfo = {\n        isSnap: false,\n        offset: 0,\n        pos: 0,\n    };\n    const horizontalInfo: SnapOffsetInfo = {\n        isSnap: false,\n        offset: 0,\n        pos: 0,\n    };\n\n    if (dx === 0 && dy === 0) {\n        return {\n            vertical: verticalInfo,\n            horizontal: horizontalInfo,\n        };\n    }\n    const {\n        vertical: verticalSnapInfo,\n        horizontal: horizontalSnapInfo,\n    } = checkMoveableSnapPoses(moveable, dx ? [endX] : [], dy ? [endY] : []);\n\n    verticalSnapInfo.posInfos.filter(({ pos }) => {\n        return isRight ? pos >= startX : pos <= startX;\n    });\n    horizontalSnapInfo.posInfos.filter(({ pos }) => {\n        return isBottom ? pos >= startY : pos <= startY;\n    });\n    verticalSnapInfo.isSnap = verticalSnapInfo.posInfos.length > 0;\n    horizontalSnapInfo.isSnap = horizontalSnapInfo.posInfos.length > 0;\n\n    const {\n        isSnap: isVerticalSnap,\n        guideline: verticalGuideline,\n    } = getNearestSnapGuidelineInfo(verticalSnapInfo);\n    const {\n        isSnap: isHorizontalSnap,\n        guideline: horizontalGuideline,\n    } = getNearestSnapGuidelineInfo(horizontalSnapInfo);\n    const horizontalPos = isHorizontalSnap ? horizontalGuideline!.pos[1] : 0;\n    const verticalPos = isVerticalSnap ? verticalGuideline!.pos[0] : 0;\n\n    if (dx === 0) {\n        if (isHorizontalSnap) {\n            horizontalInfo.isSnap = true;\n            horizontalInfo.pos = horizontalGuideline!.pos[1];\n            horizontalInfo.offset = endY - horizontalInfo.pos;\n        }\n    } else if (dy === 0) {\n        if (isVerticalSnap) {\n            verticalInfo.isSnap = true;\n            verticalInfo.pos = verticalPos;\n            verticalInfo.offset = endX - verticalPos;\n        }\n    } else {\n        // y - y1 = a * (x - x1)\n        const a = dy / dx;\n        const b = endPos[1] - a * endX;\n        let y = 0;\n        let x = 0;\n        let isSnap = false;\n\n        if (isVerticalSnap) {\n            x = verticalPos;\n            y = a * x + b;\n            isSnap = true;\n        } else if (isHorizontalSnap) {\n            y = horizontalPos;\n            x = (y - b) / a;\n            isSnap = true;\n        }\n        if (isSnap) {\n            verticalInfo.isSnap = true;\n            verticalInfo.pos = x;\n            verticalInfo.offset = endX - x;\n\n            horizontalInfo.isSnap = true;\n            horizontalInfo.pos = y;\n            horizontalInfo.offset = endY - y;\n        }\n    }\n    return {\n        vertical: verticalInfo,\n        horizontal: horizontalInfo,\n    };\n}\n\nexport function checkSnaps(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    rect: SnapDirectionPoses,\n    customSnapThreshold?: number,\n) {\n    const poses = splitSnapDirectionPoses(moveable.props.snapDirections, rect);\n\n    return checkMoveableSnapPoses(\n        moveable,\n        poses.vertical,\n        poses.horizontal,\n        customSnapThreshold,\n    );\n}\n\nexport function getNearestSnapGuidelineInfo(\n    snapInfo: SnapInfo,\n) {\n    const isSnap = snapInfo.isSnap;\n\n    if (!isSnap) {\n        return {\n            isSnap: false,\n            offset: 0,\n            dist: -1,\n            pos: 0,\n            guideline: null,\n        };\n    }\n    const posInfo = snapInfo.posInfos[0];\n    const guidelineInfo = posInfo!.guidelineInfos[0];\n    const offset = guidelineInfo!.offset;\n    const dist = guidelineInfo!.dist;\n    const guideline = guidelineInfo!.guideline;\n\n    return {\n        isSnap,\n        offset,\n        dist,\n        pos: posInfo!.pos,\n        guideline,\n    };\n}\n\nfunction checkSnap(\n    guidelines: SnapGuideline[],\n    targetType: \"horizontal\" | \"vertical\",\n    targetPoses: number[],\n    snapThreshold: number,\n): SnapInfo {\n    if (!guidelines || !guidelines.length) {\n        return {\n            isSnap: false,\n            index: -1,\n            posInfos: [],\n        };\n    }\n    const isVertical = targetType === \"vertical\";\n    const posType = isVertical ? 0 : 1;\n\n    const snapPosInfos = targetPoses.map((targetPos, index) => {\n        const guidelineInfos = guidelines.map(guideline => {\n            const { pos } = guideline;\n            const offset = targetPos - pos[posType];\n\n            return {\n                offset,\n                dist: Math.abs(offset),\n                guideline,\n            };\n        }).filter(({ guideline, dist }) => {\n            const { type } = guideline;\n            if (\n                type !== targetType\n                || dist > snapThreshold\n            ) {\n                return false;\n            }\n            return true;\n        }).sort(\n            (a, b) => a.dist - b.dist,\n        );\n\n\n        return {\n            pos: targetPos,\n            index,\n            guidelineInfos,\n        };\n    }).filter(snapPosInfo => {\n        return snapPosInfo.guidelineInfos.length > 0;\n    }).sort((a, b) => {\n        return a.guidelineInfos[0].dist - b.guidelineInfos[0].dist;\n    });\n\n    const isSnap = snapPosInfos.length > 0;\n    return {\n        isSnap,\n        index: isSnap ? snapPosInfos[0].index : -1,\n        posInfos: snapPosInfos,\n    };\n}\n\nexport function getSnapInfosByDirection(\n    moveable: MoveableManagerInterface<SnappableProps & (ResizableProps | ScalableProps), SnappableState>,\n    poses: number[][],\n    snapDirection: number[],\n) {\n    let nextPoses: number[][] = [];\n    if (snapDirection[0] && snapDirection[1]) {\n        nextPoses = [\n            snapDirection,\n            [-snapDirection[0], snapDirection[1]],\n            [snapDirection[0], -snapDirection[1]],\n        ].map(direction => getPosByDirection(poses, direction));\n    } else if (!snapDirection[0] && !snapDirection[1]) {\n        const alignPoses = [poses[0], poses[1], poses[3], poses[2], poses[0]];\n\n        for (let i = 0; i < 4; ++i) {\n            nextPoses.push(alignPoses[i]);\n            nextPoses.push([\n                (alignPoses[i][0] + alignPoses[i + 1][0]) / 2,\n                (alignPoses[i][1] + alignPoses[i + 1][1]) / 2,\n            ]);\n        }\n    } else {\n        if (moveable.props.keepRatio) {\n            nextPoses = [\n                [-1, -1],\n                [-1, 1],\n                [1, -1],\n                [1, 1],\n                snapDirection,\n            ].map(dir => getPosByDirection(poses, dir));\n        } else {\n            nextPoses = getPosesByDirection(poses, snapDirection);\n\n            if (nextPoses.length > 1) {\n                nextPoses.push([\n                    (nextPoses[0][0] + nextPoses[1][0]) / 2,\n                    (nextPoses[0][1] + nextPoses[1][1]) / 2,\n                ]);\n            }\n        }\n    }\n    return checkMoveableSnapPoses(moveable, nextPoses.map(pos => pos[0]), nextPoses.map(pos => pos[1]), 1);\n}\n\nexport function checkSnapBoundPriority(\n    a: { isBound: boolean, isSnap: boolean, offset: number },\n    b: { isBound: boolean, isSnap: boolean, offset: number },\n) {\n    const aDist = Math.abs(a.offset);\n    const bDist = Math.abs(b.offset);\n\n    if (a.isBound && b.isBound) {\n        return bDist - aDist;\n    } else if (a.isBound) {\n        return -1;\n    } else if (b.isBound) {\n        return 1;\n    } else if (a.isSnap && b.isSnap) {\n        return bDist - aDist;\n    } else if (a.isSnap) {\n        return -1;\n    } else if (b.isSnap) {\n        return 1;\n    } else if (aDist < TINY_NUM) {\n        return 1;\n    } else if (bDist < TINY_NUM) {\n        return -1;\n    }\n    return aDist - bDist;\n}\nexport function getNearOffsetInfo<T extends { offset: number[], isBound: boolean, isSnap: boolean, sign: number[] }>(\n    offsets: T[],\n    index: number,\n) {\n    return offsets.slice().sort((a, b) => {\n        const aSign = a.sign[index];\n        const bSign = b.sign[index];\n        const aOffset = a.offset[index];\n        const bOffset = b.offset[index];\n        // -1 The positions of a and b do not change.\n        // 1 The positions of a and b are reversed.\n        if (!aSign) {\n            return 1;\n        } else if (!bSign) {\n            return -1;\n        }\n        return checkSnapBoundPriority(\n            { isBound: a.isBound, isSnap: a.isSnap, offset: aOffset },\n            { isBound: b.isBound, isSnap: b.isSnap, offset: bOffset },\n        );\n    })[0];\n}\n\n\nexport function getCheckSnapDirections(\n    direction: number[],\n    fixedDirection: number[],\n    keepRatio: boolean\n) {\n    const directions: number[][][] = [];\n    // const fixedDirection = [-direction[0], -direction[1]];\n\n    if (keepRatio) {\n        if (Math.abs(fixedDirection[0]) !== 1 || Math.abs(fixedDirection[1]) !== 1) {\n            directions.push(\n                [fixedDirection, [-1, -1]],\n                [fixedDirection, [-1, 1]],\n                [fixedDirection, [1, -1]],\n                [fixedDirection, [1, 1]],\n            );\n        } else {\n            directions.push(\n                [fixedDirection, [direction[0], -direction[1]]],\n                [fixedDirection, [-direction[0], direction[1]]],\n            );\n        }\n        directions.push([fixedDirection, direction]);\n    } else {\n        if ((direction[0] && direction[1]) || (!direction[0] && !direction[1])) {\n            const endDirection = direction[0] ? direction : [1, 1];\n\n            [1, -1].forEach(signX => {\n                [1, -1].forEach(signY => {\n                    const nextDirection = [signX * endDirection[0], signY * endDirection[1]];\n\n                    if (\n                        fixedDirection[0] === nextDirection[0]\n                        && fixedDirection[1] === nextDirection[1]\n                    ) {\n                        return;\n                    }\n                    directions.push([fixedDirection, nextDirection]);\n                });\n            });\n        } else if (direction[0]) {\n            const signs = Math.abs(fixedDirection[0]) === 1 ? [1] : [1, -1];\n\n            signs.forEach(sign => {\n                directions.push(\n                    [\n                        [fixedDirection[0], -1],\n                        [sign * direction[0], -1],\n                    ],\n                    [\n                        [fixedDirection[0], 0],\n                        [sign * direction[0], 0],\n                    ],\n                    [\n                        [fixedDirection[0], 1],\n                        [sign * direction[0], 1],\n                    ]\n                );\n            });\n        } else if (direction[1]) {\n            const signs = Math.abs(fixedDirection[1]) === 1 ? [1] : [1, -1];\n\n            signs.forEach(sign => {\n                directions.push(\n                    [\n                        [-1, fixedDirection[1]],\n                        [-1, sign * direction[1]],\n                    ],\n                    [\n                        [0, fixedDirection[1]],\n                        [0, sign * direction[1]],\n                    ],\n                    [\n                        [1, fixedDirection[1]],\n                        [1, sign * direction[1]],\n                    ]\n                );\n            });\n        }\n    }\n    return directions;\n}\n","import { average, getRad, throttle } from \"@daybrush/utils\";\nimport { rotate } from \"@scena/matrix\";\nimport { maxOffset, getDistSize, getTinyDist, calculatePoses } from \"../../utils\";\n\nimport { SnappableProps, DraggableProps, RotatableProps, MoveableManagerInterface } from \"../../types\";\nimport { getDragDist, getPosByDirection, getInverseDragDist } from \"../../gesto/GestoUtils\";\nimport { getNearOffsetInfo } from \"./snap\";\nimport { TINY_NUM } from \"../../consts\";\nimport { solveLineConstants } from \"./utils\";\n\nfunction isStartLine(dot: number[], line: number[][]) {\n    // l    o     => true\n    // o    l    => false\n    const cx = average([line[0][0], line[1][0]]);\n    const cy = average([line[0][1], line[1][1]]);\n\n    return {\n        vertical: cx <= dot[0],\n        horizontal: cy <= dot[1],\n    };\n}\nfunction hitTestLine(\n    dot: number[],\n    [pos1, pos2]: number[][],\n) {\n    let dx = pos2[0] - pos1[0];\n    let dy = pos2[1] - pos1[1];\n\n    if (Math.abs(dx) < TINY_NUM) {\n        dx = 0;\n    }\n    if (Math.abs(dy) < TINY_NUM) {\n        dy = 0;\n    }\n    let test1: number;\n    let test2: number;\n    if (!dx) {\n        test1 = pos1[0];\n        test2 = dot[0];\n    } else if (!dy) {\n        test1 = pos1[1];\n        test2 = dot[1];\n    } else {\n        const a = dy / dx;\n\n        // y = a * (x - pos1) + pos1\n        test1 = a * (dot[0] - pos1[0]) + pos1[1];\n        test2 = dot[1];\n    }\n    return test1 - test2;\n}\nfunction isSameStartLine(dots: number[][], line: number[][], centerSign: boolean, error: number = TINY_NUM) {\n    return dots.every(dot => {\n        const value = hitTestLine(dot, line);\n        const sign = value <= 0;\n        return sign === centerSign || Math.abs(value) <= error;\n    });\n}\nfunction checkInnerBoundDot(\n    pos: number,\n    start: number,\n    end: number,\n    isStart: boolean,\n    threshold = 0,\n) {\n    if (\n        (isStart && start - threshold <= pos)\n        || (!isStart && pos <= end + threshold)\n    ) {\n        // false 402 565 602 => 37 ([0, 37])\n        // true 400 524.9712603540036 600 => 124 ([124, 0])\n        // true 400 410 600 => 10 ([10, 0])\n        return {\n            isBound: true,\n            offset: isStart ? start - pos : end - pos,\n        };\n    }\n    return {\n        isBound: false,\n        offset: 0,\n    };\n}\n\nfunction checkInnerBound(\n    moveable: MoveableManagerInterface<SnappableProps>,\n    { line, centerSign, verticalSign, horizontalSign, lineConstants }: InnerBoundLineInfo,\n) {\n    const bounds = moveable.props.innerBounds;\n\n    if (!bounds) {\n        return {\n            isAllBound: false,\n            isBound: false,\n            isVerticalBound: false,\n            isHorizontalBound: false,\n            offset: [0, 0],\n        };\n    }\n    const { left, top, width, height } = bounds;\n    const leftLine = [[left, top], [left, top + height]];\n    const topLine = [[left, top], [left + width, top]];\n    const rightLine = [[left + width, top], [left + width, top + height]];\n    const bottomLine = [[left, top + height], [left + width, top + height]];\n\n    if (isSameStartLine([\n        [left, top],\n        [left + width, top],\n        [left, top + height],\n        [left + width, top + height],\n    ], line, centerSign)) {\n        return {\n            isAllBound: false,\n            isBound: false,\n            isVerticalBound: false,\n            isHorizontalBound: false,\n            offset: [0, 0],\n        };\n    }\n    // test vertical\n\n    const topBoundInfo = checkLineBoundCollision(line, lineConstants, topLine, verticalSign);\n    const bottomBoundInfo = checkLineBoundCollision(line, lineConstants, bottomLine, verticalSign);\n\n    // test horizontal\n    const leftBoundInfo = checkLineBoundCollision(line, lineConstants, leftLine, horizontalSign);\n    const rightBoundInfo = checkLineBoundCollision(line, lineConstants, rightLine, horizontalSign);\n\n    const isAllVerticalBound = topBoundInfo.isBound && bottomBoundInfo.isBound;\n    const isVerticalBound = topBoundInfo.isBound || bottomBoundInfo.isBound;\n    const isAllHorizontalBound = leftBoundInfo.isBound && rightBoundInfo.isBound;\n    const isHorizontalBound = leftBoundInfo.isBound || rightBoundInfo.isBound;\n    const verticalOffset = maxOffset(topBoundInfo.offset, bottomBoundInfo.offset);\n    const horizontalOffset = maxOffset(leftBoundInfo.offset, rightBoundInfo.offset);\n    let offset = [0, 0];\n    let isBound = false;\n    let isAllBound = false;\n\n    if (Math.abs(horizontalOffset) < Math.abs(verticalOffset)) {\n        offset = [verticalOffset, 0];\n        isBound = isVerticalBound;\n        isAllBound = isAllVerticalBound;\n    } else {\n        offset = [0, horizontalOffset];\n        isBound = isHorizontalBound;\n        isAllBound = isAllHorizontalBound;\n    }\n    return {\n        isAllBound,\n        isVerticalBound,\n        isHorizontalBound,\n        isBound,\n        offset,\n    };\n}\n\nfunction checkLineBoundCollision(\n    line: number[][],\n    [a, b]: [number, number, number],\n    boundLine: number[][],\n    isStart: boolean,\n    threshold?: number,\n    isRender?: boolean,\n) {\n    const dot1 = line[0];\n    // const dot2 = line[1];\n    const boundDot1 = boundLine[0];\n    const boundDot2 = boundLine[1];\n\n    // const dy1 = getTinyDist(dot2[1] - dot1[1]);\n    // const dx1 = getTinyDist(dot2[0] - dot1[0]);\n    const dy2 = getTinyDist(boundDot2[1] - boundDot1[1]);\n    const dx2 = getTinyDist(boundDot2[0] - boundDot1[0]);\n\n    const hasDx = b;\n    const hasDy = a;\n    const slope = - a / b;\n    // lineConstants\n    // ax + by + c = 0\n    // dx2 or dy2 is zero\n    if (!dx2) {\n        // vertical\n        // by + c = 0\n        if (isRender && !hasDy) {\n            // 90deg\n            return {\n                isBound: false,\n                offset: 0,\n            };\n        } else if (hasDx) {\n            // ax + by + c = 0\n            // const y = dy1 ? dy1 / dx1 * (boundDot1[0] - dot1[0]) + dot1[1] : dot1[1];\n            const y = slope * (boundDot1[0] - dot1[0]) + dot1[1];\n\n            // boundDot1[1] <= y  <= boundDot2[1]\n            return checkInnerBoundDot(y, boundDot1[1], boundDot2[1], isStart, threshold);\n        } else {\n            // ax + c = 0\n            const offset = boundDot1[0] - dot1[0];\n\n            const isBound = Math.abs(offset) <= (threshold || 0);\n\n            return {\n                isBound,\n                offset: isBound ? offset : 0,\n            };\n        }\n    } else if (!dy2) {\n        // horizontal\n        if (isRender && !hasDx) {\n            // 90deg\n            return {\n                isBound: false,\n                offset: 0,\n            };\n        } else if (hasDy) {\n            // y = a * (x - x1) + y1\n            // x = (y - y1) / a + x1\n            // const a = dy1 / dx1;\n            // const x = dx1 ? (boundDot1[1] - dot1[1]) / a + dot1[0] : dot1[0];\n            const x = (boundDot1[1] - dot1[1]) / slope + dot1[0];\n\n            // boundDot1[0] <= x && x <= boundDot2[0]\n            return checkInnerBoundDot(x, boundDot1[0], boundDot2[0], isStart, threshold);\n        } else {\n            const offset = boundDot1[1] - dot1[1];\n\n            const isBound = Math.abs(offset) <= (threshold || 0);\n\n            return {\n                isBound,\n                offset: isBound ? offset : 0,\n            };\n        }\n    }\n    return {\n        isBound: false,\n        offset: 0,\n    };\n}\nexport function getInnerBoundInfo(\n    moveable: MoveableManagerInterface<SnappableProps>,\n    lineInfos: InnerBoundLineInfo[],\n    datas: any,\n) {\n    return lineInfos.map(info => {\n        const {\n            isBound,\n            offset,\n            isVerticalBound,\n            isHorizontalBound,\n        } = checkInnerBound(moveable, info);\n\n        const multiple = info.multiple;\n\n        const sizeOffset = getDragDist({\n            datas,\n            distX: offset[0],\n            distY: offset[1],\n        }).map((size, i) => size * (multiple[i] ? 2 / multiple[i] : 0));\n\n        return {\n            sign: multiple,\n            isBound,\n            isVerticalBound,\n            isHorizontalBound,\n            isSnap: false,\n            offset: sizeOffset,\n        };\n    });\n}\n\nexport function getInnerBoundDragInfo(\n    moveable: MoveableManagerInterface<SnappableProps & DraggableProps, any>,\n    poses: number[][],\n    datas: any,\n) {\n    const lines = getCheckInnerBoundLineInfos(moveable, poses, [0, 0], false).map(info => {\n        return {\n            ...info,\n            multiple: info.multiple.map(dir => Math.abs(dir) * 2),\n        };\n    });\n    const innerBoundInfo = getInnerBoundInfo(moveable, lines, datas);\n    const widthOffsetInfo = getNearOffsetInfo(innerBoundInfo, 0);\n    const heightOffsetInfo = getNearOffsetInfo(innerBoundInfo, 1);\n    let verticalOffset = 0;\n    let horizontalOffset = 0;\n    const isVerticalBound = widthOffsetInfo.isVerticalBound || heightOffsetInfo.isVerticalBound;\n    const isHorizontalBound = widthOffsetInfo.isHorizontalBound || heightOffsetInfo.isHorizontalBound;\n\n    if (isVerticalBound || isHorizontalBound) {\n        [verticalOffset, horizontalOffset] = getInverseDragDist({\n            datas,\n            distX: -widthOffsetInfo.offset[0],\n            distY: -heightOffsetInfo.offset[1],\n        });\n    }\n\n    return {\n        vertical: {\n            isBound: isVerticalBound,\n            offset: verticalOffset,\n        },\n        horizontal: {\n            isBound: isHorizontalBound,\n            offset: horizontalOffset,\n        },\n    };\n}\nexport function getCheckSnapLineDirections(\n    direction: number[],\n    keepRatio: boolean,\n) {\n    const lineDirections: number[][][] = [];\n    const x = direction[0];\n    const y = direction[1];\n    if (x && y) {\n        lineDirections.push(\n            [[0, y * 2], direction, [-x, y]],\n            [[x * 2, 0], direction, [x, -y]],\n        );\n    } else if (x) {\n        // vertcal\n        lineDirections.push(\n            [[x * 2, 0], [x, 1], [x, -1]],\n        );\n        if (keepRatio) {\n            lineDirections.push(\n                [[0, -1], [x, -1], [-x, -1]],\n                [[0, 1], [x, 1], [-x, 1]],\n            );\n        }\n    } else if (y) {\n        // horizontal\n        lineDirections.push(\n            [[0, y * 2], [1, y], [-1, y]],\n        );\n        if (keepRatio) {\n            lineDirections.push(\n                [[-1, 0], [-1, y], [-1, -y]],\n                [[1, 0], [1, y], [1, -y]],\n            );\n        }\n    } else {\n        // [0, 0] to all direction\n        lineDirections.push(\n            [[-1, 0], [-1, -1], [-1, 1]],\n            [[1, 0], [1, -1], [1, 1]],\n            [[0, -1], [-1, -1], [1, -1]],\n            [[0, 1], [-1, 1], [1, 1]],\n        );\n    }\n\n    return lineDirections;\n}\nexport interface InnerBoundLineInfo {\n    line: number[][];\n    multiple: number[];\n    horizontalSign: boolean;\n    verticalSign: boolean;\n    centerSign: boolean;\n    lineConstants: [number, number, number];\n}\nexport function getCheckInnerBoundLineInfos(\n    moveable: MoveableManagerInterface<SnappableProps>,\n    poses: number[][],\n    direction: number[],\n    keepRatio: boolean,\n): InnerBoundLineInfo[] {\n    const {\n        allMatrix,\n        is3d,\n    } = moveable.state;\n    const virtualPoses = calculatePoses(allMatrix, 100, 100, is3d ? 4 : 3);\n    const center = getPosByDirection(virtualPoses, [0, 0]);\n\n    return getCheckSnapLineDirections(direction, keepRatio).map(([multiple, dir1, dir2]) => {\n        const virtualLine = [\n            getPosByDirection(virtualPoses, dir1),\n            getPosByDirection(virtualPoses, dir2),\n        ];\n        const lineConstants = solveLineConstants(virtualLine);\n        const {\n            vertical: verticalSign,\n            horizontal: horizontalSign,\n        } = isStartLine(center, virtualLine);\n        const centerSign = hitTestLine(center, virtualLine) <= 0;\n\n        return {\n            multiple,\n            centerSign,\n            verticalSign,\n            horizontalSign,\n            lineConstants,\n            line: [\n                getPosByDirection(poses, dir1),\n                getPosByDirection(poses, dir2),\n            ],\n        };\n    });\n}\n\nfunction isBoundRotate(\n    relativePoses: number[][],\n    boundDots: number[][],\n    center: number[],\n    rad: number,\n) {\n    const nextPoses = rad ? relativePoses.map(pos => rotate(pos, rad)) : relativePoses;\n    return [\n        [nextPoses[0], nextPoses[1]],\n        [nextPoses[1], nextPoses[3]],\n        [nextPoses[3], nextPoses[2]],\n        [nextPoses[2], nextPoses[0]],\n    ].some(line => {\n        const centerSign = hitTestLine(center, line) <= 0;\n\n        return !isSameStartLine(boundDots, line, centerSign);\n    });\n}\nfunction getDistPointLine([pos1, pos2]: number[][]) {\n    // x = 0, y = 0\n    // d = (ax + by + c) / root(a2 + b2)\n\n    const dx = pos2[0] - pos1[0];\n    const dy = pos2[1] - pos1[1];\n\n    if (!dx) {\n        return Math.abs(pos1[0]);\n    }\n    if (!dy) {\n        return Math.abs(pos1[1]);\n    }\n    // y - y1 = a(x - x1)\n    // 0 = ax -y + -a * x1 + y1\n\n    const a = dy / dx;\n\n    return Math.abs((-a * pos1[0] + pos1[1]) / Math.sqrt(Math.pow(a, 2) + 1));\n}\nfunction solveReverseLine([pos1, pos2]: number[][]) {\n    const dx = pos2[0] - pos1[0];\n    const dy = pos2[1] - pos1[1];\n\n    if (!dx) {\n        return [pos1[0], 0];\n    }\n    if (!dy) {\n        return [0, pos1[1]];\n    }\n    const a = dy / dx;\n    // y - y1 = a (x  - x1)\n    // y = ax - a * x1 + y1\n    const b = -a * pos1[0] + pos1[1];\n    // y = ax + b = -1/a x\n    // x = -b / (a + 1 / a)\n    // y = b / (1 + 1 / a^2)\n\n    return [\n        -b / (a + 1 / a),\n        b / ((a * a) + 1),\n    ];\n}\nexport function checkRotateInnerBounds(\n    moveable: MoveableManagerInterface<SnappableProps & RotatableProps, any>,\n    prevPoses: number[][],\n    nextPoses: number[][],\n    origin: number[],\n    rotation: number,\n) {\n    const bounds = moveable.props.innerBounds;\n    const rad = rotation * Math.PI / 180;\n\n    if (!bounds) {\n        return [];\n    }\n    const {\n        left,\n        top,\n        width,\n        height,\n    } = bounds;\n\n    const relativeLeft = left - origin[0];\n    const relativeRight = left + width - origin[0];\n    const relativeTop = top - origin[1];\n    const relativeBottom = top + height - origin[1];\n    const dots = [\n        [relativeLeft, relativeTop],\n        [relativeRight, relativeTop],\n        [relativeLeft, relativeBottom],\n        [relativeRight, relativeBottom],\n    ];\n    const center = getPosByDirection(nextPoses, [0, 0]);\n\n    if (!isBoundRotate(nextPoses, dots, center, 0)) {\n        return [];\n    }\n    const result: number[] = [];\n    const dotInfos = dots.map(dot => [\n        getDistSize(dot),\n        getRad([0, 0], dot),\n    ]);\n    [\n        [nextPoses[0], nextPoses[1]],\n        [nextPoses[1], nextPoses[3]],\n        [nextPoses[3], nextPoses[2]],\n        [nextPoses[2], nextPoses[0]],\n    ].forEach(line => {\n        const lineRad = getRad([0, 0], solveReverseLine(line));\n        const lineDist = getDistPointLine(line);\n\n        result.push(...dotInfos\n            .filter(([dotDist]) => {\n                return dotDist && lineDist <= dotDist;\n            })\n            .map(([dotDist, dotRad]) => {\n                const distRad = Math.acos(dotDist ? lineDist / dotDist : 0);\n                const nextRad1 = dotRad + distRad;\n                const nextRad2 = dotRad - distRad;\n\n                return [\n                    rad + nextRad1 - lineRad,\n                    rad + nextRad2 - lineRad,\n                ];\n            })\n            .reduce((prev, cur) => {\n                prev.push(...cur);\n                return prev;\n            }, [])\n            .filter(nextRad => !isBoundRotate(prevPoses, dots, center, nextRad))\n            .map(nextRad => throttle(nextRad * 180 / Math.PI, TINY_NUM)));\n    });\n    return result;\n}\n\nexport function checkInnerBoundPoses(\n    moveable: MoveableManagerInterface<SnappableProps>,\n) {\n    const innerBounds = moveable.props.innerBounds;\n\n    if (!innerBounds) {\n        return {\n            vertical: [],\n            horizontal: [],\n        };\n    }\n    const {\n        pos1,\n        pos2,\n        pos3,\n        pos4,\n    } = moveable.getRect();\n    const poses = [pos1, pos2, pos3, pos4];\n    const center = getPosByDirection(poses, [0, 0]);\n    const { left, top, width, height } = innerBounds;\n    const leftLine = [[left, top], [left, top + height]];\n    const topLine = [[left, top], [left + width, top]];\n    const rightLine = [[left + width, top], [left + width, top + height]];\n    const bottomLine = [[left, top + height], [left + width, top + height]];\n    const lineInfos = getCheckInnerBoundLineInfos(moveable, poses, [0, 0], false);\n\n    const horizontalPoses: number[] = [];\n    const verticalPoses: number[] = [];\n\n    const boundMap = {\n        top: false,\n        bottom: false,\n        left: false,\n        right: false,\n    };\n\n    lineInfos.forEach(lineInfo => {\n        const { line, lineConstants } = lineInfo;\n        const {\n            horizontal: isHorizontalStart,\n            vertical: isVerticalStart,\n        } = isStartLine(center, line);\n\n        // test vertical\n        const topBoundInfo = checkLineBoundCollision(line, lineConstants, topLine, isVerticalStart, 1, true);\n        const bottomBoundInfo = checkLineBoundCollision(line, lineConstants, bottomLine, isVerticalStart, 1, true);\n\n        // test horizontal\n        const leftBoundInfo = checkLineBoundCollision(line, lineConstants, leftLine, isHorizontalStart, 1, true);\n        const rightBoundInfo = checkLineBoundCollision(line, lineConstants, rightLine, isHorizontalStart, 1, true);\n\n        if (topBoundInfo.isBound && !boundMap.top) {\n            horizontalPoses.push(top);\n            boundMap.top = true;\n        }\n        if (bottomBoundInfo.isBound && !boundMap.bottom) {\n            horizontalPoses.push(top + height);\n            boundMap.bottom = true;\n        }\n        if (leftBoundInfo.isBound && !boundMap.left) {\n            verticalPoses.push(left);\n            boundMap.left = true;\n        }\n        if (rightBoundInfo.isBound && !boundMap.right) {\n            verticalPoses.push(left + width);\n            boundMap.right = true;\n        }\n    });\n\n    return {\n        horizontal: horizontalPoses,\n        vertical: verticalPoses,\n    };\n}\n","import { getRad, throttle } from \"@daybrush/utils\";\nimport {\n    BoundInfo, SnappableProps, BoundType,\n    RotatableProps, MoveableManagerInterface, SnappableState,\n} from \"../../types\";\nimport { rotate, minus } from \"@scena/matrix\";\nimport { getDistSize } from \"../../utils\";\nimport { TINY_NUM } from \"../../consts\";\n\nexport function checkBoundPoses(\n    bounds: BoundType | false | undefined,\n    verticalPoses: number[],\n    horizontalPoses: number[],\n) {\n    const {\n        position = \"client\",\n        left = -Infinity,\n        top = -Infinity,\n        right = Infinity,\n        bottom = Infinity,\n    } = bounds || {};\n    const nextBounds = {\n        position,\n        left,\n        top,\n        right,\n        bottom,\n    };\n\n    return {\n        vertical: checkBounds(nextBounds, verticalPoses, true),\n        horizontal: checkBounds(nextBounds, horizontalPoses, false),\n    };\n}\nexport function getBounds(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    externalBounds?: BoundType | false | null,\n) {\n    const {\n        containerClientRect: {\n            clientHeight: containerHeight,\n            clientWidth: containerWidth,\n            clientLeft,\n            clientTop,\n        },\n        snapOffset: {\n            left: snapOffsetLeft,\n            top: snapOffsetTop,\n            right: snapOffsetRight,\n            bottom: snapOffsetBottom,\n        },\n    } = moveable.state;\n    const bounds = externalBounds || moveable.props.bounds || {} as BoundType;\n    const position = bounds.position || \"client\";\n    const isCSS = position === \"css\";\n    const {\n        left = -Infinity,\n        top = -Infinity,\n    } = bounds;\n    let {\n        right = isCSS ? -Infinity : Infinity,\n        bottom = isCSS ? -Infinity : Infinity,\n    } = bounds;\n\n    if (isCSS) {\n        right = containerWidth! + snapOffsetRight - snapOffsetLeft - right;\n        bottom = containerHeight! + snapOffsetBottom - snapOffsetTop - bottom;\n    }\n\n    return {\n        left: left + snapOffsetLeft - clientLeft!,\n        right: right + snapOffsetLeft - clientLeft!,\n        top: top + snapOffsetTop - clientTop!,\n        bottom: bottom + snapOffsetTop - clientTop!,\n    };\n}\nexport function checkBoundKeepRatio(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    startPos: number[],\n    endPos: number[],\n) {\n    const {\n        left,\n        top,\n        right,\n        bottom,\n    } = getBounds(moveable);\n\n    const [endX, endY] = endPos;\n    let [dx, dy] = minus(endPos, startPos);\n\n    if (Math.abs(dx) < TINY_NUM) {\n        dx = 0;\n    }\n    if (Math.abs(dy) < TINY_NUM) {\n        dy = 0;\n    }\n    const isBottom = dy > 0;\n    const isRight = dx > 0;\n\n    const verticalInfo = {\n        isBound: false,\n        offset: 0,\n        pos: 0,\n    };\n    const horizontalInfo = {\n        isBound: false,\n        offset: 0,\n        pos: 0,\n    };\n    if (dx === 0 && dy === 0) {\n        return {\n            vertical: verticalInfo,\n            horizontal: horizontalInfo,\n        };\n    } else if (dx === 0) {\n        if (isBottom) {\n            if (bottom < endY) {\n                horizontalInfo.pos = bottom;\n                horizontalInfo.offset = endY - bottom;\n            }\n        } else {\n            if (top > endY) {\n                horizontalInfo.pos = top;\n                horizontalInfo.offset = endY - top;\n            }\n        }\n    } else if (dy === 0) {\n        if (isRight) {\n            if (right < endX) {\n                verticalInfo.pos = right;\n                verticalInfo.offset = endX - right;\n            }\n        } else {\n            if (left > endX) {\n                verticalInfo.pos = left;\n                verticalInfo.offset = endX - left;\n            }\n        }\n    } else {\n        // y - y1 = a * (x - x1)\n        const a = dy / dx;\n        const b = endPos[1] - a * endX;\n        let y = 0;\n        let x = 0;\n        let isBound = false;\n\n        if (isRight && right <= endX) {\n            y = a * right + b;\n            x = right;\n            isBound = true;\n        } else if (!isRight && endX <= left) {\n            y = a * left + b;\n            x = left;\n            isBound = true;\n        }\n        if (isBound) {\n            if (y < top || y > bottom) {\n                isBound = false;\n            }\n        }\n        if (!isBound) {\n            if (isBottom && bottom <= endY) {\n                y = bottom;\n                x = (y - b) / a;\n                isBound = true;\n            } else if (!isBottom &&  endY <= top) {\n                y = top;\n                x = (y - b) / a;\n                isBound = true;\n            }\n        }\n        if (isBound) {\n            verticalInfo.isBound = true;\n            verticalInfo.pos = x;\n            verticalInfo.offset = endX - x;\n\n            horizontalInfo.isBound = true;\n            horizontalInfo.pos = y;\n            horizontalInfo.offset = endY - y;\n        }\n    }\n\n    return {\n        vertical: verticalInfo,\n        horizontal: horizontalInfo,\n    };\n}\nfunction checkBounds(\n    bounds: Required<BoundType>,\n    poses: number[],\n    isVertical: boolean,\n): BoundInfo[] {\n    // 0   [100 - 200]  300\n    const startBoundPos = bounds[isVertical ? \"left\" : \"top\"];\n    const endBoundPos = bounds[isVertical ? \"right\" : \"bottom\"];\n\n    // 450\n    const minPos = Math.min(...poses);\n    const maxPos = Math.max(...poses);\n    const boundInfos: BoundInfo[] = [];\n\n    if (startBoundPos + 1 > minPos) {\n        boundInfos.push({\n            isBound: true,\n            offset: minPos - startBoundPos,\n            pos: startBoundPos,\n        });\n    }\n    if (endBoundPos - 1 < maxPos) {\n        boundInfos.push({\n            isBound: true,\n            offset: maxPos - endBoundPos,\n            pos: endBoundPos,\n        });\n    }\n\n    if (!boundInfos.length) {\n        boundInfos.push({\n            isBound: false,\n            offset: 0,\n            pos: 0,\n        });\n    }\n\n    return boundInfos.sort((a, b) => Math.abs(b.offset) - Math.abs(a.offset));\n}\nexport function isBoundRotate(\n    relativePoses: number[][],\n    boundRect: { left: number, top: number, right: number, bottom: number },\n    rad: number,\n) {\n    const nextPoses = rad ? relativePoses.map(pos => rotate(pos, rad)) : relativePoses;\n\n    return nextPoses.some(pos => {\n        return (pos[0] < boundRect.left && Math.abs(pos[0] - boundRect.left) > 0.1)\n            || (pos[0] > boundRect.right && Math.abs(pos[0] - boundRect.right) > 0.1)\n            || (pos[1] < boundRect.top && Math.abs(pos[1] - boundRect.top) > 0.1)\n            || (pos[1] > boundRect.bottom && Math.abs(pos[1] - boundRect.bottom) > 0.1);\n    });\n}\nexport function boundRotate(\n    vec: number[],\n    boundPos: number,\n    index: number,\n) {\n    const r = getDistSize(vec);\n    const nextPos = Math.sqrt(r * r - boundPos * boundPos) || 0;\n\n    return [nextPos, -nextPos].sort((a, b) => {\n        return Math.abs(a - vec[index ? 0 : 1]) - Math.abs(b - vec[index ? 0 : 1]);\n    }).map(pos => {\n        return getRad([0, 0], index ? [pos, boundPos] : [boundPos, pos]);\n    });\n}\n\nexport function checkRotateBounds(\n    moveable: MoveableManagerInterface<SnappableProps & RotatableProps, SnappableState>,\n    prevPoses: number[][],\n    nextPoses: number[][],\n    origin: number[],\n    rotation: number,\n) {\n    if (!moveable.props.bounds) {\n        return [];\n    }\n    const rad = rotation * Math.PI / 180;\n\n    const {\n        left,\n        top,\n        right,\n        bottom,\n    } = getBounds(moveable);\n\n    const relativeLeft = left - origin[0];\n    const relativeRight = right - origin[0];\n    const relativeTop = top - origin[1];\n    const relativeBottom = bottom - origin[1];\n    const boundRect = {\n        left: relativeLeft,\n        top: relativeTop,\n        right: relativeRight,\n        bottom: relativeBottom,\n    };\n\n    if (!isBoundRotate(nextPoses, boundRect, 0)) {\n        return [];\n    }\n    const result: number[] = [];\n    [\n        [relativeLeft, 0],\n        [relativeRight, 0],\n        [relativeTop, 1],\n        [relativeBottom, 1],\n    ].forEach(([boundPos, index]) => {\n        nextPoses.forEach(nextPos => {\n            const relativeRad1 = getRad([0, 0], nextPos);\n\n            result.push(...boundRotate(nextPos, boundPos, index)\n                .map(relativeRad2 => rad + relativeRad2 - relativeRad1)\n                .filter(nextRad => !isBoundRotate(prevPoses, boundRect, nextRad))\n                .map(nextRad => throttle(nextRad * 180 / Math.PI, TINY_NUM)));\n        });\n    });\n\n    return result;\n}\n","import { throttle } from \"@daybrush/utils\";\nimport {\n    RenderGuidelineInfo, Renderer, RenderGuidelineInnerInfo,\n    MoveableManagerInterface, SnappableProps, SnapGuideline,\n    SnappableRenderType, SnappableState,\n    SnapDirectionPoses,\n} from \"../../types\";\nimport { prefix, groupBy } from \"../../utils\";\nimport { HORIZONTAL_NAMES_MAP, VERTICAL_NAMES_MAP } from \"./utils\";\n\nexport function renderGuideline(info: RenderGuidelineInfo, React: Renderer): any {\n    const { direction, classNames, size, pos, zoom, key } = info;\n    const isHorizontal = direction === \"horizontal\";\n    const scaleType = isHorizontal ? \"Y\" : \"X\";\n    // const scaleType2 = isHorizontal ? \"Y\" : \"X\";\n\n    return React.createElement(\"div\", {\n        key,\n        className: classNames.join(\" \"),\n        style: {\n            [isHorizontal ? \"width\" : \"height\"]: `${size}`,\n            transform: `translate(${pos[0]}, ${pos[1]}) translate${scaleType}(-50%) scale${scaleType}(${zoom})`,\n        },\n    });\n}\n\nexport function renderInnerGuideline(info: RenderGuidelineInnerInfo, React: Renderer): any {\n    return renderGuideline({\n        ...info,\n        classNames: [\n            prefix(\"line\", \"guideline\", info.direction),\n            ...info.classNames,\n        ].filter(className => className) as string[],\n        size: info.size || `${info.sizeValue}px`,\n        pos: info.pos || info.posValue.map(v => `${throttle(v, 0.1)}px`),\n    }, React);\n}\n\nexport function renderSnapPoses(\n    moveable: MoveableManagerInterface,\n    direction: string,\n    snapPoses: SnappableRenderType[],\n    minPos: number,\n    targetPos: number,\n    size: number,\n    index: number,\n    React: Renderer\n) {\n    const { zoom } = moveable.props;\n    return snapPoses.map(({ type, pos }, i) => {\n        const renderPos = [0, 0];\n\n        renderPos[index] = minPos;\n        renderPos[index ? 0 : 1] = -targetPos + pos;\n\n        return renderInnerGuideline(\n            {\n                key: `${direction}TargetGuideline${i}`,\n                classNames: [prefix(\"target\", \"bold\", type)],\n                posValue: renderPos,\n                sizeValue: size,\n                zoom: zoom!,\n                direction: direction,\n            },\n            React\n        );\n    });\n}\nexport function renderGuidelines(\n    moveable: MoveableManagerInterface<SnappableProps>,\n    type: \"vertical\" | \"horizontal\",\n    guidelines: SnapGuideline[],\n    targetPos: number[],\n    targetRect: SnapDirectionPoses,\n    React: Renderer\n): any[] {\n    const { zoom, isDisplayInnerSnapDigit } = moveable.props;\n\n    const mainNames = type === \"horizontal\" ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;\n    const targetStart = targetRect[mainNames.start]!;\n    const targetEnd = targetRect[mainNames.end]!;\n    return guidelines.filter(({ hide, elementRect }) => {\n        if (hide) {\n            return false;\n        }\n        if (isDisplayInnerSnapDigit && elementRect) {\n            // inner\n            const rect = elementRect.rect;\n\n            if (rect[mainNames.start]! <= targetStart && targetEnd <= rect[mainNames.end]!) {\n                return false;\n            }\n        }\n        return true;\n    }).map((guideline, i) => {\n        const { pos, size, element, className } = guideline;\n\n        const renderPos = [\n            -targetPos[0] + pos[0],\n            -targetPos[1] + pos[1],\n        ];\n\n        return renderInnerGuideline(\n            {\n                key: `${type}-default-guideline-${i}`,\n                classNames: element ? [prefix(\"bold\"), className] : [prefix(\"normal\"), className],\n                direction: type,\n                posValue: renderPos,\n                sizeValue: size,\n                zoom: zoom!,\n            },\n            React\n        );\n    });\n}\n\nexport function renderDigitLine(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    type: \"vertical\" | \"horizontal\",\n    lineType: \"dashed\" | \"gap\",\n    index: number,\n    gap: number,\n    renderPos: number[],\n    className: string | undefined,\n    React: Renderer,\n): any {\n    const {\n        snapDigit = 0,\n        isDisplaySnapDigit = true,\n        snapDistFormat = (v: number, type: \"vertical\" | \"horizontal\") => {\n            // Type can be used render different values.\n            if (type === 'vertical') {\n                return v;\n            }\n            return v;\n        },\n        zoom,\n    } = moveable.props;\n    const scaleType = type === \"horizontal\" ? \"X\" : \"Y\";\n    const sizeName = type === \"vertical\" ? \"height\" : \"width\";\n    const absGap = Math.abs(gap!);\n    const snapSize = isDisplaySnapDigit\n        ? parseFloat(absGap.toFixed(snapDigit))\n        : 0;\n    return <div\n        key={`${type}-${lineType}-guideline-${index}`}\n        className={prefix(\"guideline-group\", type)}\n        style={{\n            left: `${renderPos[0]}px`,\n            top: `${renderPos[1]}px`,\n            [sizeName]: `${absGap}px`,\n        }}\n    >\n        {renderInnerGuideline(\n            {\n                direction: type,\n                classNames: [prefix(lineType), className],\n                size: \"100%\",\n                posValue: [0, 0],\n                sizeValue: absGap,\n                zoom: zoom!,\n            },\n            React\n        )}\n        <div\n            className={prefix(\"size-value\", \"gap\")}\n            style={{\n                transform: `translate${scaleType}(-50%) scale(${zoom})`,\n            }}\n        >\n            {snapSize > 0 ? snapDistFormat(snapSize, type) : \"\"}\n        </div>\n    </div>;\n}\n\nexport function groupByElementGuidelines(\n    type: \"vertical\" | \"horizontal\",\n    guidelines: SnapGuideline[],\n    targetRect: SnapDirectionPoses,\n    isDisplayInnerSnapDigit: boolean,\n) {\n    const index = type === \"vertical\" ? 0 : 1;\n    const otherIndex = type === \"vertical\" ? 1 : 0;\n    const names = index ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;\n    const targetStart = targetRect[names.start]!;\n    const targetEnd = targetRect[names.end]!;\n    return groupBy(guidelines, (guideline) => {\n        return guideline.pos[index];\n    }).map(nextGuidelines => {\n        const start: SnapGuideline[] = [];\n        const end: SnapGuideline[] = [];\n        const inner: SnapGuideline[] = [];\n\n        nextGuidelines.forEach(guideline => {\n            const element = guideline.element!;\n            const rect = guideline.elementRect!.rect;\n            if (rect[names.end]! < targetStart) {\n                start.push(guideline);\n            } else if (targetEnd < rect[names.start]!) {\n                end.push(guideline);\n            } else if (rect[names.start]! <= targetStart && targetEnd <= rect[names.end]! && isDisplayInnerSnapDigit) {\n                const pos = guideline.pos;\n                const elementRect1 = { element, rect: { ...rect, [names.end]: rect[names.start]! } };\n                const elementRect2 = { element, rect: { ...rect, [names.start]: rect[names.end]! } };\n                const nextPos1 = [0, 0];\n                const nextPos2 = [0, 0];\n                nextPos1[index] = pos[index];\n                nextPos1[otherIndex] = pos[otherIndex];\n\n                nextPos2[index] = pos[index];\n                nextPos2[otherIndex] = pos[otherIndex] + guideline.size;\n\n\n                start.push({\n                    type,\n                    pos: nextPos1,\n                    size: 0,\n                    elementRect: elementRect1,\n                });\n                end.push({\n                    type,\n                    pos: nextPos2,\n                    size: 0,\n                    elementRect: elementRect2,\n                });\n                // inner.push(guideline);\n            }\n        });\n\n        start.sort((a, b) => {\n            return b.pos[otherIndex] - a.pos[otherIndex];\n        });\n        end.sort((a, b) => {\n            return a.pos[otherIndex] - b.pos[otherIndex];\n        });\n        return {\n            total: nextGuidelines,\n            start,\n            end,\n            inner,\n        };\n    });\n}\nexport function renderDashedGuidelines(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    guidelines: SnapGuideline[],\n    targetPos: number[],\n    targetRect: SnapDirectionPoses,\n    React: Renderer,\n): any[] {\n    const {\n        isDisplayInnerSnapDigit,\n    } = moveable.props;\n    const rendered: any[] = [];\n\n    ([\"vertical\", \"horizontal\"] as const).forEach(type => {\n        const nextGuidelines = guidelines.filter(guideline => guideline.type === type);\n        const index = type === \"vertical\" ? 1 : 0;\n        const otherIndex = index ? 0 : 1;\n\n        const groups = groupByElementGuidelines(type, nextGuidelines, targetRect, isDisplayInnerSnapDigit!);\n        const mainNames = index ? HORIZONTAL_NAMES_MAP : VERTICAL_NAMES_MAP;\n        const sideNames = index ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;\n        const targetStart = targetRect[mainNames.start]!;\n        const targetEnd = targetRect[mainNames.end]!;\n\n        groups.forEach(({ total, start, end, inner }) => {\n            const sidePos = targetPos[otherIndex] + total[0].pos[otherIndex] - targetRect[sideNames.start]!;\n\n            let prevRect = targetRect;\n\n            start.forEach(guideline => {\n                const nextRect = guideline.elementRect!.rect;\n                const size = prevRect[mainNames.start]! - nextRect[mainNames.end]!;\n\n                if (size > 0) {\n                    const renderPos = [0, 0];\n\n                    renderPos[index] = targetPos[index] + prevRect[mainNames.start]! - targetStart - size;\n                    renderPos[otherIndex] = sidePos;\n\n                    rendered.push(renderDigitLine(\n                        moveable,\n                        type,\n                        \"dashed\",\n                        rendered.length,\n                        size,\n                        renderPos,\n                        guideline.className,\n                        React\n                    ));\n                }\n                prevRect = nextRect;\n            });\n\n            prevRect = targetRect;\n            end.forEach(guideline => {\n                const nextRect = guideline.elementRect!.rect;\n                const size = nextRect[mainNames.start]! - prevRect[mainNames.end]!;\n\n                if (size > 0) {\n                    const renderPos = [0, 0];\n\n                    renderPos[index] = targetPos[index] + prevRect[mainNames.end]! - targetStart;\n                    renderPos[otherIndex] = sidePos;\n\n                    rendered.push(renderDigitLine(\n                        moveable,\n                        type,\n                        \"dashed\",\n                        rendered.length,\n                        size,\n                        renderPos,\n                        guideline.className,\n                        React\n                    ));\n                }\n                prevRect = nextRect;\n            });\n\n            inner.forEach(guideline => {\n                const nextRect = guideline.elementRect!.rect;\n\n                const size1 = targetStart - nextRect[mainNames.start]!;\n                const size2 = nextRect[mainNames.end]! - targetEnd;\n                const renderPos1 = [0, 0];\n                const renderPos2 = [0, 0];\n\n                renderPos1[index] = targetPos[index] - size1;\n                renderPos1[otherIndex] = sidePos;\n\n                renderPos2[index] = targetPos[index] + targetEnd - targetStart;\n                renderPos2[otherIndex] = sidePos;\n\n                rendered.push(renderDigitLine(\n                    moveable,\n                    type,\n                    \"dashed\",\n                    rendered.length,\n                    size1,\n                    renderPos1,\n                    guideline.className,\n                    React\n                ));\n                rendered.push(renderDigitLine(\n                    moveable,\n                    type,\n                    \"dashed\",\n                    rendered.length,\n                    size2,\n                    renderPos2,\n                    guideline.className,\n                    React\n                ));\n            });\n        });\n    });\n    return rendered;\n}\nexport function renderGapGuidelines(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    guidelines: SnapGuideline[],\n    targetPos: number[],\n    targetRect: SnapDirectionPoses,\n    React: any\n): any[] {\n    const rendered: any[] = [];\n    ([\"horizontal\", \"vertical\"] as const).forEach(type => {\n        const nextGuidelines = guidelines.filter(guideline => guideline.type === type);\n        const index = type === \"vertical\" ? 0 : 1;\n        const otherIndex = index ? 0 : 1;\n        const mainNames = index ? HORIZONTAL_NAMES_MAP : VERTICAL_NAMES_MAP;\n        const sideNames = index ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;\n        const targetStart = targetRect[mainNames.start]!;\n        const targetEnd = targetRect[mainNames.end]!;\n        const targetSideStart = targetRect[sideNames.start]!;\n        const targetSideEnd = targetRect[sideNames.end]!;\n\n\n        nextGuidelines.forEach(({ gap, gapRects }) => {\n            const sideStartPos = Math.max(\n                targetSideStart,\n                ...gapRects!.map(({ rect }) => rect[sideNames.start]!),\n            );\n            const sideEndPos = Math.min(\n                targetSideEnd,\n                ...gapRects!.map(({ rect }) => rect[sideNames.end]!),\n            );\n            const sideCenterPos = (sideStartPos + sideEndPos) / 2;\n\n            if (sideStartPos === sideEndPos || sideCenterPos === (targetSideStart + targetSideEnd)/ 2) {\n                return;\n            }\n            gapRects!.forEach(({ rect, className }) => {\n                const renderPos = [targetPos[0], targetPos[1]];\n\n                if (rect[mainNames.end]! < targetStart) {\n                    renderPos[index] += rect[mainNames.end]! - targetStart;\n                } else if (targetEnd < rect[mainNames.start]!) {\n                    renderPos[index] += rect[mainNames.start]! - targetStart - gap!;\n                } else {\n                    return;\n                }\n\n                renderPos[otherIndex] += sideCenterPos - targetSideStart;\n                rendered.push(renderDigitLine(\n                    moveable,\n                    index ? \"vertical\" : \"horizontal\",\n                    \"gap\",\n                    rendered.length,\n                    gap!,\n                    renderPos,\n                    className,\n                    React\n                ));\n            });\n        });\n    });\n    return rendered;\n}\n","import { getDist, getRad, IObject, TINY_NUM } from \"@daybrush/utils\";\nimport { minus } from \"@scena/matrix\";\nimport { getAbsolutePoses, getDistSize, getRect, maxOffset } from \"../../utils\";\nimport { getDragDist, getPosByDirection } from \"../../gesto/GestoUtils\";\nimport {\n    BoundInfo, SnapInfo, MoveableManagerInterface, SnappableProps,\n    SnappableState, SnapBoundInfo, SnapGuideline, BoundType, SnapOffsetInfo, DraggableProps,\n} from \"../../types\";\nimport { checkBoundKeepRatio, checkBoundPoses, getBounds } from \"./bounds\";\nimport { getInnerBoundDragInfo } from \"./innerBounds\";\nimport {\n    getNearestSnapGuidelineInfo, checkMoveableSnapPoses,\n    checkSnapPoses, checkSnapKeepRatio,\n} from \"./snap\";\nimport { hasGuidelines, getSnapDirections, splitSnapDirectionPoses } from \"./utils\";\n\ninterface DirectionSnapType<T> {\n    vertical: T;\n    horizontal: T;\n}\n\n\nexport function solveEquation(\n    pos1: number[],\n    pos2: number[],\n    snapOffset: number,\n    isVertical: boolean\n) {\n    let dx = pos2[0] - pos1[0];\n    let dy = pos2[1] - pos1[1];\n\n    if (Math.abs(dx) < TINY_NUM) {\n        dx = 0;\n    }\n    if (Math.abs(dy) < TINY_NUM) {\n        dy = 0;\n    }\n    if (!dx) {\n        // y = 0 * x + b\n        // only horizontal\n        if (!isVertical) {\n            return [0, snapOffset];\n        }\n        return [0, 0];\n    }\n    if (!dy) {\n        // only vertical\n        if (isVertical) {\n            return [snapOffset, 0];\n        }\n        return [0, 0];\n    }\n    // y = ax + b\n    const a = dy / dx;\n    const b = pos1[1] - a * pos1[0];\n\n    if (isVertical) {\n        // y = a * x + b\n        const y = a * (pos2[0] + snapOffset) + b;\n\n        return [snapOffset, y - pos2[1]];\n    } else {\n        // x = (y - b) / a\n        const x = (pos2[1] + snapOffset - b) / a;\n\n        return [x - pos2[0], snapOffset];\n    }\n}\n\n\nfunction solveNextOffset(\n    pos1: number[],\n    pos2: number[],\n    offset: number,\n    isVertical: boolean,\n    datas: IObject<any>\n) {\n    const sizeOffset = solveEquation(pos1, pos2, offset, isVertical);\n\n    if (!sizeOffset) {\n        return {\n            isOutside: false,\n            offset: [0, 0],\n        };\n    }\n    const size = getDist(pos1, pos2);\n    const dist1 = getDist(sizeOffset, pos1);\n    const dist2 = getDist(sizeOffset, pos2);\n\n    const isOutside = dist1 > size || dist2 > size;\n    const [widthOffset, heightOffset] = getDragDist({\n        datas,\n        distX: sizeOffset[0],\n        distY: sizeOffset[1],\n    });\n\n    return {\n        offset: [widthOffset, heightOffset],\n        isOutside,\n    };\n}\n\nfunction getSnapBound(boundInfo: BoundInfo, snapInfo: SnapInfo) {\n    if (boundInfo.isBound) {\n        return boundInfo.offset;\n    } else if (snapInfo.isSnap) {\n        return getNearestSnapGuidelineInfo(snapInfo).offset;\n    }\n    return 0;\n}\n\n\nexport function checkThrottleDragRotate(\n    throttleDragRotate: number,\n    [distX, distY]: number[],\n    [isVerticalBound, isHorizontalBound]: boolean[],\n    [isVerticalSnap, isHorizontalSnap]: boolean[],\n    [verticalOffset, horizontalOffset]: number[]\n) {\n    let offsetX = -verticalOffset;\n    let offsetY = -horizontalOffset;\n\n    if (throttleDragRotate && distX && distY) {\n        offsetX = 0;\n        offsetY = 0;\n        const adjustPoses: number[][] = [];\n        if (isVerticalBound && isHorizontalBound) {\n            adjustPoses.push([0, horizontalOffset], [verticalOffset, 0]);\n        } else if (isVerticalBound) {\n            adjustPoses.push([verticalOffset, 0]);\n        } else if (isHorizontalBound) {\n            adjustPoses.push([0, horizontalOffset]);\n        } else if (isVerticalSnap && isHorizontalSnap) {\n            adjustPoses.push([0, horizontalOffset], [verticalOffset, 0]);\n        } else if (isVerticalSnap) {\n            adjustPoses.push([verticalOffset, 0]);\n        } else if (isHorizontalSnap) {\n            adjustPoses.push([0, horizontalOffset]);\n        }\n        if (adjustPoses.length) {\n            adjustPoses.sort((a, b) => {\n                return (\n                    getDistSize(minus([distX, distY], a)) -\n                    getDistSize(minus([distX, distY], b))\n                );\n            });\n            const adjustPos = adjustPoses[0];\n\n            if (adjustPos[0] && Math.abs(distX) > TINY_NUM) {\n                offsetX = -adjustPos[0];\n                offsetY =\n                    (distY * Math.abs(distX + offsetX)) / Math.abs(distX) -\n                    distY;\n            } else if (adjustPos[1] && Math.abs(distY) > TINY_NUM) {\n                const prevDistY = distY;\n                offsetY = -adjustPos[1];\n                offsetX =\n                    (distX * Math.abs(distY + offsetY)) / Math.abs(prevDistY) -\n                    distX;\n            }\n            if (throttleDragRotate && isHorizontalBound && isVerticalBound) {\n                if (\n                    Math.abs(offsetX) > TINY_NUM &&\n                    Math.abs(offsetX) < Math.abs(verticalOffset)\n                ) {\n                    const scale = Math.abs(verticalOffset) / Math.abs(offsetX);\n\n                    offsetX *= scale;\n                    offsetY *= scale;\n                } else if (\n                    Math.abs(offsetY) > TINY_NUM &&\n                    Math.abs(offsetY) < Math.abs(horizontalOffset)\n                ) {\n                    const scale =\n                        Math.abs(horizontalOffset) / Math.abs(offsetY);\n\n                    offsetX *= scale;\n                    offsetY *= scale;\n                } else {\n                    offsetX = maxOffset(-verticalOffset, offsetX);\n                    offsetY = maxOffset(-horizontalOffset, offsetY);\n                }\n            }\n        }\n    } else {\n        offsetX = distX || isVerticalBound ? -verticalOffset : 0;\n        offsetY = distY || isHorizontalBound ? -horizontalOffset : 0;\n    }\n    return [offsetX, offsetY];\n}\n\nexport function checkSnapBoundsDrag(\n    moveable: MoveableManagerInterface<SnappableProps & DraggableProps, any>,\n    distX: number,\n    distY: number,\n    throttleDragRotate: number,\n    isRequest: boolean,\n    datas: any\n) {\n    if (!hasGuidelines(moveable, \"draggable\")) {\n        return [\n            {\n                isSnap: false,\n                isBound: false,\n                offset: 0,\n            },\n            {\n                isSnap: false,\n                isBound: false,\n                offset: 0,\n            },\n        ];\n    }\n    const poses = getAbsolutePoses(datas.absolutePoses, [distX, distY]);\n    const { left, right, top, bottom } = getRect(poses);\n    const boundPoses = {\n        horizontal: poses.map((pos) => pos[1]),\n        vertical: poses.map((pos) => pos[0]),\n    };\n    const snapDirections = getSnapDirections(moveable.props.snapDirections);\n    const snapPoses = splitSnapDirectionPoses(snapDirections, {\n        left,\n        right,\n        top,\n        bottom,\n        center: (left + right) / 2,\n        middle: (top + bottom) / 2,\n    });\n    const {\n        vertical: verticalSnapBoundInfo,\n        horizontal: horizontalSnapBoundInfo,\n    } = checkMoveableSnapBounds(moveable, isRequest, snapPoses, boundPoses);\n    const {\n        vertical: verticalInnerBoundInfo,\n        horizontal: horizontalInnerBoundInfo,\n    } = getInnerBoundDragInfo(moveable, poses, datas);\n\n    const isVerticalSnap = verticalSnapBoundInfo.isSnap;\n    const isHorizontalSnap = horizontalSnapBoundInfo.isSnap;\n    const isVerticalBound =\n        verticalSnapBoundInfo.isBound || verticalInnerBoundInfo.isBound;\n    const isHorizontalBound =\n        horizontalSnapBoundInfo.isBound || horizontalInnerBoundInfo.isBound;\n    const verticalOffset = maxOffset(\n        verticalSnapBoundInfo.offset,\n        verticalInnerBoundInfo.offset\n    );\n    const horizontalOffset = maxOffset(\n        horizontalSnapBoundInfo.offset,\n        horizontalInnerBoundInfo.offset\n    );\n\n    const [offsetX, offsetY] = checkThrottleDragRotate(\n        throttleDragRotate,\n        [distX, distY],\n        [isVerticalBound, isHorizontalBound],\n        [isVerticalSnap, isHorizontalSnap],\n        [verticalOffset, horizontalOffset]\n    );\n\n    return [\n        {\n            isBound: isVerticalBound,\n            isSnap: isVerticalSnap,\n            offset: offsetX,\n        },\n        {\n            isBound: isHorizontalBound,\n            isSnap: isHorizontalSnap,\n            offset: offsetY,\n        },\n    ];\n}\n\nexport function checkMoveableSnapBounds(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    isRequest: boolean,\n    poses: { vertical: number[]; horizontal: number[]; },\n    boundPoses: { vertical: number[]; horizontal: number[]; } = poses,\n): DirectionSnapType<Required<SnapBoundInfo>> {\n    const {\n        horizontal: horizontalBoundInfos,\n        vertical: verticalBoundInfos,\n    } = checkBoundPoses(\n        getBounds(moveable),\n        boundPoses.vertical,\n        boundPoses.horizontal,\n    );\n    const {\n        horizontal: horizontalSnapInfo,\n        vertical: verticalSnapInfo,\n    } = isRequest ? {\n        horizontal: { isSnap: false, index: -1 } as SnapInfo,\n        vertical: { isSnap: false, index: -1 } as SnapInfo,\n    } : checkMoveableSnapPoses(\n        moveable,\n        poses.vertical,\n        poses.horizontal,\n    );\n    const horizontalOffset = getSnapBound(\n        horizontalBoundInfos[0],\n        horizontalSnapInfo\n    );\n    const verticalOffset = getSnapBound(\n        verticalBoundInfos[0],\n        verticalSnapInfo\n    );\n\n    const horizontalDist = Math.abs(horizontalOffset);\n    const verticalDist = Math.abs(verticalOffset);\n\n    return {\n        horizontal: {\n            isBound: horizontalBoundInfos[0].isBound,\n            isSnap: horizontalSnapInfo.isSnap,\n            snapIndex: horizontalSnapInfo.index,\n            offset: horizontalOffset,\n            dist: horizontalDist,\n            bounds: horizontalBoundInfos,\n            snap: horizontalSnapInfo,\n        },\n        vertical: {\n            isBound: verticalBoundInfos[0].isBound,\n            isSnap: verticalSnapInfo.isSnap,\n            snapIndex: verticalSnapInfo.index,\n            offset: verticalOffset,\n            dist: verticalDist,\n            bounds: verticalBoundInfos,\n            snap: verticalSnapInfo,\n        },\n    };\n}\nexport function checkSnapBounds(\n    guideines: SnapGuideline[],\n    bounds: BoundType | undefined | false,\n    posesX: number[],\n    posesY: number[],\n    snapThreshold: number,\n): DirectionSnapType<Required<SnapBoundInfo>> {\n    const {\n        horizontal: horizontalBoundInfos,\n        vertical: verticalBoundInfos,\n    } = checkBoundPoses(bounds, posesX, posesY);\n\n    // options.isRequest ? {\n    //     horizontal: { isSnap: false, index: -1 } as SnapInfo,\n    //     vertical: { isSnap: false, index: -1 } as SnapInfo,\n    // } :\n    const {\n        horizontal: horizontalSnapInfo,\n        vertical: verticalSnapInfo,\n    } = checkSnapPoses(guideines, posesX, posesY, snapThreshold);\n\n    const horizontalOffset = getSnapBound(\n        horizontalBoundInfos[0],\n        horizontalSnapInfo\n    );\n    const verticalOffset = getSnapBound(\n        verticalBoundInfos[0],\n        verticalSnapInfo\n    );\n\n    const horizontalDist = Math.abs(horizontalOffset);\n    const verticalDist = Math.abs(verticalOffset);\n\n    return {\n        horizontal: {\n            isBound: horizontalBoundInfos[0].isBound,\n            isSnap: horizontalSnapInfo.isSnap,\n            snapIndex: horizontalSnapInfo.index,\n            offset: horizontalOffset,\n            dist: horizontalDist,\n            bounds: horizontalBoundInfos,\n            snap: horizontalSnapInfo,\n        },\n        vertical: {\n            isBound: verticalBoundInfos[0].isBound,\n            isSnap: verticalSnapInfo.isSnap,\n            snapIndex: verticalSnapInfo.index,\n            offset: verticalOffset,\n            dist: verticalDist,\n            bounds: verticalBoundInfos,\n            snap: verticalSnapInfo,\n        },\n    };\n}\n\n\nfunction checkSnapRightLine(\n    startPos: number[],\n    endPos: number[],\n    snapBoundInfo: { vertical: SnapBoundInfo; horizontal: SnapBoundInfo },\n    keepRatio: boolean\n) {\n    const rad = (getRad(startPos, endPos) / Math.PI) * 180;\n    const {\n        vertical: {\n            isBound: isVerticalBound,\n            isSnap: isVerticalSnap,\n            dist: verticalDist,\n        },\n        horizontal: {\n            isBound: isHorizontalBound,\n            isSnap: isHorizontalSnap,\n            dist: horizontalDist,\n        },\n    } = snapBoundInfo;\n\n    const rad180 = rad % 180;\n    const isHorizontalLine = rad180 < 3 || rad180 > 177;\n    const isVerticalLine = rad180 > 87 && rad180 < 93;\n\n    if (horizontalDist < verticalDist) {\n        if (\n            isVerticalBound ||\n            (isVerticalSnap &&\n                !isVerticalLine &&\n                (!keepRatio || !isHorizontalLine))\n        ) {\n            return \"vertical\";\n        }\n    }\n    if (\n        isHorizontalBound ||\n        (isHorizontalSnap &&\n            !isHorizontalLine &&\n            (!keepRatio || !isVerticalLine))\n    ) {\n        return \"horizontal\";\n    }\n    return \"\";\n}\n\n\nexport function getSnapBoundInfo(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    poses: number[][],\n    directions: number[][][],\n    keepRatio: boolean,\n    isRequest: boolean,\n    datas: any\n) {\n    return directions.map(([startDirection, endDirection]) => {\n        const otherStartPos = getPosByDirection(poses, startDirection);\n        const otherEndPos = getPosByDirection(poses, endDirection);\n        const snapBoundInfo = keepRatio\n            ? checkSnapBoundsKeepRatio(\n                moveable,\n                otherStartPos,\n                otherEndPos,\n                isRequest\n            )\n            : checkMoveableSnapBounds(moveable, isRequest, {\n                vertical: [otherEndPos[0]],\n                horizontal: [otherEndPos[1]],\n            });\n\n        const {\n            horizontal: {\n                // dist: otherHorizontalDist,\n                offset: otherHorizontalOffset,\n                isBound: isOtherHorizontalBound,\n                isSnap: isOtherHorizontalSnap,\n            },\n            vertical: {\n                // dist: otherVerticalDist,\n                offset: otherVerticalOffset,\n                isBound: isOtherVerticalBound,\n                isSnap: isOtherVerticalSnap,\n            },\n        } = snapBoundInfo;\n\n        const multiple = minus(endDirection, startDirection);\n\n        if (!otherVerticalOffset && !otherHorizontalOffset) {\n            return {\n                isBound: isOtherVerticalBound || isOtherHorizontalBound,\n                isSnap: isOtherVerticalSnap || isOtherHorizontalSnap,\n                sign: multiple,\n                offset: [0, 0],\n            };\n        }\n        const snapLine = checkSnapRightLine(\n            otherStartPos,\n            otherEndPos,\n            snapBoundInfo,\n            keepRatio\n        );\n\n        if (!snapLine) {\n            return {\n                sign: multiple,\n                isBound: false,\n                isSnap: false,\n                offset: [0, 0],\n            };\n        }\n\n        const isVertical = snapLine === \"vertical\";\n        let sizeOffset = [0, 0];\n\n        if (\n            !keepRatio\n            && Math.abs(endDirection[0]) === 1\n            && Math.abs(endDirection[1]) === 1\n            && startDirection[0] !== endDirection[0]\n            && startDirection[1] !== endDirection[1]\n        ) {\n            sizeOffset = getDragDist({\n                datas,\n                distX: -otherVerticalOffset,\n                distY: -otherHorizontalOffset,\n            });\n        } else {\n            sizeOffset = solveNextOffset(\n                otherStartPos,\n                otherEndPos,\n                -(isVertical ? otherVerticalOffset : otherHorizontalOffset),\n                isVertical,\n                datas,\n            ).offset;\n        }\n        sizeOffset = sizeOffset.map((size, i) => size * (multiple[i] ? 2 / multiple[i] : 0));\n\n\n        return {\n            sign: multiple,\n            isBound: isVertical ? isOtherVerticalBound : isOtherHorizontalBound,\n            isSnap: isVertical ? isOtherVerticalSnap : isOtherHorizontalSnap,\n            offset: sizeOffset,\n        };\n    });\n}\n\n\nfunction getSnapBoundOffset(boundInfo: BoundInfo, snapInfo: SnapOffsetInfo) {\n    if (boundInfo.isBound) {\n        return boundInfo.offset;\n    } else if (snapInfo.isSnap) {\n        return snapInfo.offset;\n    }\n    return 0;\n}\n\nexport function checkSnapBoundsKeepRatio(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    startPos: number[],\n    endPos: number[],\n    isRequest: boolean\n): DirectionSnapType<SnapBoundInfo> {\n    const {\n        horizontal: horizontalBoundInfo,\n        vertical: verticalBoundInfo,\n    } = checkBoundKeepRatio(moveable, startPos, endPos);\n    const {\n        horizontal: horizontalSnapInfo,\n        vertical: verticalSnapInfo,\n    } = isRequest ? ({\n        horizontal: { isSnap: false },\n        vertical: { isSnap: false },\n    } as any) : checkSnapKeepRatio(moveable, startPos, endPos);\n\n    const horizontalOffset = getSnapBoundOffset(\n        horizontalBoundInfo,\n        horizontalSnapInfo\n    );\n    const verticalOffset = getSnapBoundOffset(\n        verticalBoundInfo,\n        verticalSnapInfo\n    );\n\n    const horizontalDist = Math.abs(horizontalOffset);\n    const verticalDist = Math.abs(verticalOffset);\n\n    return {\n        horizontal: {\n            isBound: horizontalBoundInfo.isBound,\n            isSnap: horizontalSnapInfo.isSnap,\n            offset: horizontalOffset,\n            dist: horizontalDist,\n        },\n        vertical: {\n            isBound: verticalBoundInfo.isBound,\n            isSnap: verticalSnapInfo.isSnap,\n            offset: verticalOffset,\n            dist: verticalDist,\n        },\n    };\n}\n\nexport function checkMaxBounds(\n    moveable: MoveableManagerInterface<SnappableProps>,\n    poses: number[][],\n    direction: number[],\n    fixedPosition: number[],\n    datas: any\n) {\n    const fixedDirection = [-direction[0], -direction[1]];\n    const { width, height } = moveable.state;\n    const bounds = moveable.props.bounds;\n    let maxWidth = Infinity;\n    let maxHeight = Infinity;\n\n    if (bounds) {\n        const directions = [\n            [direction[0], -direction[1]],\n            [-direction[0], direction[1]],\n        ];\n        const {\n            left = -Infinity,\n            top = -Infinity,\n            right = Infinity,\n            bottom = Infinity,\n        } = bounds;\n\n        directions.forEach((otherDirection) => {\n            const isCheckVertical = otherDirection[0] !== fixedDirection[0];\n            const isCheckHorizontal = otherDirection[1] !== fixedDirection[1];\n            const otherPos = getPosByDirection(poses, otherDirection);\n            const deg = (getRad(fixedPosition, otherPos) * 360) / Math.PI;\n\n            if (isCheckHorizontal) {\n                const nextOtherPos = otherPos.slice();\n\n                if (Math.abs(deg - 360) < 2 || Math.abs(deg - 180) < 2) {\n                    nextOtherPos[1] = fixedPosition[1];\n                }\n                const {\n                    offset: [, heightOffset],\n                    isOutside: isHeightOutside,\n                } = solveNextOffset(\n                    fixedPosition,\n                    nextOtherPos,\n                    (fixedPosition[1] < otherPos[1] ? bottom : top) -\n                    otherPos[1],\n                    false,\n                    datas\n                );\n                if (!isNaN(heightOffset)) {\n                    maxHeight = height + (isHeightOutside ? 1 : -1) * Math.abs(heightOffset);\n                }\n            }\n            if (isCheckVertical) {\n                const nextOtherPos = otherPos.slice();\n\n                if (Math.abs(deg - 90) < 2 || Math.abs(deg - 270) < 2) {\n                    nextOtherPos[0] = fixedPosition[0];\n                }\n                const {\n                    offset: [widthOffset],\n                    isOutside: isWidthOutside,\n                } = solveNextOffset(\n                    fixedPosition,\n                    nextOtherPos,\n                    (fixedPosition[0] < otherPos[0] ? right : left) - otherPos[0],\n                    true,\n                    datas\n                );\n                if (!isNaN(widthOffset)) {\n                    maxWidth = width + (isWidthOutside ? 1 : -1) * Math.abs(widthOffset);\n                }\n            }\n        });\n    }\n    return {\n        maxWidth,\n        maxHeight,\n    };\n}\n","import { isObject, throttle } from \"@daybrush/utils\";\nimport { diff } from \"@egjs/children-differ\";\nimport { minus } from \"@scena/matrix\";\nimport { getMinMaxs } from \"overlap-area\";\nimport {\n    MoveableManagerInterface, SnappableProps,\n    SnappableState, SnapGuideline, SnapDirectionPoses, PosGuideline, ElementGuidelineValue, SnapElementRect,\n} from \"../../types\";\nimport { getRect, getAbsolutePosesByState, getRefTarget, calculateInversePosition, roundSign } from \"../../utils\";\nimport {\n    splitSnapDirectionPoses, getSnapDirections,\n    HORIZONTAL_NAMES_MAP, VERTICAL_NAMES_MAP, calculateContainerPos,\n} from \"./utils\";\n\nexport function getTotalGuidelines(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n) {\n    const {\n        snapOffset,\n        containerClientRect: {\n            overflow,\n            scrollHeight: containerHeight,\n            scrollWidth: containerWidth,\n            clientHeight: containerClientHeight,\n            clientWidth: containerClientWidth,\n            clientLeft,\n            clientTop,\n        },\n    } = moveable.state;\n    const {\n        snapGap = true,\n        verticalGuidelines,\n        horizontalGuidelines,\n        snapThreshold = 5,\n        snapGridWidth = 0,\n        snapGridHeight = 0,\n        maxSnapElementGuidelineDistance = Infinity,\n    } = moveable.props;\n    const { top, left, bottom, right } = getRect(getAbsolutePosesByState(moveable.state));\n    const targetRect = { top, left, bottom, right, center: (left + right) / 2, middle: (top + bottom) / 2 };\n    const elementGuidelines = getElementGuidelines(moveable);\n    let totalGuidelines: SnapGuideline[] = [...elementGuidelines];\n\n    if (snapGap) {\n        totalGuidelines.push(...getGapGuidelines(\n            moveable, targetRect, snapThreshold,\n        ));\n    }\n    totalGuidelines.push(...getGridGuidelines(\n        snapGridWidth,\n        snapGridHeight,\n        overflow ? containerWidth! : containerClientWidth!,\n        overflow ? containerHeight! : containerClientHeight!,\n        clientLeft,\n        clientTop,\n    ));\n\n    totalGuidelines.push(...getDefaultGuidelines(\n        horizontalGuidelines || false,\n        verticalGuidelines || false,\n        overflow ? containerWidth! : containerClientWidth!,\n        overflow ? containerHeight! : containerClientHeight!,\n        clientLeft,\n        clientTop,\n        snapOffset,\n    ));\n\n    totalGuidelines = totalGuidelines.filter(({ element, elementRect, type }) => {\n        if (!element || !elementRect) {\n            return true;\n        }\n        const rect = elementRect.rect;\n\n        return checkBetweenRects(targetRect, rect, type, maxSnapElementGuidelineDistance);\n    });\n\n    return totalGuidelines;\n}\n\nexport function getGapGuidelines(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    targetRect: SnapDirectionPoses,\n    snapThreshold: number,\n) {\n    const {\n        maxSnapElementGuidelineDistance = Infinity,\n    } = moveable.props;\n    const elementRects = moveable.state.elementRects;\n    const gapGuidelines: SnapGuideline[] = [];\n    [\n        [\"vertical\", VERTICAL_NAMES_MAP, HORIZONTAL_NAMES_MAP] as const,\n        [\"horizontal\", HORIZONTAL_NAMES_MAP, VERTICAL_NAMES_MAP] as const,\n    ].forEach(([type, mainNames, sideNames]) => {\n        const targetStart = targetRect[mainNames.start]!;\n        const targetEnd = targetRect[mainNames.end]!;\n        const targetCenter = targetRect[mainNames.center]!;\n        const targetStart2 = targetRect[sideNames.start]!;\n        const targetEnd2 = targetRect[sideNames.end]!;\n\n        // element : moveable\n        function getDist(elementRect: SnapElementRect) {\n            const rect = elementRect.rect;\n\n            if (rect[mainNames.end]! < targetStart + snapThreshold) {\n                return targetStart - rect[mainNames.end]!;\n            } else if (targetEnd - snapThreshold < rect[mainNames.start]!) {\n                return rect[mainNames.start]! - targetEnd;\n            } else {\n                return -1;\n            }\n        }\n        const nextElementRects = elementRects.filter(elementRect => {\n            const rect = elementRect.rect;\n\n            if (rect[sideNames.start]! > targetEnd2 || rect[sideNames.end]! < targetStart2) {\n                return false;\n            }\n\n            return getDist(elementRect) > 0;\n        }).sort((a, b) => {\n            return getDist(a) - getDist(b);\n        });\n\n        const groups: SnapElementRect[][] = [];\n\n        nextElementRects.forEach(snapRect1 => {\n            nextElementRects.forEach(snapRect2 => {\n                if (snapRect1 === snapRect2) {\n                    return;\n                }\n                const { rect: rect1 } = snapRect1;\n                const { rect: rect2 } = snapRect2;\n\n                const rect1Start = rect1[sideNames.start]!;\n                const rect1End = rect1[sideNames.end]!;\n                const rect2Start = rect2[sideNames.start]!;\n                const rect2End = rect2[sideNames.end]!;\n\n                if (rect1Start > rect2End || rect2Start > rect1End) {\n                    return;\n                }\n\n                groups.push([snapRect1, snapRect2]);\n            });\n        });\n\n        groups.forEach(([snapRect1, snapRect2]) => {\n            const { rect: rect1 } = snapRect1;\n            const { rect: rect2 } = snapRect2;\n\n            const rect1Start = rect1[mainNames.start]!;\n            const rect1End = rect1[mainNames.end]!;\n            const rect2Start = rect2[mainNames.start]!;\n            const rect2End = rect2[mainNames.end]!;\n            let gap = 0;\n            let pos = 0;\n            let isStart = false;\n            let isCenter = false;\n            let isEnd = false;\n\n            if (rect1End <= targetStart && targetEnd <= rect2Start) {\n                // (l)element1(r) : (l)target(r) : (l)element2(r)\n                isCenter = true;\n                gap = ((rect2Start - rect1End) - (targetEnd - targetStart)) / 2;\n                pos = rect1End + gap + (targetEnd - targetStart) / 2;\n\n                if (Math.abs(pos - targetCenter) > snapThreshold) {\n                    return;\n                }\n            } else if (rect1End < rect2Start && rect2End < targetStart + snapThreshold) {\n                // (l)element1(r) : (l)element2(r) : (l)target\n                isStart = true;\n\n                gap = rect2Start - rect1End;\n                pos = rect2End + gap;\n\n                if (Math.abs(pos - targetStart) > snapThreshold) {\n                    return;\n                }\n            } else if (rect1End < rect2Start && targetEnd - snapThreshold < rect1Start) {\n                // target(r) : (l)element1(r) : (l)element2(r)\n\n                isEnd = true;\n                gap = rect2Start - rect1End;\n                pos = rect1Start - gap;\n\n                if (Math.abs(pos - targetEnd) > snapThreshold) {\n                    return;\n                }\n            } else {\n                return;\n            }\n            if (!gap) {\n                return;\n            }\n            if (!checkBetweenRects(targetRect, rect2, type, maxSnapElementGuidelineDistance)) {\n                return;\n            }\n            gapGuidelines.push({\n                type,\n                pos: type === \"vertical\" ? [pos, 0] : [0, pos],\n                element: snapRect2.element,\n                size: 0,\n                className: snapRect2.className,\n                isStart,\n                isCenter,\n                isEnd,\n                gap,\n                hide: true,\n                gapRects: [snapRect1, snapRect2],\n            });\n        });\n    });\n    return gapGuidelines;\n}\nexport function getGridGuidelines(\n    snapGridWidth: number,\n    snapGridHeight: number,\n    containerWidth: number,\n    containerHeight: number,\n    clientLeft = 0,\n    clientTop = 0,\n): SnapGuideline[] {\n    const guidelines: SnapGuideline[] = [];\n\n    if (snapGridHeight) {\n        for (let pos = 0; pos <= containerHeight; pos += snapGridHeight) {\n            guidelines.push({\n                type: \"horizontal\",\n                pos: [0, throttle(pos - clientTop, 0.1)],\n                size: containerWidth!,\n                hide: true,\n            });\n        }\n    }\n    if (snapGridWidth) {\n        for (let pos = 0; pos <= containerWidth; pos += snapGridWidth) {\n            guidelines.push({\n                type: \"vertical\",\n                pos: [throttle(pos - clientLeft, 0.1), 0],\n                size: containerHeight!,\n                hide: true,\n            });\n        }\n    }\n    return guidelines;\n}\n\nexport function checkBetweenRects(\n    rect1: SnapDirectionPoses,\n    rect2: SnapDirectionPoses,\n    type: \"horizontal\" | \"vertical\",\n    distance: number,\n) {\n    if (type === \"horizontal\") {\n        return Math.abs(rect1.right! - rect2.left!) <= distance\n            || Math.abs(rect1.left! - rect2.right!) <= distance\n            || rect1.left! <= rect2.right! && rect2.left! <= rect1.right!;\n    } else if (type === \"vertical\") {\n        return Math.abs(rect1.bottom! - rect2.top!) <= distance\n            || Math.abs(rect1.top! - rect2.bottom!) <= distance\n            || rect1.top! <= rect2.bottom! && rect2.top! <= rect1.bottom!;\n    }\n    return true;\n}\n\n\nexport function getElementGuidelines(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n) {\n    const state = moveable.state;\n\n    const {\n        elementGuidelines = [],\n    } = moveable.props;\n\n    if (!elementGuidelines.length) {\n        state.elementRects = [];\n        return [];\n    }\n\n    const prevValues = (state.elementRects || []).filter(snapRect => !snapRect.refresh);\n    const nextElementGuidelines = elementGuidelines.map(el => {\n        if (isObject(el) && \"element\" in el) {\n            return {\n                ...el,\n                element: getRefTarget(el.element, true)!,\n            };\n        }\n        return {\n            element: getRefTarget(el, true)!,\n        };\n    }).filter(value => {\n        return value.element;\n    }) as ElementGuidelineValue[];\n\n    const {\n        maintained,\n        added,\n    } = diff(prevValues.map(v => v.element), nextElementGuidelines.map(v => v.element));\n\n\n    const nextValues: SnapElementRect[] = [];\n    maintained.forEach(([prevIndex, nextIndex]) => {\n        nextValues[nextIndex] = prevValues[prevIndex];\n    });\n\n    getSnapElementRects(moveable, added.map(index => nextElementGuidelines[index])).map((rect, i) => {\n        nextValues[added[i]] = rect;\n    });\n\n\n    state.elementRects = nextValues;\n    const elementSnapDirections = getSnapDirections(moveable.props.elementSnapDirections);\n    const nextGuidelines: SnapGuideline[] = [];\n\n    nextValues.forEach(snapRect => {\n        const {\n            element,\n            top: topValue = elementSnapDirections.top,\n            left: leftValue = elementSnapDirections.left,\n            right: rightValue = elementSnapDirections.right,\n            bottom: bottomValue = elementSnapDirections.bottom,\n            center: centerValue = elementSnapDirections.center,\n            middle: middleValue = elementSnapDirections.middle,\n            className,\n            rect,\n        } = snapRect;\n        const {\n            horizontal,\n            vertical,\n        } = splitSnapDirectionPoses({\n            top: topValue,\n            right: rightValue,\n            left: leftValue,\n            bottom: bottomValue,\n            center: centerValue,\n            middle: middleValue,\n        }, rect);\n        const rectTop = rect.top!;\n        const rectLeft = rect.left!;\n        const width = rect.right! - rectLeft;\n        const height = rect.bottom! - rectTop;\n        const sizes = [width, height];\n\n        vertical.forEach(pos => {\n            nextGuidelines.push({\n                type: \"vertical\", element, pos: [\n                    throttle(pos, 0.1),\n                    rectTop,\n                ], size: height,\n                sizes,\n                className,\n                elementRect: snapRect,\n            });\n        });\n        horizontal.forEach(pos => {\n            nextGuidelines.push({\n                type: \"horizontal\", element, pos: [\n                    rectLeft,\n                    throttle(pos, 0.1),\n                ], size: width,\n                sizes,\n                className,\n                elementRect: snapRect,\n            });\n        });\n    });\n\n    return nextGuidelines;\n}\n\n\nexport function getDefaultGuidelines(\n    horizontalGuidelines: Array<PosGuideline | number> | false,\n    verticalGuidelines: Array<PosGuideline | number> | false,\n    width: number,\n    height: number,\n    clientLeft = 0,\n    clientTop = 0,\n    snapOffset = { left: 0, top: 0, right: 0, bottom: 0 },\n): SnapGuideline[] {\n    const guidelines: SnapGuideline[] = [];\n    const {\n        left: snapOffsetLeft,\n        top: snapOffsetTop,\n        bottom: snapOffsetBottom,\n        right: snapOffsetRight,\n    } = snapOffset;\n    const snapWidth = width! + snapOffsetRight - snapOffsetLeft;\n    const snapHeight = height! + snapOffsetBottom - snapOffsetTop;\n\n    horizontalGuidelines && horizontalGuidelines!.forEach(posInfo => {\n        const nextPosInfo = isObject(posInfo) ? posInfo : { pos: posInfo };\n\n        guidelines.push({\n            type: \"horizontal\", pos: [\n                snapOffsetLeft,\n                throttle(nextPosInfo.pos - clientTop + snapOffsetTop, 0.1),\n            ], size: snapWidth,\n            className: nextPosInfo.className,\n        });\n    });\n    verticalGuidelines && verticalGuidelines!.forEach(posInfo => {\n        const nextPosInfo = isObject(posInfo) ? posInfo : { pos: posInfo };\n\n        guidelines.push({\n            type: \"vertical\", pos: [\n                throttle(nextPosInfo.pos - clientLeft + snapOffsetLeft, 0.1),\n                snapOffsetTop,\n            ], size: snapHeight,\n            className: nextPosInfo.className,\n        });\n    });\n    return guidelines;\n}\n\n\n\nexport function getSnapElementRects(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    values: ElementGuidelineValue[],\n): SnapElementRect[] {\n    if (!values.length) {\n        return [];\n    }\n    const state = moveable.state;\n    const {\n        containerClientRect,\n        targetClientRect: {\n            top: clientTop,\n            left: clientLeft,\n        },\n        rootMatrix,\n        is3d,\n    } = state;\n    const n = is3d ? 4 : 3;\n    const [containerLeft, containerTop] = calculateContainerPos(rootMatrix, containerClientRect, n);\n    const poses = getAbsolutePosesByState(state);\n    const {\n        minX: targetLeft,\n        minY: targetTop,\n    } = getMinMaxs(poses);\n    const [distLeft, distTop] = minus([targetLeft, targetTop], calculateInversePosition(rootMatrix, [\n        clientLeft - containerLeft,\n        clientTop - containerTop,\n    ], n)).map(pos => roundSign(pos));\n\n    return values.map(value => {\n        const rect = value.element.getBoundingClientRect();\n        const left = rect.left - containerLeft;\n        const top = rect.top - containerTop;\n        const bottom = top + rect.height;\n        const right = left + rect.width;\n        const [elementLeft, elementTop] = calculateInversePosition(rootMatrix, [left, top], n);\n        const [elementRight, elementBottom] = calculateInversePosition(rootMatrix, [right, bottom], n);\n\n        return {\n            ...value,\n            rect: {\n                left: elementLeft + distLeft,\n                right: elementRight + distLeft,\n                top: elementTop + distTop,\n                bottom: elementBottom + distTop,\n                center: (elementLeft + elementRight) / 2 + distLeft,\n                middle: (elementTop + elementBottom) / 2 + distTop,\n            },\n        };\n    });\n}\n\n","import {\n    Renderer,\n    SnappableProps,\n    SnappableState,\n    SnapGuideline,\n    SnapInfo,\n    ScalableProps,\n    SnapPosInfo,\n    RotatableProps,\n    RectInfo,\n    MoveableManagerInterface,\n    SnappableRenderType,\n    BoundType,\n    MoveableGroupInterface,\n} from \"../types\";\nimport {\n    prefix,\n    calculatePoses,\n    getRect,\n    getAbsolutePosesByState,\n    getAbsolutePoses,\n    getClientRect,\n    getRefTarget,\n    getDragDistByState,\n    triggerEvent,\n    getDirectionCondition,\n} from \"../utils\";\nimport {\n    findIndex, hasClass, throttle,\n} from \"@daybrush/utils\";\nimport {\n    getDragDist,\n    scaleMatrix,\n    getPosByDirection,\n} from \"../gesto/GestoUtils\";\nimport { minus, rotate, plus } from \"@scena/matrix\";\nimport { dragControlCondition as rotatableDragControlCondtion } from \"./Rotatable\";\nimport { FLOAT_POINT_NUM } from \"../consts\";\nimport {\n    getInnerBoundInfo,\n    getCheckInnerBoundLineInfos,\n    checkRotateInnerBounds,\n    checkInnerBoundPoses,\n} from \"./snappable/innerBounds\";\nimport {\n    checkBoundPoses,\n    checkRotateBounds,\n    getBounds,\n} from \"./snappable/bounds\";\nimport {\n    checkSnaps,\n    getSnapInfosByDirection,\n    getNearOffsetInfo,\n    getCheckSnapDirections,\n} from \"./snappable/snap\";\nimport {\n    renderSnapPoses,\n    renderGuidelines,\n    renderDashedGuidelines,\n    renderGapGuidelines,\n} from \"./snappable/render\";\nimport {\n    hasGuidelines,\n} from \"./snappable/utils\";\nimport {\n    checkMaxBounds,\n    checkMoveableSnapBounds,\n    getSnapBoundInfo,\n} from \"./snappable/snapBounds\";\nimport { getTotalGuidelines } from \"./snappable/getTotalGuidelines\";\n\n\nexport interface SnapPoses {\n    vertical: number[];\n    horizontal: number[];\n}\n\nexport function snapStart(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n) {\n    const state = moveable.state;\n\n    if (state.guidelines && state.guidelines.length) {\n        return;\n    }\n    const container = moveable.state.container;\n    const snapContainer = moveable.props.snapContainer || container!;\n\n    const containerClientRect = state.containerClientRect;\n    const snapOffset = {\n        left: 0,\n        top: 0,\n        bottom: 0,\n        right: 0,\n    };\n\n    if (container !== snapContainer) {\n        const snapContainerTarget = getRefTarget(snapContainer, true);\n\n        if (snapContainerTarget) {\n            const snapContainerRect = getClientRect(snapContainerTarget);\n            const offset1 = getDragDistByState(state, [\n                snapContainerRect.left - containerClientRect.left,\n                snapContainerRect.top - containerClientRect.top,\n            ]);\n            const offset2 = getDragDistByState(state, [\n                snapContainerRect.right - containerClientRect.right,\n                snapContainerRect.bottom - containerClientRect.bottom,\n            ]);\n            snapOffset.left = throttle(offset1[0], 0.00001);\n            snapOffset.top = throttle(offset1[1], 0.00001);\n            snapOffset.right = throttle(offset2[0], 0.00001);\n            snapOffset.bottom = throttle(offset2[1], 0.00001);\n        }\n    }\n\n    state.snapOffset = snapOffset;\n    state.guidelines = getTotalGuidelines(moveable);\n    state.enableSnap = true;\n}\n\nfunction getNextFixedPoses(\n    matrix: number[],\n    width: number,\n    height: number,\n    fixedDirection: number[],\n    fixedPos: number[],\n    is3d: boolean\n) {\n    const nextPoses = calculatePoses(matrix, width, height, is3d ? 4 : 3);\n    const nextFixedPos = getPosByDirection(nextPoses, fixedDirection);\n\n    return getAbsolutePoses(nextPoses, minus(fixedPos, nextFixedPos));\n}\n\nexport function normalized(value: number) {\n    return value ? value / Math.abs(value) : 0;\n}\n\n\nexport function getSizeOffsetInfo(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    poses: number[][],\n    direction: number[],\n    keepRatio: boolean,\n    isRequest: boolean,\n    datas: any\n) {\n    const { fixedDirection } = datas;\n    const directions = getCheckSnapDirections(direction, fixedDirection, keepRatio);\n    const innerBoundLineInfos = getCheckInnerBoundLineInfos(moveable, poses, direction, keepRatio);\n    const offsets = [\n        ...getSnapBoundInfo(\n            moveable,\n            poses,\n            directions,\n            keepRatio,\n            isRequest,\n            datas\n        ),\n        ...getInnerBoundInfo(\n            moveable,\n            innerBoundLineInfos,\n            datas\n        ),\n    ];\n    const widthOffsetInfo = getNearOffsetInfo(offsets, 0);\n    const heightOffsetInfo = getNearOffsetInfo(offsets, 1);\n\n    return {\n        width: {\n            isBound: widthOffsetInfo.isBound,\n            offset: widthOffsetInfo.offset[0],\n        },\n        height: {\n            isBound: heightOffsetInfo.isBound,\n            offset: heightOffsetInfo.offset[1],\n        },\n    };\n}\nexport function recheckSizeByTwoDirection(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    poses: number[][],\n    width: number,\n    height: number,\n    maxWidth: number,\n    maxHeight: number,\n    direction: number[],\n    isRequest: boolean,\n    datas: any\n) {\n    const snapPos = getPosByDirection(poses, direction);\n\n    const {\n        horizontal: { offset: horizontalOffset },\n        vertical: { offset: verticalOffset },\n    } = checkMoveableSnapBounds(moveable, isRequest, {\n        vertical: [snapPos[0]],\n        horizontal: [snapPos[1]],\n    });\n\n    if (verticalOffset || horizontalOffset) {\n        const [nextWidthOffset, nextHeightOffset] = getDragDist({\n            datas,\n            distX: -verticalOffset,\n            distY: -horizontalOffset,\n        });\n        const nextWidth = Math.min(\n            maxWidth || Infinity,\n            width + direction[0] * nextWidthOffset\n        );\n        const nextHeight = Math.min(\n            maxHeight || Infinity,\n            height + direction[1] * nextHeightOffset\n        );\n\n        return [nextWidth - width, nextHeight - height];\n    }\n    return [0, 0];\n}\nexport function checkSizeDist(\n    moveable: MoveableManagerInterface<any, any>,\n    getNextPoses: (widthOffset: number, heightOffset: number) => number[][],\n    width: number,\n    height: number,\n    direction: number[],\n    fixedPosition: number[],\n    isRequest: boolean,\n    datas: any\n) {\n    const poses = getAbsolutePosesByState(moveable.state);\n    const keepRatio = moveable.props.keepRatio;\n\n    let widthOffset = 0;\n    let heightOffset = 0;\n\n    for (let i = 0; i < 2; ++i) {\n        const nextPoses = getNextPoses(widthOffset, heightOffset);\n        const {\n            width: widthOffsetInfo,\n            height: heightOffsetInfo,\n        } = getSizeOffsetInfo(\n            moveable,\n            nextPoses,\n            direction,\n            keepRatio,\n            isRequest,\n            datas\n        );\n\n        const isWidthBound = widthOffsetInfo.isBound;\n        const isHeightBound = heightOffsetInfo.isBound;\n        let nextWidthOffset = widthOffsetInfo.offset;\n        let nextHeightOffset = heightOffsetInfo.offset;\n\n        if (i === 1) {\n            if (!isWidthBound) {\n                nextWidthOffset = 0;\n            }\n            if (!isHeightBound) {\n                nextHeightOffset = 0;\n            }\n        }\n        if (i === 0 && isRequest && !isWidthBound && !isHeightBound) {\n            return [0, 0];\n        }\n        if (keepRatio) {\n            const widthDist =\n                Math.abs(nextWidthOffset) * (width ? 1 / width : 1);\n            const heightDist =\n                Math.abs(nextHeightOffset) * (height ? 1 / height : 1);\n            const isGetWidthOffset =\n                isWidthBound && isHeightBound\n                    ? widthDist < heightDist\n                    : isHeightBound ||\n                    (!isWidthBound && widthDist < heightDist);\n            if (isGetWidthOffset) {\n                // width : height = ? : heightOffset\n                nextWidthOffset = (width * nextHeightOffset) / height;\n            } else {\n                // width : height = widthOffset : ?\n                nextHeightOffset = (height * nextWidthOffset) / width;\n            }\n        }\n        widthOffset += nextWidthOffset;\n        heightOffset += nextHeightOffset;\n    }\n\n    if (direction[0] && direction[1]) {\n        const { maxWidth, maxHeight } = checkMaxBounds(\n            moveable,\n            poses,\n            direction,\n            fixedPosition,\n            datas\n        );\n\n        const [nextWidthOffset, nextHeightOffset] = recheckSizeByTwoDirection(\n            moveable,\n            getNextPoses(widthOffset, heightOffset).map(pos => pos.map(p => throttle(p, FLOAT_POINT_NUM))),\n            width + widthOffset,\n            height + heightOffset,\n            maxWidth,\n            maxHeight,\n            direction,\n            isRequest,\n            datas\n        );\n        widthOffset += nextWidthOffset;\n        heightOffset += nextHeightOffset;\n    }\n\n    return [widthOffset, heightOffset];\n}\n\nexport function checkSnapRotate(\n    moveable: MoveableManagerInterface<SnappableProps & RotatableProps, any>,\n    rect: RectInfo,\n    origin: number[],\n    rotation: number\n) {\n    if (!hasGuidelines(moveable, \"rotatable\")) {\n        return rotation;\n    }\n\n    const { pos1, pos2, pos3, pos4 } = rect;\n    const rad = (rotation * Math.PI) / 180;\n    const prevPoses = [pos1, pos2, pos3, pos4].map((pos) => minus(pos, origin));\n    const nextPoses = prevPoses.map((pos) => rotate(pos, rad));\n\n    const result = [\n        ...checkRotateBounds(moveable, prevPoses, nextPoses, origin, rotation),\n        ...checkRotateInnerBounds(\n            moveable,\n            prevPoses,\n            nextPoses,\n            origin,\n            rotation\n        ),\n    ];\n    result.sort((a, b) => Math.abs(a - rotation) - Math.abs(b - rotation));\n\n    if (result.length) {\n        return result[0];\n    } else {\n        return rotation;\n    }\n}\nexport function checkSnapResize(\n    moveable: MoveableManagerInterface<{}, {}>,\n    width: number,\n    height: number,\n    direction: number[],\n    fixedPosition: number[],\n    isRequest: boolean,\n    datas: any\n) {\n    if (!hasGuidelines(moveable, \"resizable\")) {\n        return [0, 0];\n    }\n    const { fixedDirection, nextAllMatrix } = datas;\n    const { allMatrix, is3d } = moveable.state;\n\n    return checkSizeDist(\n        moveable,\n        (widthOffset: number, heightOffset: number) => {\n            return getNextFixedPoses(\n                nextAllMatrix || allMatrix,\n                width + widthOffset,\n                height + heightOffset,\n                fixedDirection,\n                fixedPosition,\n                is3d\n            );\n        },\n        width,\n        height,\n        direction,\n        fixedPosition,\n        isRequest,\n        datas\n    );\n}\nexport function checkSnapScale(\n    moveable: MoveableManagerInterface<ScalableProps, any>,\n    scale: number[],\n    direction: number[],\n    isRequest: boolean,\n    datas: any\n) {\n    if (!hasGuidelines(moveable, \"scalable\")) {\n        return [0, 0];\n    }\n    const { startOffsetWidth, startOffsetHeight, fixedPosition, fixedDirection, is3d } = datas;\n    const sizeDist = checkSizeDist(\n        moveable,\n        (widthOffset: number, heightOffset: number) => {\n            return getNextFixedPoses(\n                scaleMatrix(\n                    datas,\n                    plus(scale, [widthOffset / startOffsetWidth, heightOffset / startOffsetHeight]),\n                ),\n                startOffsetWidth,\n                startOffsetHeight,\n                fixedDirection,\n                fixedPosition,\n                is3d\n            );\n        },\n        startOffsetWidth,\n        startOffsetHeight,\n        direction,\n        fixedPosition,\n        isRequest,\n        datas\n    );\n    return [sizeDist[0] / startOffsetWidth, sizeDist[1] / startOffsetHeight];\n}\n\nexport function startCheckSnapDrag(\n    moveable: MoveableManagerInterface<any, any>,\n    datas: any\n) {\n    datas.absolutePoses = getAbsolutePosesByState(moveable.state);\n}\n\n\n\nfunction getSnapGuidelines(posInfos: SnapPosInfo[]) {\n    const guidelines: SnapGuideline[] = [];\n\n    posInfos.forEach((posInfo) => {\n        posInfo.guidelineInfos.forEach(({ guideline }) => {\n            if (guidelines.indexOf(guideline) > -1) {\n                return;\n            }\n            guidelines.push(guideline);\n        });\n    });\n\n    return guidelines;\n}\n\nfunction addBoundGuidelines(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    verticalPoses: number[],\n    horizontalPoses: number[],\n    verticalSnapPoses: SnappableRenderType[],\n    horizontalSnapPoses: SnappableRenderType[],\n    externalBounds?: BoundType | false | null\n) {\n    const {\n        vertical: verticalBoundInfos,\n        horizontal: horizontalBoundInfos,\n    } = checkBoundPoses(\n        getBounds(moveable, externalBounds),\n        verticalPoses,\n        horizontalPoses\n    );\n    verticalBoundInfos.forEach((info) => {\n        if (info.isBound) {\n            verticalSnapPoses.push({\n                type: \"bounds\",\n                pos: info.pos,\n            });\n        }\n    });\n    horizontalBoundInfos.forEach((info) => {\n        if (info.isBound) {\n            horizontalSnapPoses.push({\n                type: \"bounds\",\n                pos: info.pos,\n            });\n        }\n    });\n    const {\n        vertical: verticalInnerBoundPoses,\n        horizontal: horizontalInnerBoundPoses,\n    } = checkInnerBoundPoses(moveable);\n\n    verticalInnerBoundPoses.forEach((innerPos) => {\n        if (\n            findIndex(\n                verticalSnapPoses,\n                ({ type, pos }) => type === \"bounds\" && pos === innerPos\n            ) >= 0\n        ) {\n            return;\n        }\n        verticalSnapPoses.push({\n            type: \"bounds\",\n            pos: innerPos,\n        });\n    });\n\n    horizontalInnerBoundPoses.forEach((innerPos) => {\n        if (\n            findIndex(\n                horizontalSnapPoses,\n                ({ type, pos }) => type === \"bounds\" && pos === innerPos\n            ) >= 0\n        ) {\n            return;\n        }\n        horizontalSnapPoses.push({\n            type: \"bounds\",\n            pos: innerPos,\n        });\n    });\n}\n\nconst directionCondition = getDirectionCondition(\"\", [\"resizable\", \"scalable\"]);\n\n/**\n * @namespace Moveable.Snappable\n * @description Whether or not target can be snapped to the guideline. (default: false)\n * @sort 2\n */\nexport default {\n    name: \"snappable\",\n    dragRelation: \"strong\",\n    props: {\n        snappable: [Boolean, Array],\n        snapContainer: Object,\n\n        snapDirections: [Boolean, Object],\n        elementSnapDirections: [Boolean, Object],\n\n        snapGap: Boolean,\n        snapGridWidth: Number,\n        snapGridHeight: Number,\n        isDisplaySnapDigit: Boolean,\n        isDisplayInnerSnapDigit: Boolean,\n        snapDigit: Number,\n        snapThreshold: Number,\n\n        horizontalGuidelines: Array,\n        verticalGuidelines: Array,\n        elementGuidelines: Array,\n\n        bounds: Object,\n        innerBounds: Object,\n        snapDistFormat: Function,\n    } as const,\n    events: {\n        onSnap: \"snap\",\n    } as const,\n    css: [\n        `:host {\n    --bounds-color: #d66;\n}\n.guideline {\n    pointer-events: none;\n    z-index: 2;\n}\n.guideline.bounds {\n    background: #d66;\n    background: var(--bounds-color);\n}\n.guideline-group {\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.guideline-group .size-value {\n    position: absolute;\n    color: #f55;\n    font-size: 12px;\n    font-weight: bold;\n}\n.guideline-group.horizontal .size-value {\n    transform-origin: 50% 100%;\n    transform: translateX(-50%);\n    left: 50%;\n    bottom: 5px;\n}\n.guideline-group.vertical .size-value {\n    transform-origin: 0% 50%;\n    top: 50%;\n    transform: translateY(-50%);\n    left: 5px;\n}\n.guideline.gap {\n    background: #f55;\n}\n.size-value.gap {\n    color: #f55;\n}\n`,\n    ],\n    render(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n        React: Renderer\n    ): any[] {\n        const state = moveable.state;\n        const {\n            top: targetTop,\n            left: targetLeft,\n            pos1,\n            pos2,\n            pos3,\n            pos4,\n            snapRenderInfo,\n        } = state;\n\n        if (!snapRenderInfo || !hasGuidelines(moveable, \"\")) {\n            return [];\n        }\n        state.guidelines = getTotalGuidelines(moveable);\n\n\n        const minLeft = Math.min(pos1[0], pos2[0], pos3[0], pos4[0]);\n        const minTop = Math.min(pos1[1], pos2[1], pos3[1], pos4[1]);\n        const externalPoses = snapRenderInfo.externalPoses || [];\n        const poses = getAbsolutePosesByState(moveable.state);\n        const verticalSnapPoses: SnappableRenderType[] = [];\n        const horizontalSnapPoses: SnappableRenderType[] = [];\n        const verticalGuidelines: SnapGuideline[] = [];\n        const horizontalGuidelines: SnapGuideline[] = [];\n        const snapInfos: Array<{\n            vertical: SnapInfo;\n            horizontal: SnapInfo;\n        }> = [];\n        const { width, height, top, left, bottom, right } = getRect(poses);\n        const targetRect = { left, right, top, bottom, center: (left + right) / 2, middle: (top + bottom) / 2 };\n        const hasExternalPoses = externalPoses.length > 0;\n        const externalRect = hasExternalPoses\n            ? getRect(externalPoses)\n            : ({} as ReturnType<typeof getRect>);\n\n        if (!snapRenderInfo.request) {\n            if (snapRenderInfo.direction) {\n                snapInfos.push(\n                    getSnapInfosByDirection(\n                        moveable,\n                        poses,\n                        snapRenderInfo.direction\n                    )\n                );\n            }\n            if (snapRenderInfo.snap) {\n                const rect = getRect(poses);\n                if (snapRenderInfo.center) {\n                    (rect as any).middle = (rect.top + rect.bottom) / 2;\n                    (rect as any).center = (rect.left + rect.right) / 2;\n                }\n                snapInfos.push(checkSnaps(moveable, rect, 1));\n            }\n            if (hasExternalPoses) {\n                if (snapRenderInfo.center) {\n                    (externalRect as any).middle =\n                        (externalRect.top + externalRect.bottom) / 2;\n                    (externalRect as any).center =\n                        (externalRect.left + externalRect.right) / 2;\n                }\n                snapInfos.push(checkSnaps(moveable, externalRect, 1));\n            }\n            snapInfos.forEach((snapInfo) => {\n                const {\n                    vertical: { posInfos: verticalPosInfos },\n                    horizontal: { posInfos: horizontalPosInfos },\n                } = snapInfo;\n                verticalSnapPoses.push(\n                    ...verticalPosInfos.filter(({ guidelineInfos }) => {\n                        return guidelineInfos.some(({ guideline }) => !guideline.hide);\n                    }).map(\n                        (posInfo) => ({\n                            type: \"snap\",\n                            pos: posInfo.pos,\n                        } as const)\n                    )\n                );\n                horizontalSnapPoses.push(\n                    ...horizontalPosInfos.filter(({ guidelineInfos }) => {\n                        return guidelineInfos.some(({ guideline }) => !guideline.hide);\n                    }).map(\n                        (posInfo) => ({\n                            type: \"snap\",\n                            pos: posInfo.pos,\n                        } as const)\n                    )\n                );\n                verticalGuidelines.push(...getSnapGuidelines(verticalPosInfos));\n                horizontalGuidelines.push(...getSnapGuidelines(horizontalPosInfos));\n            });\n        }\n\n        addBoundGuidelines(\n            moveable,\n            [left, right],\n            [top, bottom],\n            verticalSnapPoses,\n            horizontalSnapPoses\n        );\n        if (hasExternalPoses) {\n            addBoundGuidelines(\n                moveable,\n                [externalRect.left, externalRect.right],\n                [externalRect.top, externalRect.bottom],\n                verticalSnapPoses,\n                horizontalSnapPoses,\n                snapRenderInfo.externalBounds\n            );\n        }\n        const allGuidelines = [...verticalGuidelines, ...horizontalGuidelines];\n        const elementGuidelines = allGuidelines.filter(guideline => guideline.element && !guideline.gapRects);\n        const gapGuidelines = allGuidelines.filter(guideline => guideline.gapRects);\n        triggerEvent(\n            moveable,\n            \"onSnap\",\n            {\n                guidelines: allGuidelines.filter(({ element }) => !element),\n                elements: elementGuidelines,\n                gaps: gapGuidelines,\n            },\n            true\n        );\n        return [\n            ...renderDashedGuidelines(\n                moveable,\n                elementGuidelines,\n                [minLeft, minTop],\n                targetRect,\n                React,\n            ),\n            ...renderGapGuidelines(\n                moveable,\n                gapGuidelines,\n                [minLeft, minTop],\n                targetRect,\n                React,\n            ),\n            ...renderGuidelines(\n                moveable,\n                \"horizontal\",\n                horizontalGuidelines,\n                [targetLeft, targetTop],\n                targetRect,\n                React\n            ),\n            ...renderGuidelines(\n                moveable,\n                \"vertical\",\n                verticalGuidelines,\n                [targetLeft, targetTop],\n                targetRect,\n                React\n            ),\n            ...renderSnapPoses(\n                moveable,\n                \"horizontal\",\n                horizontalSnapPoses,\n                minLeft,\n                targetTop,\n                width,\n                0,\n                React\n            ),\n            ...renderSnapPoses(\n                moveable,\n                \"vertical\",\n                verticalSnapPoses,\n                minTop,\n                targetLeft,\n                height,\n                1,\n                React\n            ),\n        ];\n    },\n    dragStart(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n        e: any\n    ) {\n        moveable.state.snapRenderInfo = {\n            request: e.isRequest,\n            snap: true,\n            center: true,\n        };\n        snapStart(moveable);\n    },\n    drag(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n    ) {\n        const state = moveable.state;\n        state.guidelines = getTotalGuidelines(moveable);\n    },\n    pinchStart(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n    ) {\n        this.unset(moveable);\n    },\n    dragEnd(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n    ) {\n        this.unset(moveable);\n    },\n    dragControlCondition(moveable: MoveableManagerInterface, e: any) {\n        if (directionCondition(moveable, e) || rotatableDragControlCondtion(moveable, e)) {\n            return true;\n        }\n        if (!e.isRequest && e.inputEvent) {\n            return hasClass(e.inputEvent.target, prefix(\"snap-control\"));\n        }\n    },\n    dragControlStart(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n    ) {\n        moveable.state.snapRenderInfo = null;\n        snapStart(moveable);\n    },\n    dragControl(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n    ) {\n        this.drag(moveable);\n    },\n    dragControlEnd(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n    ) {\n        this.unset(moveable);\n    },\n    dragGroupStart(moveable: any, e: any) {\n        this.dragStart(moveable, e);\n    },\n    dragGroup(\n        moveable: MoveableGroupInterface<SnappableProps, SnappableState>\n    ) {\n        this.drag(moveable);\n    },\n    dragGroupEnd(\n        moveable: MoveableGroupInterface<SnappableProps, SnappableState>\n    ) {\n        this.unset(moveable);\n    },\n    dragGroupControlStart(\n        moveable: MoveableGroupInterface<SnappableProps, SnappableState>\n    ) {\n        moveable.state.snapRenderInfo = null;\n        snapStart(moveable);\n    },\n    dragGroupControl(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n    ) {\n        this.drag(moveable);\n    },\n    dragGroupControlEnd(\n        moveable: MoveableGroupInterface<SnappableProps, SnappableState>\n    ) {\n        this.unset(moveable);\n    },\n    unset(moveable: any) {\n        const state = moveable.state;\n\n        state.enableSnap = false;\n        state.guidelines = [];\n        state.snapRenderInfo = null;\n        state.elementRects = [];\n    },\n};\n\n\n/**\n * Whether or not target can be snapped to the guideline. (default: false)\n * @name Moveable.Snappable#snappable\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snappable = true;\n */\n/**\n *  A snap container that is the basis for snap, bounds, and innerBounds. (default: null = container)\n * @name Moveable.Snappable#snapContainer\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.querySelector(\".container\"));\n *\n * moveable.snapContainer = document.body;\n */\n/**\n * You can specify the directions to snap to the target. (default: { left: true, top: true, right: true, bottom: true })\n * @name Moveable.Snappable#snapDirections\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   snappable: true,\n *   snapDirections: true,\n * });\n * // snap center\n * moveable.snapDirections = { left: true, top: true, right: true, bottom: true, center: true, middle: true };\n */\n\n/**\n * You can specify the snap directions of elements. (default: { left: true, top: true, right: true, bottom: true })\n * @name Moveable.Snappable#elementSnapDirections\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   snappable: true,\n *   elementSnapDirections: true,\n * });\n * // snap center\n * moveable.elementSnapDirections = { left: true, top: true, right: true, bottom: true, center: true, middle: true };\n */\n/**\n * When you drag, make the gap snap in the element guidelines. (default: true)\n * @name Moveable.Snappable#snapGap\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   snappable: true,\n *   snapElement: true,\n *   snapGap: true,\n * });\n *\n * moveable.snapGap = false;\n */\n/**\n * Distance value that can snap to guidelines. (default: 5)\n * @name Moveable.Snappable#snapThreshold\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snapThreshold = 5;\n */\n\n/**\n * Add guidelines in the horizontal direction. (default: [])\n * @name Moveable.Snappable#horizontalGuidelines\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.horizontalGuidelines = [100, 200, 500];\n */\n\n/**\n * Add guidelines in the vertical direction. (default: [])\n * @name Moveable.Snappable#verticalGuidelines\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.verticalGuidelines = [100, 200, 500];\n */\n/**\n * Add guidelines for the element. (default: [])\n * @name Moveable.Snappable#elementGuidelines\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.elementGuidelines = [\n *   document.querySelector(\".element\"),\n * ];\n */\n/**\n * You can set up boundaries.\n * @name Moveable.Snappable#bounds\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @default null\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.bounds = { left: 0, right: 1000, top: 0, bottom: 1000};\n */\n/**\n * You can set up inner boundaries.\n * @name Moveable.Snappable#innerBounds\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @default null\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.innerBounds = { left: 500, top: 500, width: 100, height: 100};\n */\n/**\n * snap distance digits (default: 0)\n * @name Moveable.Snappable#snapDigit\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snapDigit = 0\n */\n\n/**\n * If width size is greater than 0, you can vertical snap to the grid. (default: 0)\n * @name Moveable.Snappable#snapGridWidth\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snapGridWidth = 5;\n */\n\n/**\n * If height size is greater than 0, you can horizontal snap to the grid. (default: 0)\n * @name Moveable.Snappable#snapGridHeight\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snapGridHeight = 5;\n */\n/**\n * Whether to show snap distance (default: true)\n * @name Moveable.Snappable#isDisplaySnapDigit\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.isDisplaySnapDigit = true;\n */\n\n/**\n * Whether to show element inner snap distance (default: false)\n * @name Moveable.Snappable#isDisplayInnerSnapDigit\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.isDisplayInnerSnapDigit = true;\n */\n\n\n/**\n * You can set the text format of the distance shown in the guidelines. (default: self)\n * @name Moveable.Snappable#snapDistFormat\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  snappable: true,\n *  snapDistFormat: (v, type) => v,\n * });\n * moveable.snapDistFormat = (v, type) => `${v}px`;\n */\n\n/**\n * When you drag or dragControl, the `snap` event is called.\n * @memberof Moveable.Snappable\n * @event snap\n * @param {Moveable.Snappable.OnSnap} - Parameters for the `snap` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     snappable: true\n * });\n * moveable.on(\"snap\", e => {\n *     console.log(\"onSnap\", e);\n * });\n */\n","import { prefix, getControlTransform, getLineStyle, getProps } from \"./utils\";\nimport {\n    Renderer, MoveableManagerInterface,\n    RenderDirections,\n} from \"./types\";\nimport { DIRECTION_INDEXES, DIRECTION_ROTATIONS, DIRECTIONS, DIRECTIONS4 } from \"./consts\";\nimport { IObject, throttle, getRad, getKeys } from \"@daybrush/utils\";\n\nexport interface DirectionControlInfo {\n    data: Record<string, any>;\n    classNames: string[];\n    dir: string;\n}\nexport function renderDirectionControlsByInfos(\n    moveable: MoveableManagerInterface<Partial<RenderDirections>>,\n    ableName: string,\n    renderDirections: DirectionControlInfo[],\n    React: Renderer,\n): any[] {\n\n    const {\n        renderPoses,\n        rotation: rotationRad,\n        direction,\n    } = moveable.state;\n    const {\n        zoom,\n    } = getProps(moveable.props, ableName as any);\n\n\n    const sign = (direction > 0 ? 1 : -1);\n    const degRotation = rotationRad / Math.PI * 180;\n    const directionMap: IObject<boolean> = {};\n\n    const renderState = moveable.renderState;\n    if (!renderState.renderDirectionMap) {\n        renderState.renderDirectionMap = {};\n    }\n    const renderDirectionMap = renderState.renderDirectionMap;\n\n    renderDirections.forEach(({ dir }) => {\n        directionMap[dir] = true;\n    });\n\n    return renderDirections.map(({ data, classNames, dir }) => {\n        const indexes = DIRECTION_INDEXES[dir];\n\n        if (!indexes || !directionMap[dir]) {\n            return null;\n        }\n        renderDirectionMap[dir] = true;\n        const directionRotation = (throttle(degRotation, 15) + sign * DIRECTION_ROTATIONS[dir] + 720) % 180;\n\n        const dataAttrs: Record<string, string> = {};\n\n        getKeys(data).forEach(name => {\n            dataAttrs[`data-${name}`] = data[name];\n        });\n        return (\n            <div className={prefix(\"control\", \"direction\", dir, ableName, ...classNames)}\n                data-rotation={directionRotation}\n                data-direction={dir}\n                {...dataAttrs}\n                key={`direction-${dir}`}\n                style={getControlTransform(rotationRad, zoom!, ...indexes.map(index => renderPoses[index]))}></div>\n        );\n    });\n}\nexport function renderDirectionControls(\n    moveable: MoveableManagerInterface<Partial<RenderDirections>>,\n    defaultDirections: string[],\n    ableName: string,\n    React: Renderer,\n): any[] {\n    const {\n        renderDirections: directions = defaultDirections,\n    } = getProps(moveable.props, ableName as any);\n\n    if (!directions) {\n        return [];\n    }\n    const renderDirections = directions === true ? DIRECTIONS : directions;\n\n    return renderDirectionControlsByInfos(\n        moveable,\n        ableName,\n        renderDirections.map(dir => {\n            return {\n                data: {},\n                classNames: [],\n                dir,\n            };\n        }),\n        React,\n    );\n}\nexport function renderAroundControls(\n    moveable: MoveableManagerInterface<Partial<RenderDirections>>,\n    React: Renderer,\n): any[] {\n    const renderState = moveable.renderState;\n    if (!renderState.renderDirectionMap) {\n        renderState.renderDirectionMap = {};\n    }\n    const {\n        renderPoses,\n        rotation: rotationRad,\n        direction,\n    } = moveable.state;\n\n    const renderDirectionMap = renderState.renderDirectionMap;\n\n    const {\n        zoom,\n    } = moveable.props;\n    const sign = (direction > 0 ? 1 : -1);\n    const degRotation = rotationRad / Math.PI * 180;\n\n    return getKeys(renderDirectionMap).map(dir => {\n        const indexes = DIRECTION_INDEXES[dir];\n\n        if (!indexes) {\n            return null;\n        }\n        const directionRotation = (throttle(degRotation, 15) + sign * DIRECTION_ROTATIONS[dir] + 720) % 180;\n\n        return (\n            <div className={prefix(\"around-control\")} data-rotation={directionRotation} data-direction={dir} key={`direction-around-${dir}`}\n                style={getControlTransform(rotationRad, zoom!, ...indexes.map(index => renderPoses[index]))}></div>\n        );\n    });\n}\n\nexport function renderLine(\n    React: Renderer,\n    direction: string,\n    pos1: number[],\n    pos2: number[],\n    zoom: number,\n    key: number | string,\n    ...classNames: string[]\n): any {\n    const rad = getRad(pos1, pos2);\n    const rotation = direction ? (throttle(rad / Math.PI * 180, 15)) % 180 : -1;\n\n    return <div key={`line${key}`}\n        className={prefix(\"line\", \"direction\", direction ? \"edge\" : \"\", direction, ...classNames)}\n        data-rotation={rotation}\n        data-line-index={key}\n        data-direction={direction} style={getLineStyle(pos1, pos2, zoom, rad)}></div>;\n}\n\nexport function renderEdgeLines(\n    React: Renderer,\n    ableName: string,\n    edge: true | string[],\n    poses: number[][],\n    zoom: number,\n): any[] {\n    const directions = edge === true ? DIRECTIONS4 : edge;\n\n    return directions.map((direction, i) => {\n        const [index1, index2] = DIRECTION_INDEXES[direction];\n\n        if (index2 == null) {\n            return;\n        }\n        return renderLine(React, direction, poses[index1], poses[index2], zoom, `${ableName}Edge${i}`, ableName);\n    }).filter(Boolean);\n}\nexport function getRenderDirections(ableName: string) {\n    return (\n        moveable: MoveableManagerInterface<Partial<RenderDirections>>,\n        React: Renderer,\n    ) => {\n        const edge = getProps(moveable.props, ableName as any).edge;\n\n        if (edge && (edge === true || edge.length)) {\n            return [\n                ...renderEdgeLines(\n                    React,\n                    ableName,\n                    edge,\n                    moveable.state.renderPoses,\n                    moveable.props.zoom!,\n                ),\n                ...renderDiagonalDirections(moveable, ableName, React),\n            ];\n        }\n        return renderAllDirections(moveable, ableName, React);\n    };\n}\nexport function renderAllDirections(\n    moveable: MoveableManagerInterface<Partial<RenderDirections>>,\n    ableName: string,\n    React: Renderer,\n) {\n    return renderDirectionControls(moveable, DIRECTIONS, ableName, React);\n}\nexport function renderDiagonalDirections(\n    moveable: MoveableManagerInterface<Partial<RenderDirections>>,\n    ableName: string,\n    React: Renderer,\n): any[] {\n    return renderDirectionControls(moveable, [\"nw\", \"ne\", \"sw\", \"se\"], ableName, React);\n}\n","import {\n    setDragStart, getBeforeDragDist, getTransformDist,\n    convertTransformFormat, resolveTransformEvent, fillTransformStartEvent,\n    setDefaultTransformIndex, fillOriginalTransform,\n} from \"../gesto/GestoUtils\";\nimport {\n    triggerEvent, fillParams,\n    getDistSize, prefix,\n    fillEndParams, getComputedStyle,\n    fillCSSObject,\n} from \"../utils\";\nimport { minus, plus } from \"@scena/matrix\";\nimport {\n    DraggableProps, OnDrag, OnDragGroup,\n    OnDragGroupStart, OnDragStart, OnDragEnd, DraggableState,\n    Renderer, OnDragGroupEnd, MoveableManagerInterface, MoveableGroupInterface,\n} from \"../types\";\nimport { triggerChildGesto } from \"../groupUtils\";\nimport { startCheckSnapDrag } from \"./Snappable\";\nimport { IObject, getRad, throttle, throttleArray } from \"@daybrush/utils\";\nimport { checkSnapBoundsDrag } from \"./snappable/snapBounds\";\nimport { TINY_NUM } from \"../consts\";\n\n/**\n * @namespace Draggable\n * @memberof Moveable\n * @description Draggable refers to the ability to drag and move targets.\n */\nexport default {\n    name: \"draggable\",\n    props: {\n        draggable: Boolean,\n        throttleDrag: Number,\n        throttleDragRotate: Number,\n        startDragRotate: Number,\n        edgeDraggable: Boolean,\n    } as const,\n    events: {\n        onDragStart: \"dragStart\",\n        onDrag: \"drag\",\n        onDragEnd: \"dragEnd\",\n        onDragGroupStart: \"dragGroupStart\",\n        onDragGroup: \"dragGroup\",\n        onDragGroupEnd: \"dragGroupEnd\",\n    } as const,\n    render(\n        moveable: MoveableManagerInterface<DraggableProps, DraggableState>,\n        React: Renderer,\n    ): any[] {\n        const { throttleDragRotate, zoom } = moveable.props;\n        const { dragInfo, beforeOrigin } = moveable.state;\n\n        if (!throttleDragRotate || !dragInfo) {\n            return [];\n        }\n        const dist = dragInfo.dist;\n\n        if (!dist[0] && !dist[1]) {\n            return [];\n        }\n\n        const width = getDistSize(dist);\n        const rad = getRad(dist, [0, 0]);\n\n        return [<div className={prefix(\n            \"line\",\n            \"horizontal\",\n            \"dragline\",\n            \"dashed\",\n        )} key={`dragRotateGuideline`} style={{\n            width: `${width}px`,\n            transform: `translate(${beforeOrigin[0]}px, ${beforeOrigin[1]}px) rotate(${rad}rad) scaleY(${zoom})`,\n        }} />];\n    },\n    dragStart(\n        moveable: MoveableManagerInterface<DraggableProps, any>,\n        e: any,\n    ) {\n        const { datas, parentEvent, parentGesto } = e;\n        const state = moveable.state;\n        const {\n            target,\n            gestos,\n        } = state;\n\n        if (gestos.draggable) {\n            return false;\n        }\n        gestos.draggable = parentGesto || moveable.targetGesto;\n        const style = getComputedStyle(target!);\n\n        datas.datas = {};\n        datas.left = parseFloat(style.left || \"\") || 0;\n        datas.top = parseFloat(style.top || \"\") || 0;\n        datas.bottom = parseFloat(style.bottom || \"\") || 0;\n        datas.right = parseFloat(style.right || \"\") || 0;\n        datas.startValue = [0, 0];\n\n        setDragStart(moveable, e);\n        setDefaultTransformIndex(e, \"translate\");\n        startCheckSnapDrag(moveable, datas);\n\n        datas.prevDist = [0, 0];\n        datas.prevBeforeDist = [0, 0];\n        datas.isDrag = false;\n        datas.deltaOffset = [0, 0];\n\n        const params = fillParams<OnDragStart>(moveable, e, {\n            set: (translate: number[]) => {\n                datas.startValue = translate;\n            },\n            ...fillTransformStartEvent(e),\n        });\n        const result = parentEvent || triggerEvent(moveable, \"onDragStart\", params);\n\n        if (result !== false) {\n            datas.isDrag = true;\n            moveable.state.dragInfo = {\n                startRect: moveable.getRect(),\n                dist: [0, 0],\n            };\n        } else {\n            gestos.draggable = null;\n            datas.isPinch = false;\n        }\n        return datas.isDrag ? params : false;\n    },\n    drag(\n        moveable: MoveableManagerInterface<DraggableProps, any>,\n        e: any,\n    ): OnDrag | undefined {\n        if (!e) {\n            return;\n        }\n        resolveTransformEvent(e, \"translate\");\n\n        const { datas, parentEvent, parentFlag, isPinch, isRequest, deltaOffset } = e;\n        let { distX, distY } = e;\n        const { isDrag, prevDist, prevBeforeDist, startValue } = datas;\n\n        if (!isDrag) {\n            return;\n        }\n\n        if (deltaOffset) {\n            distX += deltaOffset[0];\n            distY += deltaOffset[1];\n        }\n        const props = moveable.props;\n\n        const parentMoveable = props.parentMoveable;\n        const throttleDrag = parentEvent ? 0 : (props.throttleDrag || 0);\n        const throttleDragRotate = parentEvent ? 0 : (props.throttleDragRotate || 0);\n\n        let isSnap = false;\n        let dragRotateRad = 0;\n\n        if (!parentEvent && throttleDragRotate > 0 && (distX || distY)) {\n            const startDragRotate = props.startDragRotate || 0;\n            const deg\n                = throttle(startDragRotate + getRad([0, 0], [distX, distY]) * 180 / Math.PI, throttleDragRotate)\n                - startDragRotate;\n            const ry = distY * Math.abs(Math.cos((deg - 90) / 180 * Math.PI));\n            const rx = distX * Math.abs(Math.cos(deg / 180 * Math.PI));\n            const r = getDistSize([rx, ry]);\n            dragRotateRad = deg * Math.PI / 180;\n\n            distX = r * Math.cos(dragRotateRad);\n            distY = r * Math.sin(dragRotateRad);\n        }\n\n        if (!isPinch && !parentEvent && !parentFlag && (!throttleDragRotate || distX || distY)) {\n            const [verticalInfo, horizontalInfo] = checkSnapBoundsDrag(\n                moveable, distX, distY, throttleDragRotate, isRequest || deltaOffset, datas,\n            );\n            const {\n                isSnap: isVerticalSnap,\n                isBound: isVerticalBound,\n                offset: verticalOffset,\n            } = verticalInfo;\n            const {\n                isSnap: isHorizontalSnap,\n                isBound: isHorizontalBound,\n                offset: horizontalOffset,\n            } = horizontalInfo;\n\n            isSnap = isVerticalSnap || isHorizontalSnap || isVerticalBound || isHorizontalBound;\n\n            distX += verticalOffset;\n            distY += horizontalOffset;\n        }\n\n        const beforeTranslate = plus(getBeforeDragDist({ datas, distX, distY }), startValue);\n        const translate = plus(getTransformDist({ datas, distX, distY }), startValue);\n\n        if (!throttleDragRotate && !isSnap) {\n            throttleArray(translate, throttleDrag);\n            throttleArray(beforeTranslate, throttleDrag);\n        }\n        throttleArray(translate, TINY_NUM);\n        throttleArray(beforeTranslate, TINY_NUM);\n\n        const beforeDist = minus(beforeTranslate, startValue);\n        const dist = minus(translate, startValue);\n        const delta = minus(dist, prevDist);\n        const beforeDelta = minus(beforeDist, prevBeforeDist);\n\n        datas.prevDist = dist;\n        datas.prevBeforeDist = beforeDist;\n\n\n        datas.passDelta = delta; //distX - (datas.passDistX || 0);\n        // datas.passDeltaY = distY - (datas.passDistY || 0);\n        datas.passDist = dist; //distX;\n        // datas.passDistY = distY;\n\n        const left = datas.left + beforeDist[0];\n        const top = datas.top + beforeDist[1];\n        const right = datas.right - beforeDist[0];\n        const bottom = datas.bottom - beforeDist[1];\n        const nextTransform = convertTransformFormat(datas,\n            `translate(${translate[0]}px, ${translate[1]}px)`, `translate(${dist[0]}px, ${dist[1]}px)`);\n\n        fillOriginalTransform(e, nextTransform);\n\n        moveable.state.dragInfo.dist = parentEvent ? [0, 0] : dist;\n        if (!parentEvent && !parentMoveable && delta.every(num => !num) && beforeDelta.some(num => !num)) {\n            return;\n        }\n\n        const {\n            width,\n            height,\n        } = moveable.state;\n        const params = fillParams<OnDrag>(moveable, e, {\n            transform: nextTransform,\n            dist,\n            delta,\n            translate,\n            beforeDist,\n            beforeDelta,\n            beforeTranslate,\n            left,\n            top,\n            right,\n            bottom,\n            width,\n            height,\n            isPinch,\n            ...fillCSSObject({\n                transform: nextTransform,\n            }, e),\n        });\n\n        !parentEvent && triggerEvent(moveable, \"onDrag\", params);\n        return params;\n    },\n    dragAfter(\n        moveable: MoveableManagerInterface<DraggableProps, DraggableState>,\n        e: any,\n    ) {\n        const datas = e.datas;\n        const {\n            deltaOffset,\n        } = datas;\n\n        if (deltaOffset[0] || deltaOffset[1]) {\n            datas.deltaOffset = [0, 0];\n            return this.drag(moveable, {...e, deltaOffset });\n        }\n        return false;\n    },\n    dragEnd(\n        moveable: MoveableManagerInterface<DraggableProps, DraggableState>,\n        e: any,\n    ) {\n        const { parentEvent, datas } = e;\n\n        moveable.state.dragInfo = null;\n        if (!datas.isDrag) {\n            return;\n        }\n        datas.isDrag = false;\n        const param = fillEndParams<OnDragEnd>(moveable, e, {});\n        !parentEvent && triggerEvent(moveable, \"onDragEnd\", param);\n        return param;\n    },\n    dragGroupStart(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas, clientX, clientY } = e;\n\n        const params = this.dragStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n        const events = triggerChildGesto(moveable, this, \"dragStart\", [\n            clientX || 0,\n            clientY || 0,\n        ], e, false, \"draggable\");\n\n        const nextParams: OnDragGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events,\n        };\n        const result = triggerEvent(moveable, \"onDragGroupStart\", nextParams);\n\n        datas.isDrag = result !== false;\n\n        return datas.isDrag ? params : false;\n    },\n    dragGroup(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas } = e;\n\n        if (!datas.isDrag) {\n            return;\n        }\n        const params = this.drag(moveable, e);\n        const { passDelta } = e.datas;\n        const events = triggerChildGesto(moveable, this, \"drag\", passDelta, e, false, \"draggable\");\n\n        if (!params) {\n            return;\n        }\n        const nextParams: OnDragGroup = {\n            targets: moveable.props.targets!,\n            events,\n            ...params,\n        };\n\n        triggerEvent(moveable, \"onDragGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupEnd(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isDrag) {\n            return;\n        }\n        this.dragEnd(moveable, e);\n        const events = triggerChildGesto(moveable, this, \"dragEnd\", [0, 0], e, false, \"draggable\");\n        triggerEvent(moveable, \"onDragGroupEnd\", fillEndParams<OnDragGroupEnd>(moveable, e, {\n            targets: moveable.props.targets!,\n            events,\n        }));\n\n        return isDrag;\n    },\n    /**\n     * @method Moveable.Draggable#request\n     * @param {object} [e] - the draggable's request parameter\n     * @param {number} [e.x] - x position\n     * @param {number} [e.y] - y position\n     * @param {number} [e.deltaX] - X number to move\n     * @param {number} [e.deltaY] - Y number to move\n     * @return {Moveable.Requester} Moveable Requester\n     * @example\n\n     * // Instantly Request (requestStart - request - requestEnd)\n     * // Use Relative Value\n     * moveable.request(\"draggable\", { deltaX: 10, deltaY: 10 }, true);\n     * // Use Absolute Value\n     * moveable.request(\"draggable\", { x: 200, y: 100 }, true);\n     *\n     * // requestStart\n     * const requester = moveable.request(\"draggable\");\n     *\n     * // request\n     * // Use Relative Value\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * // Use Absolute Value\n     * moveable.request(\"draggable\", { x: 200, y: 100 });\n     * moveable.request(\"draggable\", { x: 220, y: 100 });\n     * moveable.request(\"draggable\", { x: 240, y: 100 });\n     *\n     * // requestEnd\n     * requester.requestEnd();\n     */\n    request(moveable: MoveableManagerInterface<any, any>) {\n        const datas = {};\n        const rect = moveable.getRect();\n        let distX = 0;\n        let distY = 0;\n\n        return {\n            isControl: false,\n            requestStart() {\n                return { datas };\n            },\n            request(e: IObject<any>) {\n                if (\"x\" in e) {\n                    distX = e.x - rect.left;\n                } else if (\"deltaX\" in e) {\n                    distX += e.deltaX;\n                }\n                if (\"y\" in e) {\n                    distY = e.y - rect.top;\n                } else if (\"deltaY\" in e) {\n                    distY += e.deltaY;\n                }\n\n                return { datas, distX, distY };\n            },\n            requestEnd() {\n                return { datas, isDrag: true };\n            },\n        };\n    },\n    unset(moveable: any) {\n        moveable.state.dragInfo = null;\n    },\n};\n\n/**\n * Whether or not target can be dragged. (default: false)\n * @name Moveable.Draggable#draggable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.draggable = true;\n */\n\n/**\n * throttle of x, y when drag.\n * @name Moveable.Draggable#throttleDrag\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.throttleDrag = 1;\n */\n\n/**\n* throttle of angle of x, y when drag.\n* @name Moveable.Draggable#throttleDragRotate\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body);\n*\n* moveable.throttleDragRotate = 45;\n*/\n\n/**\n* start angle of throttleDragRotate of x, y when drag.\n* @name Moveable.Draggable#startDragRotate\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body);\n*\n* // 45, 135, 225, 315\n* moveable.throttleDragRotate = 90;\n* moveable.startDragRotate = 45;\n*/\n\n/**\n * When the drag starts, the dragStart event is called.\n * @memberof Moveable.Draggable\n * @event dragStart\n * @param {Moveable.Draggable.OnDragStart} - Parameters for the dragStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { draggable: true });\n * moveable.on(\"dragStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When dragging, the drag event is called.\n * @memberof Moveable.Draggable\n * @event drag\n * @param {Moveable.Draggable.OnDrag} - Parameters for the drag event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { draggable: true });\n * moveable.on(\"drag\", ({ target, transform }) => {\n *     target.style.transform = transform;\n * });\n */\n/**\n * When the drag finishes, the dragEnd event is called.\n * @memberof Moveable.Draggable\n * @event dragEnd\n * @param {Moveable.Draggable.OnDragEnd} - Parameters for the dragEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { draggable: true });\n * moveable.on(\"dragEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n/**\n* When the group drag starts, the `dragGroupStart` event is called.\n* @memberof Moveable.Draggable\n* @event dragGroupStart\n* @param {Moveable.Draggable.OnDragGroupStart} - Parameters for the `dragGroupStart` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     draggable: true\n* });\n* moveable.on(\"dragGroupStart\", ({ targets }) => {\n*     console.log(\"onDragGroupStart\", targets);\n* });\n*/\n\n/**\n* When the group drag, the `dragGroup` event is called.\n* @memberof Moveable.Draggable\n* @event dragGroup\n* @param {Moveable.Draggable.OnDragGroup} - Parameters for the `dragGroup` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     draggable: true\n* });\n* moveable.on(\"dragGroup\", ({ targets, events }) => {\n*     console.log(\"onDragGroup\", targets);\n*     events.forEach(ev => {\n*          // drag event\n*          console.log(\"onDrag left, top\", ev.left, ev.top);\n*          // ev.target!.style.left = `${ev.left}px`;\n*          // ev.target!.style.top = `${ev.top}px`;\n*          console.log(\"onDrag translate\", ev.dist);\n*          ev.target!.style.transform = ev.transform;)\n*     });\n* });\n*/\n\n/**\n * When the group drag finishes, the `dragGroupEnd` event is called.\n * @memberof Moveable.Draggable\n * @event dragGroupEnd\n * @param {Moveable.Draggable.OnDragGroupEnd} - Parameters for the `dragGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     draggable: true\n * });\n * moveable.on(\"dragGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onDragGroupEnd\", targets, isDrag);\n * });\n */\n","import {\n    getDirection, triggerEvent,\n    fillParams,\n    fillEndParams,\n    getAbsolutePosesByState,\n    catchEvent,\n    getOffsetSizeDist,\n    getProps,\n    getDirectionCondition,\n    calculatePoses,\n    fillAfterTransform,\n} from \"../utils\";\nimport {\n    setDragStart,\n    getResizeDist,\n    getAbsolutePosition,\n    getPosByDirection,\n    getNextMatrix,\n    getNextTransforms,\n} from \"../gesto/GestoUtils\";\nimport {\n    ResizableProps, OnResizeGroup, OnResizeGroupEnd,\n    OnResizeGroupStart, DraggableProps, OnDrag, OnResizeStart, SnappableState,\n    OnResize, OnResizeEnd, MoveableManagerInterface, MoveableGroupInterface, SnappableProps,\n    OnBeforeResize, OnBeforeResizeGroup, ResizableRequestParam,\n} from \"../types\";\nimport { getRenderDirections } from \"../renderDirections\";\nimport {\n    fillChildEvents,\n    triggerChildAbles,\n} from \"../groupUtils\";\nimport Draggable from \"./Draggable\";\nimport { calculate, convertDimension, createRotateMatrix, plus } from \"@scena/matrix\";\nimport CustomGesto, { setCustomDrag } from \"../gesto/CustomGesto\";\nimport { checkSnapResize } from \"./Snappable\";\nimport {\n    calculateBoundSize,\n    isString, convertUnitSize,\n    throttle,\n    isNumber,\n} from \"@daybrush/utils\";\nimport { TINY_NUM } from \"../consts\";\nimport { parseMat } from \"css-to-mat\";\n\n/**\n * @namespace Resizable\n * @memberof Moveable\n * @description Resizable indicates whether the target's width and height can be increased or decreased.\n */\n\nconst directionCondition = getDirectionCondition(\"resizable\");\n\nexport default {\n    name: \"resizable\",\n    ableGroup: \"size\",\n    canPinch: true,\n    props: {\n        resizable: Boolean,\n        throttleResize: Number,\n        renderDirections: Array,\n        keepRatio: Boolean,\n        resizeFormat: Function,\n        keepRatioFinally: Boolean,\n        edge: Boolean,\n    } as const,\n    events: {\n        onResizeStart: \"resizeStart\",\n        onBeforeResize: \"beforeResize\",\n        onResize: \"resize\",\n        onResizeEnd: \"resizeEnd\",\n\n        onResizeGroupStart: \"resizeGroupStart\",\n        onBeforeResizeGroup: \"beforeResizeGroup\",\n        onResizeGroup: \"resizeGroup\",\n        onResizeGroupEnd: \"resizeGroupEnd\",\n    } as const,\n    render: getRenderDirections(\"resizable\"),\n    dragControlCondition: directionCondition,\n    dragControlStart(\n        moveable: MoveableManagerInterface<ResizableProps & DraggableProps, SnappableState>,\n        e: any,\n    ) {\n        const {\n            inputEvent,\n            isPinch,\n            isGroup,\n            parentDirection,\n            parentGesto,\n            datas,\n            parentFixedDirection,\n            parentEvent,\n        } = e;\n\n        const direction = parentDirection || (isPinch ? [0, 0] : getDirection(inputEvent.target));\n        const state = moveable.state;\n        const { target, width, height, gestos } = state;\n\n        if (!direction || !target) {\n            return false;\n        }\n        if (gestos.resizable) {\n            return false;\n        }\n        gestos.resizable = parentGesto || moveable.controlGesto;\n        !isPinch && setDragStart(moveable, e);\n\n        datas.datas = {};\n        datas.direction = direction;\n        datas.startOffsetWidth = width;\n        datas.startOffsetHeight = height;\n        datas.prevWidth = 0;\n        datas.prevHeight = 0;\n\n        datas.minSize = [0, 0];\n        datas.startWidth = state.cssWidth;\n        datas.startHeight = state.cssHeight;\n        datas.maxSize = [Infinity, Infinity];\n\n        if (!isGroup) {\n            datas.minSize = [\n                state.minOffsetWidth,\n                state.minOffsetHeight,\n            ];\n            datas.maxSize = [\n                state.maxOffsetWidth,\n                state.maxOffsetHeight,\n            ];\n        }\n        const transformOrigin = moveable.props.transformOrigin || \"% %\";\n\n        datas.transformOrigin = transformOrigin && isString(transformOrigin)\n            ? transformOrigin.split(\" \")\n            : transformOrigin;\n\n        datas.startOffsetMatrix = state.offsetMatrix;\n        datas.startTransformOrigin = state.transformOrigin;\n\n        datas.isWidth = e?.parentIsWidth ?? ((!direction[0] && !direction[1]) || direction[0] || !direction[1]);\n\n        function setRatio(ratio: number) {\n            datas.ratio = ratio && isFinite(ratio) ? ratio : 0;\n        }\n\n\n        datas.startPositions = getAbsolutePosesByState(moveable.state);\n\n        function setFixedDirection(fixedDirection: number[]) {\n            datas.fixedDirection = fixedDirection;\n            datas.fixedPosition = getPosByDirection(datas.startPositions, fixedDirection);\n        }\n        function setMin(minSize: Array<string | number>)  {\n            datas.minSize = [\n                convertUnitSize(`${minSize[0]}`, 0) || 0,\n                convertUnitSize(`${minSize[1]}`, 0) || 0,\n            ];\n        }\n        function setMax(maxSize: Array<string | number>) {\n            const nextMaxSize = [\n                maxSize[0] || Infinity,\n                maxSize[1] || Infinity,\n            ];\n            if (!isNumber(nextMaxSize[0]) || isFinite(nextMaxSize[0])) {\n                nextMaxSize[0] = convertUnitSize(`${nextMaxSize[0]}`, 0) || Infinity;\n            }\n            if (!isNumber(nextMaxSize[1]) || isFinite(nextMaxSize[1])) {\n                nextMaxSize[1] = convertUnitSize(`${nextMaxSize[1]}`, 0) || Infinity;\n            }\n            datas.maxSize = nextMaxSize;\n        }\n\n        setRatio(width / height);\n        setFixedDirection(parentFixedDirection || [-direction[0], -direction[1]]);\n\n        datas.setFixedDirection = setFixedDirection;\n        datas.setMin = setMin;\n        datas.setMax = setMax;\n        const params = fillParams<OnResizeStart>(moveable, e, {\n            direction,\n            startRatio: datas.ratio,\n            set: ([startWidth, startHeight]: number[]) => {\n                datas.startWidth = startWidth;\n                datas.startHeight = startHeight;\n            },\n            setMin,\n            setMax,\n            setRatio,\n            setFixedDirection,\n            setOrigin: (origin: Array<string | number>) => {\n                datas.transformOrigin = origin;\n            },\n            dragStart: Draggable.dragStart(\n                moveable,\n                new CustomGesto().dragStart([0, 0], e),\n            ),\n        });\n        const result = parentEvent || triggerEvent(moveable, \"onResizeStart\", params);\n\n        datas.startFixedDirection = datas.fixedDirection;\n        if (result !== false) {\n            datas.isResize = true;\n            moveable.state.snapRenderInfo = {\n                request: e.isRequest,\n                direction,\n            };\n        }\n        return datas.isResize ? params : false;\n    },\n    dragControl(\n        moveable: MoveableManagerInterface<ResizableProps & DraggableProps & SnappableProps>,\n        e: any,\n    ) {\n        const {\n            datas,\n            parentFlag,\n            isPinch,\n            parentKeepRatio,\n            dragClient,\n            parentDist,\n            isRequest,\n            isGroup,\n            parentEvent,\n            resolveMatrix,\n        } = e;\n\n        const {\n            isResize,\n            transformOrigin,\n            startWidth,\n            startHeight,\n            prevWidth,\n            prevHeight,\n            minSize,\n            maxSize,\n            ratio,\n            startOffsetWidth,\n            startOffsetHeight,\n            isWidth,\n        } = datas;\n\n        if (!isResize) {\n            return;\n        }\n        if (resolveMatrix) {\n            const {\n                is3d,\n            } = moveable.state;\n            const {\n                startOffsetMatrix,\n                startTransformOrigin,\n            } = datas;\n            const n = is3d ? 4 : 3;\n            let targetMatrix = parseMat(getNextTransforms(e));\n            const targetN = Math.sqrt(targetMatrix.length);\n\n            if (n !== targetN) {\n                targetMatrix = convertDimension(targetMatrix, targetN, n);\n            }\n\n            const nextAllMatrix = getNextMatrix(\n                startOffsetMatrix,\n                targetMatrix,\n                startTransformOrigin,\n                n,\n            );\n            const poses = calculatePoses(nextAllMatrix, startOffsetWidth, startOffsetHeight, n);\n\n            datas.startPositions = poses;\n            datas.nextTargetMatrix = targetMatrix;\n            datas.nextAllMatrix = nextAllMatrix;\n        }\n        const props = getProps(moveable.props, \"resizable\");\n        const {\n            resizeFormat,\n            throttleResize = parentFlag ? 0 : 1,\n            parentMoveable,\n            keepRatioFinally,\n        } = props;\n        const direction = datas.direction;\n        let sizeDirection = direction;\n        let distWidth = 0;\n        let distHeight = 0;\n\n        if (!direction[0] && !direction[1]) {\n            sizeDirection = [1, 1];\n        }\n        const keepRatio = (ratio && (parentKeepRatio != null ? parentKeepRatio : props.keepRatio)) || false;\n\n        function getNextBoundingSize() {\n            const fixedDirection = datas.fixedDirection;\n            const nextSize = getOffsetSizeDist(sizeDirection, keepRatio, datas, e);\n\n            distWidth = nextSize.distWidth;\n            distHeight = nextSize.distHeight;\n\n            let nextWidth = (sizeDirection[0] - fixedDirection[0]) || keepRatio\n                ? Math.max(startOffsetWidth + distWidth, TINY_NUM) : startOffsetWidth;\n            let nextHeight = (sizeDirection[1] - fixedDirection[1]) || keepRatio\n                ? Math.max(startOffsetHeight + distHeight, TINY_NUM) : startOffsetHeight;\n\n            if (keepRatio && startOffsetWidth && startOffsetHeight) {\n                // startOffsetWidth : startOffsetHeight = nextWidth : nextHeight\n                if (isWidth) {\n                    nextHeight = nextWidth / ratio;\n                } else {\n                    nextWidth = nextHeight * ratio;\n                }\n            }\n            return [nextWidth, nextHeight];\n        }\n\n        let [boundingWidth, boundingHeight] = getNextBoundingSize();\n\n        if (!parentEvent) {\n            datas.setFixedDirection(datas.fixedDirection);\n\n            triggerEvent(moveable, \"onBeforeResize\", fillParams<OnBeforeResize>(moveable, e, {\n                startFixedDirection: datas.startFixedDirection,\n                setFixedDirection(nextFixedDirection: number[]) {\n                    datas.setFixedDirection(nextFixedDirection);\n\n                    [boundingWidth, boundingHeight] = getNextBoundingSize();\n\n                    return [boundingWidth, boundingHeight];\n                },\n                boundingWidth,\n                boundingHeight,\n                setSize(size: number[]) {\n                    [boundingWidth, boundingHeight] = size;\n                },\n            }, true));\n        }\n\n        let fixedPosition = dragClient;\n\n        if (!dragClient) {\n            if (!parentFlag && isPinch) {\n                fixedPosition = getAbsolutePosition(moveable, [0, 0]);\n            } else {\n                fixedPosition = datas.fixedPosition;\n            }\n        }\n\n        let snapDist = [0, 0];\n\n        if (!isPinch) {\n            snapDist = checkSnapResize(\n                moveable,\n                boundingWidth,\n                boundingHeight,\n                direction,\n                fixedPosition,\n                isRequest,\n                datas,\n            );\n        }\n        if (parentDist) {\n            !parentDist[0] && (snapDist[0] = 0);\n            !parentDist[1] && (snapDist[1] = 0);\n        }\n\n        function computeSize() {\n            if (resizeFormat) {\n                [boundingWidth, boundingHeight] = resizeFormat([boundingWidth, boundingHeight]);\n            }\n            boundingWidth = throttle(boundingWidth, throttleResize!);\n            boundingHeight = throttle(boundingHeight, throttleResize!);\n        }\n        if (keepRatio) {\n            if (sizeDirection[0] && sizeDirection[1] && snapDist[0] && snapDist[1]) {\n                if (Math.abs(snapDist[0]) > Math.abs(snapDist[1])) {\n                    snapDist[1] = 0;\n                } else {\n                    snapDist[0] = 0;\n                }\n            }\n            const isNoSnap = !snapDist[0] && !snapDist[1];\n\n            if (isNoSnap) {\n                // pre-compute before maintaining the ratio\n                computeSize();\n            }\n            if (\n                (sizeDirection[0] && !sizeDirection[1])\n                || (snapDist[0] && !snapDist[1])\n                || (isNoSnap && isWidth)\n            ) {\n                boundingWidth += snapDist[0];\n                boundingHeight = boundingWidth / ratio;\n            } else if (\n                (!sizeDirection[0] && sizeDirection[1])\n                || (!snapDist[0] && snapDist[1])\n                || (isNoSnap && !isWidth)\n            ) {\n                boundingHeight += snapDist[1];\n                boundingWidth = boundingHeight * ratio;\n            }\n        } else {\n            boundingWidth += snapDist[0];\n            boundingHeight += snapDist[1];\n\n            boundingWidth = Math.max(0, boundingWidth);\n            boundingHeight = Math.max(0, boundingHeight);\n        }\n\n        [boundingWidth, boundingHeight] = calculateBoundSize(\n            [boundingWidth, boundingHeight],\n            minSize,\n            maxSize,\n            keepRatio ? ratio : false,\n        );\n        computeSize();\n\n        if (keepRatio && (isGroup || keepRatioFinally)) {\n            if (isWidth) {\n                boundingHeight = boundingWidth / ratio;\n            } else {\n                boundingWidth = boundingHeight * ratio;\n            }\n        }\n        distWidth = boundingWidth - startOffsetWidth;\n        distHeight = boundingHeight - startOffsetHeight;\n\n        const delta = [distWidth - prevWidth, distHeight - prevHeight];\n\n        datas.prevWidth = distWidth;\n        datas.prevHeight = distHeight;\n\n        const inverseDelta = getResizeDist(\n            moveable,\n            boundingWidth,\n            boundingHeight,\n            fixedPosition,\n            transformOrigin,\n            datas,\n        );\n\n        if (!parentMoveable && delta.every(num => !num) && inverseDelta.every(num => !num)) {\n            return;\n        }\n        const drag = Draggable.drag(\n            moveable,\n            setCustomDrag(e, moveable.state, inverseDelta, !!isPinch, false, \"draggable\"),\n        ) as OnDrag;\n        const transform = drag.transform;\n\n        const nextWidth = startWidth + distWidth;\n        const nextHeight = startHeight + distHeight;\n\n        const params = fillParams<OnResize>(moveable, e, {\n            width: nextWidth,\n            height: nextHeight,\n            offsetWidth: Math.round(boundingWidth),\n            offsetHeight: Math.round(boundingHeight),\n            startRatio: ratio,\n            boundingWidth,\n            boundingHeight,\n            direction,\n            dist: [distWidth, distHeight],\n            delta,\n            isPinch: !!isPinch,\n            drag,\n            ...fillAfterTransform({\n                style: {\n                    width: `${nextWidth}px`,\n                    height: `${nextHeight}px`,\n                },\n                transform,\n            }, drag, e),\n        });\n        !parentEvent && triggerEvent(moveable, \"onResize\", params);\n        return params;\n    },\n    dragControlAfter(\n        moveable: MoveableManagerInterface<ResizableProps & DraggableProps>,\n        e: any,\n    ) {\n        const datas = e.datas;\n        const {\n            isResize,\n            startOffsetWidth,\n            startOffsetHeight,\n            prevWidth,\n            prevHeight,\n        } = datas;\n\n        if (!isResize) {\n            return;\n        }\n        const {\n            width,\n            height,\n        } = moveable.state;\n        const errorWidth = width - (startOffsetWidth + prevWidth);\n        const errorHeight = height - (startOffsetHeight + prevHeight);\n        const isErrorWidth = Math.abs(errorWidth) > 3;\n        const isErrorHeight = Math.abs(errorHeight) > 3;\n\n        if (isErrorWidth) {\n            datas.startWidth += errorWidth;\n            datas.startOffsetWidth += errorWidth;\n            datas.prevWidth += errorWidth;\n        }\n        if (isErrorHeight) {\n            datas.startHeight += errorHeight;\n            datas.startOffsetHeight += errorHeight;\n            datas.prevHeight += errorHeight;\n        }\n        if (isErrorWidth || isErrorHeight) {\n            return this.dragControl(moveable, e);\n        }\n    },\n    dragControlEnd(\n        moveable: MoveableManagerInterface<ResizableProps & DraggableProps>,\n        e: any,\n    ) {\n        const { datas, parentEvent } = e;\n        if (!datas.isResize) {\n            return;\n        }\n        datas.isResize = false;\n\n        const params = fillEndParams<OnResizeEnd>(moveable, e, {});\n        !parentEvent && triggerEvent(moveable, \"onResizeEnd\", params);\n        return params;\n    },\n    dragGroupControlCondition: directionCondition,\n    dragGroupControlStart(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas } = e;\n        const params = this.dragControlStart(moveable, {...e, isGroup: true });\n\n        if (!params) {\n            return false;\n        }\n        const originalEvents = fillChildEvents(moveable, \"resizable\", e);\n        function setDist(child: MoveableManagerInterface, ev: any) {\n            const fixedDirection = datas.fixedDirection;\n            const fixedPosition = datas.fixedPosition;\n\n            const startPositions = ev.datas.startPositions || getAbsolutePosesByState(child.state);\n            const pos = getPosByDirection(startPositions, fixedDirection);\n            const [originalX, originalY] = calculate(\n                createRotateMatrix(-moveable.rotation / 180 * Math.PI, 3),\n                [pos[0] - fixedPosition[0], pos[1] - fixedPosition[1], 1],\n                3,\n            );\n            ev.datas.originalX = originalX;\n            ev.datas.originalY = originalY;\n\n            return ev;\n        }\n        const {\n            startOffsetWidth: parentStartOffsetWidth,\n            startOffsetHeight: parentStartOffsetHeight,\n        } = datas;\n\n        function updateGroupMin() {\n            const originalMinSize = datas.minSize;\n            originalEvents.forEach(ev => {\n                const {\n                    minSize: childMinSize,\n                    startOffsetWidth: childStartOffsetWidth,\n                    startOffsetHeight: childStartOffsetHeight,\n                } = ev.datas;\n\n                const parentMinWidth = parentStartOffsetWidth\n                    * (childStartOffsetWidth ? childMinSize[0] / childStartOffsetWidth : 0);\n                const parentMinHeight = parentStartOffsetHeight\n                    * (childStartOffsetHeight ? childMinSize[1] / childStartOffsetHeight : 0);\n\n                originalMinSize[0] = Math.max(originalMinSize[0], parentMinWidth);\n                originalMinSize[1] = Math.max(originalMinSize[1], parentMinHeight);\n            });\n        }\n\n        function updateGroupMax() {\n            const originalMaxSize = datas.maxSize;\n            originalEvents.forEach(ev => {\n                const {\n                    maxSize: childMaxSize,\n                    startOffsetWidth: childStartOffsetWidth,\n                    startOffsetHeight: childStartOffsetHeight,\n                } = ev.datas;\n\n                const parentMaxWidth = parentStartOffsetWidth\n                    * (childStartOffsetWidth ? childMaxSize[0] / childStartOffsetWidth : 0);\n                const parentMaxHeight = parentStartOffsetHeight\n                    * (childStartOffsetHeight ? childMaxSize[1] / childStartOffsetHeight : 0);\n\n                originalMaxSize[0] = Math.min(originalMaxSize[0], parentMaxWidth);\n                originalMaxSize[1] = Math.min(originalMaxSize[1], parentMaxHeight);\n            });\n        }\n        const events = triggerChildAbles(\n            moveable,\n            this,\n            \"dragControlStart\",\n            e,\n            (child, ev) => {\n                return setDist(child, ev);\n            },\n        );\n\n\n        updateGroupMin();\n        updateGroupMax();\n\n        const setFixedDirection = (fixedDirection: number[]) => {\n            params.setFixedDirection(fixedDirection);\n            events.forEach((ev, i) => {\n                ev.setFixedDirection(fixedDirection);\n                setDist(ev.moveable, originalEvents[i]);\n            });\n        };\n\n        datas.setFixedDirection = setFixedDirection;\n\n        const nextParams: OnResizeGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events: events.map(ev => {\n                return {\n                    ...ev,\n                    setMin: (minSize: Array<number | string>) => {\n                        ev.setMin(minSize);\n                        updateGroupMin();\n                    },\n                    setMax: (maxSize: Array<number | string>) => {\n                        ev.setMax(maxSize);\n                        updateGroupMax();\n                    },\n                };\n            }),\n            setFixedDirection,\n            setMin: (minSize: Array<number | string>) => {\n                params.setMin(minSize);\n                updateGroupMin();\n            },\n            setMax: (maxSize: Array<number | string>) => {\n                params.setMax(maxSize);\n                updateGroupMax();\n            },\n        };\n        const result = triggerEvent(moveable, \"onResizeGroupStart\", nextParams);\n\n        datas.isResize = result !== false;\n        return datas.isResize ? params : false;\n    },\n    dragGroupControl(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas } = e;\n        if (!datas.isResize) {\n            return;\n        }\n        const props = getProps(moveable.props, \"resizable\");\n\n        catchEvent(moveable, \"onBeforeResize\", parentEvent => {\n            triggerEvent(moveable, \"onBeforeResizeGroup\", fillParams<OnBeforeResizeGroup>(moveable, e, {\n                ...parentEvent,\n                targets: props.targets!,\n            }, true));\n        });\n\n\n        const params = this.dragControl(moveable, {...e, isGroup: true });\n\n        if (!params) {\n            return;\n        }\n        const {\n            boundingWidth,\n            boundingHeight,\n            dist,\n        } = params;\n\n        const keepRatio = props.keepRatio;\n\n        const parentScale = [\n            boundingWidth / (boundingWidth - dist[0]),\n            boundingHeight / (boundingHeight - dist[1]),\n        ];\n        const fixedPosition = datas.fixedPosition;\n\n        const events = triggerChildAbles(\n            moveable,\n            this,\n            \"dragControl\",\n            e,\n            (_, ev) => {\n                const [clientX, clientY] = calculate(\n                    createRotateMatrix(moveable.rotation / 180 * Math.PI, 3),\n                    [\n                        ev.datas.originalX * parentScale[0],\n                        ev.datas.originalY * parentScale[1],\n                        1,\n                    ],\n                    3,\n                );\n\n                return {\n                    ...ev,\n                    parentDist: null,\n                    parentScale,\n                    dragClient: plus(fixedPosition, [clientX, clientY]),\n                    parentKeepRatio: keepRatio,\n                };\n            },\n        );\n        const nextParams: OnResizeGroup = {\n            targets: props.targets!,\n            events,\n            ...params,\n        };\n\n        triggerEvent(moveable, \"onResizeGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupControlEnd(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isResize) {\n            return;\n        }\n\n        this.dragControlEnd(moveable, e);\n        const events = triggerChildAbles(moveable, this, \"dragControlEnd\", e);\n\n        const nextParams: OnResizeGroupEnd = fillEndParams<OnResizeGroupEnd>(moveable, e, {\n            targets: moveable.props.targets!,\n            events,\n        });\n\n        triggerEvent(moveable, \"onResizeGroupEnd\", nextParams);\n        return isDrag;\n    },\n    /**\n     * @method Moveable.Resizable#request\n     * @param {Moveable.Resizable.ResizableRequestParam} e - the Resizable's request parameter\n     * @return {Moveable.Requester} Moveable Requester\n     * @example\n\n     * // Instantly Request (requestStart - request - requestEnd)\n     * // Use Relative Value\n     * moveable.request(\"resizable\", { deltaWidth: 10, deltaHeight: 10 }, true);\n     *\n     * // Use Absolute Value\n     * moveable.request(\"resizable\", { offsetWidth: 100, offsetHeight: 100 }, true);\n     *\n     * // requestStart\n     * const requester = moveable.request(\"resizable\");\n     *\n     * // request\n     * // Use Relative Value\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     *\n     * // Use Absolute Value\n     * moveable.request(\"resizable\", { offsetWidth: 100, offsetHeight: 100 });\n     * moveable.request(\"resizable\", { offsetWidth: 110, offsetHeight: 100 });\n     * moveable.request(\"resizable\", { offsetWidth: 120, offsetHeight: 100 });\n     *\n     * // requestEnd\n     * requester.requestEnd();\n     */\n    request(moveable: MoveableManagerInterface<any>) {\n        const datas: Record<string, any> = {};\n        let distWidth = 0;\n        let distHeight = 0;\n        const rect = moveable.getRect();\n\n        return {\n            isControl: true,\n            requestStart(e: ResizableRequestParam) {\n                return { datas, parentDirection: e.direction || [1, 1], parentIsWidth: e?.horizontal ?? true };\n            },\n            request(e: ResizableRequestParam) {\n                if (\"offsetWidth\" in e) {\n                    distWidth = e.offsetWidth! - rect.offsetWidth;\n                } else if (\"deltaWidth\" in e) {\n                    distWidth += e.deltaWidth!;\n                }\n                if (\"offsetHeight\" in e) {\n                    distHeight = e.offsetHeight! - rect.offsetHeight;\n                } else if (\"deltaHeight\" in e) {\n                    distHeight += e.deltaHeight!;\n                }\n\n\n                return { datas, parentDist: [distWidth, distHeight], parentKeepRatio: e.keepRatio };\n            },\n            requestEnd() {\n                return { datas, isDrag: true };\n            },\n        };\n    },\n};\n\n/**\n * Whether or not target can be resized.\n * @name Moveable.Resizable#resizable\n * @default false\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     resizable: false,\n * });\n *\n * moveable.resizable = true;\n */\n\n/**\n * throttle of width, height when resize. If throttleResize is set to less than 1, the target may shake.\n * @name Moveable.Resizable#throttleResize\n * @default 1\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   resizable: true,\n *   throttleResize: 1,\n * });\n *\n * moveable.throttleResize = 0;\n */\n/**\n * When resize or scale, keeps a ratio of the width, height.\n * @name Moveable.Resizable#keepRatio\n * @default false\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   resizable: true,\n * });\n *\n * moveable.keepRatio = true;\n */\n/**\n * Set directions to show the control box.\n * @name Moveable.Resizable#renderDirections\n * @default [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"]\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   resizable: true,\n *   renderDirections: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"],\n * });\n *\n * moveable.renderDirections = [\"nw\", \"ne\", \"sw\", \"se\"];\n */\n\n/**\n * Function to convert size for resize\n * @name Moveable.Resizable#resizeFormat\n * @default oneself\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   resizable: true,\n *   resizeFormat: v => v,\n * });\n *\n * moveable.resizeFormat = (size: number[]) => ([Math.trunc(size[0]), Math.trunc(size[1])];\n */\n\n/**\n * When the resize starts, the resizeStart event is called.\n * @memberof Moveable.Resizable\n * @event resizeStart\n * @param {Moveable.Resizable.OnResizeStart} - Parameters for the resizeStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { resizable: true });\n * moveable.on(\"resizeStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n\n/**\n * When resizing, `beforeResize` is called before `resize` occurs. In `beforeResize`, you can get and set the pre-value before resizing.\n * @memberof Moveable.Resizable\n * @event beforeResize\n * @param {Moveable.Resizable.OnBeforeResize} - Parameters for the `beforeResize` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { resizable: true });\n * moveable.on(\"beforeResize\", ({ setFixedDirection }) => {\n *     if (shiftKey) {\n *        setFixedDirection([0, 0]);\n *     }\n * });\n * moveable.on(\"resize\", ({ target, width, height, drag }) => {\n *     target.style.width = `${width}px`;\n *     target.style.height = `${height}px`;\n *     target.style.transform = drag.transform;\n * });\n */\n\n/**\n * When resizing, the resize event is called.\n * @memberof Moveable.Resizable\n * @event resize\n * @param {Moveable.Resizable.OnResize} - Parameters for the resize event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { resizable: true });\n * moveable.on(\"resize\", ({ target, width, height }) => {\n *     target.style.width = `${e.width}px`;\n *     target.style.height = `${e.height}px`;\n * });\n */\n/**\n * When the resize finishes, the resizeEnd event is called.\n * @memberof Moveable.Resizable\n * @event resizeEnd\n * @param {Moveable.Resizable.OnResizeEnd} - Parameters for the resizeEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { resizable: true });\n * moveable.on(\"resizeEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n/**\n* When the group resize starts, the `resizeGroupStart` event is called.\n* @memberof Moveable.Resizable\n* @event resizeGroupStart\n* @param {Moveable.Resizable.OnResizeGroupStart} - Parameters for the `resizeGroupStart` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     resizable: true\n* });\n* moveable.on(\"resizeGroupStart\", ({ targets }) => {\n*     console.log(\"onResizeGroupStart\", targets);\n* });\n*/\n\n/**\n* When the group resize, the `resizeGroup` event is called.\n* @memberof Moveable.Resizable\n* @event resizeGroup\n* @param {Moveable.Resizable.onResizeGroup} - Parameters for the `resizeGroup` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     resizable: true\n* });\n* moveable.on(\"resizeGroup\", ({ targets, events }) => {\n*     console.log(\"onResizeGroup\", targets);\n*     events.forEach(ev => {\n*         const offset = [\n*             direction[0] < 0 ? -ev.delta[0] : 0,\n*             direction[1] < 0 ? -ev.delta[1] : 0,\n*         ];\n*         // ev.drag is a drag event that occurs when the group resize.\n*         const left = offset[0] + ev.drag.beforeDist[0];\n*         const top = offset[1] + ev.drag.beforeDist[1];\n*         const width = ev.width;\n*         const top = ev.top;\n*     });\n* });\n*/\n\n/**\n * When the group resize finishes, the `resizeGroupEnd` event is called.\n * @memberof Moveable.Resizable\n * @event resizeGroupEnd\n * @param {Moveable.Resizable.OnResizeGroupEnd} - Parameters for the `resizeGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     resizable: true\n * });\n * moveable.on(\"resizeGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onResizeGroupEnd\", targets, isDrag);\n * });\n */\n","import {\n    prefix, triggerEvent, fillParams,\n    calculatePosition, fillEndParams, getRotationRad, getRefTargets,\n    catchEvent, getProps, calculateMoveableClientPositions,\n    fillAfterTransform,\n} from \"../utils\";\nimport {\n    IObject, hasClass, getRad,\n    throttle,\n    getDist,\n    getKeys,\n    isArray,\n} from \"@daybrush/utils\";\nimport {\n    RotatableProps, OnRotateGroup, OnRotateGroupEnd,\n    Renderer, OnRotateGroupStart, OnRotateStart, OnRotate,\n    OnRotateEnd, MoveableClientRect, SnappableProps,\n    SnappableState, MoveableManagerInterface, MoveableGroupInterface, DraggableProps,\n    OnBeforeRotate,\n    OnBeforeRotateGroup,\n    OnResizeStart,\n    OnResize,\n    TransformObject,\n    OnDragStart,\n} from \"../types\";\nimport { triggerChildAbles } from \"../groupUtils\";\nimport { calculate, convertPositionMatrix, getOrigin, minus, plus, rotate as rotateMatrix } from \"@scena/matrix\";\nimport CustomGesto, { setCustomDrag } from \"../gesto/CustomGesto\";\nimport { checkSnapRotate } from \"./Snappable\";\nimport {\n    fillTransformStartEvent,\n    convertTransformFormat, getRotateDist,\n    getOriginDirection,\n    getDirectionOffset,\n    fillTransformEvent,\n    setDefaultTransformIndex,\n    resolveTransformEvent,\n    getTransformDirection,\n    getPosByDirection,\n} from \"../gesto/GestoUtils\";\nimport { DirectionControlInfo, renderAroundControls, renderDirectionControlsByInfos } from \"../renderDirections\";\nimport { DIRECTIONS, DIRECTION_REGION_TO_DIRECTION } from \"../consts\";\nimport Resizable from \"./Resizable\";\nimport Draggable from \"./Draggable\";\n\n/**\n * @namespace Rotatable\n * @memberof Moveable\n * @description Rotatable indicates whether the target can be rotated.\n */\n\nfunction setRotateStartInfo(\n    moveable: MoveableManagerInterface<any, any>,\n    datas: IObject<any>, clientX: number, clientY: number,\n    rect: MoveableClientRect,\n) {\n    const groupable = moveable.props.groupable;\n    const state = moveable.state;\n    const n = state.is3d ? 4 : 3;\n    const origin = datas.origin;\n    const nextOrigin = calculatePosition(\n        moveable.state.rootMatrix,\n        // TO-DO #710\n        minus([origin[0], origin[1]], groupable ? [0, 0] : [state.left, state.top]),\n        n,\n    );\n    const startAbsoluteOrigin = plus([rect.left, rect.top], nextOrigin);\n\n    datas.startAbsoluteOrigin = startAbsoluteOrigin;\n    datas.prevDeg = getRad(startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180;\n    datas.defaultDeg = datas.prevDeg;\n    datas.prevSnapDeg = 0;\n    datas.loop = 0;\n    datas.startDist = getDist(startAbsoluteOrigin, [clientX, clientY]);\n}\n\nfunction getAbsoluteDist(\n    deg: number,\n    direction: number,\n    datas: IObject<any>,\n) {\n    const {\n        defaultDeg,\n        prevDeg,\n    } = datas;\n\n\n    let normalizedPrevDeg = prevDeg % 360;\n    let loop = Math.floor(prevDeg / 360);\n\n    if (normalizedPrevDeg < 0) {\n        normalizedPrevDeg += 360;\n    }\n\n    if (normalizedPrevDeg > deg && normalizedPrevDeg > 270 && deg < 90) {\n        // 360 => 0\n        ++loop;\n    } else if (normalizedPrevDeg < deg && normalizedPrevDeg < 90 && deg > 270) {\n        // 0 => 360\n        --loop;\n    }\n    const dist = direction * (loop * 360 + deg - defaultDeg);\n\n    datas.prevDeg = defaultDeg + dist;\n\n    return dist;\n}\nfunction getAbsoluteDistByClient(\n    clientX: number, clientY: number,\n    direction: number,\n    datas: IObject<any>,\n) {\n    return getAbsoluteDist(\n        getRad(datas.startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180,\n        direction,\n        datas,\n    );\n}\nfunction getRotateInfo(\n    moveable: MoveableManagerInterface<any, any>,\n    moveableRect: any,\n    datas: IObject<any>,\n    dist: number,\n    startValue: number,\n    isSnap?: boolean,\n) {\n    const {\n        throttleRotate = 0,\n    } = moveable.props;\n    let nextDist = dist;\n\n    const prevSnapDeg = datas.prevSnapDeg;\n\n\n\n    if (isSnap) {\n        nextDist = checkSnapRotate(moveable, moveableRect, datas.origin, nextDist);\n    }\n\n    const snapRotation = throttle(startValue + nextDist, throttleRotate);\n    const snapDeg = snapRotation - startValue;\n\n    datas.prevSnapDeg = snapDeg;\n\n    return [snapDeg - prevSnapDeg, nextDist, snapRotation];\n\n\n}\n\nexport function getReversePositionX(dir: string) {\n    if (dir === \"left\") {\n        return \"right\";\n    } else if (dir === \"right\") {\n        return \"left\";\n    }\n    return dir;\n}\nexport function getReversePositionY(dir: string) {\n    if (dir === \"top\") {\n        return \"bottom\";\n    } else if (dir === \"bottom\") {\n        return \"top\";\n    }\n    return dir;\n}\nexport function getRotationPositions(\n    rotationPosition: RotatableProps[\"rotationPosition\"],\n    [pos1, pos2, pos3, pos4]: number[][],\n    direction: number,\n) {\n    if (rotationPosition === \"none\") {\n        return;\n    }\n    const [dir1, dir2] = (rotationPosition || \"top\").split(\"-\");\n    let radPoses = [pos1, pos2];\n\n    // if (scale[0] < 0) {\n    //     dir1 = getReversePositionX(dir1);\n    //     dir2 = getReversePositionX(dir2);\n    // }\n    // if (scale[1] < 0) {\n    //     dir1 = getReversePositionY(dir1);\n    //     dir2 = getReversePositionY(dir2);\n    // }\n    if (dir1 === \"left\") {\n        radPoses = [pos3, pos1];\n    } else if (dir1 === \"right\") {\n        radPoses = [pos2, pos4];\n    } else if (dir1 === \"bottom\") {\n        radPoses = [pos4, pos3];\n    }\n    let pos = [\n        (radPoses[0][0] + radPoses[1][0]) / 2,\n        (radPoses[0][1] + radPoses[1][1]) / 2,\n    ];\n    const rad = getRotationRad(radPoses, direction);\n    if (dir2) {\n        const isStart = dir2 === \"top\" || dir2 === \"left\";\n        const isReverse = dir1 === \"bottom\" || dir1 === \"left\";\n\n        pos = radPoses[(isStart && !isReverse) || (!isStart && isReverse) ? 0 : 1];\n    }\n    return [pos, rad] as const;\n}\n\nexport function dragControlCondition(moveable: MoveableManagerInterface<RotatableProps>, e: any) {\n    if (e.isRequest) {\n        return e.requestAble === \"rotatable\";\n    }\n    const target = e.inputEvent.target as HTMLElement;\n    if (\n        hasClass(target, prefix(\"rotation-control\"))\n        || hasClass(target, prefix(\"around-control\"))\n        || (hasClass(target, prefix(\"control\")) && hasClass(target, prefix(\"rotatable\")))\n    ) {\n        return true;\n    }\n    const rotationTarget = moveable.props.rotationTarget;\n\n    if (rotationTarget) {\n        return getRefTargets(rotationTarget, true).some(element => {\n            if (!element) {\n                return false;\n            }\n            return target === element || target.contains(element);\n        });\n    }\n    return false;\n}\n\nconst directionCSS = DIRECTIONS.map(dir => {\n    let top = \"\";\n    let left = \"\";\n    let originX = \"center\";\n    let originY = \"center\";\n\n    if (dir.indexOf(\"n\") > -1) {\n        top = \"top: -20px;\";\n        originY = \"bottom\";\n    }\n    if (dir.indexOf(\"s\") > -1) {\n        top = \"top: 0px;\";\n        originY = \"top\";\n    }\n    if (dir.indexOf(\"w\") > -1) {\n        left = \"left: -20px;\";\n        originX = \"right\";\n    }\n    if (dir.indexOf(\"e\") > -1) {\n        left = \"left: 0px;\";\n        originX = \"left\";\n    }\n    return `.around-control[data-direction*=\"${dir}\"] {\n        ${left}${top}\n        transform-origin: ${originX} ${originY};\n    }`;\n}).join(\"\\n\");\nconst css = `.rotation {\n    position: absolute;\n    height: 40px;\n    width: 1px;\n    transform-origin: 50% 100%;\n    height: calc(40px * var(--zoom));\n    top: auto;\n    left: 0;\n    bottom: 100%;\n    will-change: transform;\n}\n.rotation .rotation-line {\n    display: block;\n    width: 100%;\n    height: 100%;\n    transform-origin: 50% 50%;\n}\n.rotation .rotation-control {\n    border-color: #4af;\n    border-color: var(--moveable-color);\n    background:#fff;\n    cursor: alias;\n}\n.rotatable.direction.control {\n    cursor: alias;\n}\n.around-control {\n    position: absolute;\n    will-change: transform;\n    width: 20px;\n    height: 20px;\n    left: -10px;\n    top: -10px;\n    box-sizing: border-box;\n    background: transparent;\n    z-index: 8;\n    cursor: alias;\n    transform-origin: center center;\n}\n.rotatable.direction.control.move {\n    cursor: move;\n}\n${directionCSS}\n`;\nexport default {\n    name: \"rotatable\",\n    canPinch: true,\n    props: {\n        rotatable: Boolean,\n        rotationPosition: String,\n        throttleRotate: Number,\n        renderDirections: Object,\n        rotationTarget: Object,\n        rotateAroundControls: Boolean,\n        edge: Boolean,\n        resolveAblesWithRotatable: Object,\n    } as const,\n    events: {\n        onRotateStart: \"rotateStart\",\n        onBeforeRotate: \"beforeRotate\",\n        onRotate: \"rotate\",\n        onRotateEnd: \"rotateEnd\",\n        onRotateGroupStart: \"rotateGroupStart\",\n        onBeforeRotateGroup: \"beforeRotateGroup\",\n        onRotateGroup: \"rotateGroup\",\n        onRotateGroupEnd: \"rotateGroupEnd\",\n    } as const,\n    css: [css],\n    render(moveable: MoveableManagerInterface<RotatableProps>, React: Renderer): any {\n        const {\n            rotatable,\n            rotationPosition,\n            zoom,\n            renderDirections,\n            rotateAroundControls,\n            resolveAblesWithRotatable,\n        } = getProps(moveable.props, \"rotatable\");\n        const {\n            renderPoses,\n            direction,\n        } = moveable.state;\n        if (!rotatable) {\n            return null;\n        }\n        const positions = getRotationPositions(rotationPosition!, renderPoses, direction);\n\n        const jsxs = [];\n\n        if (positions) {\n            const [pos, rad] = positions;\n            jsxs.push(\n                <div key=\"rotation\" className={prefix(\"rotation\")} style={{\n                    // tslint:disable-next-line: max-line-length\n                    transform: `translate(-50%) translate(${pos[0]}px, ${pos[1]}px) rotate(${rad}rad)`,\n                }}>\n                    <div className={prefix(\"line rotation-line\")} style={{\n                        transform: `scaleX(${zoom})`,\n                    }}></div>\n                    <div className={prefix(\"control rotation-control\")} style={{\n                        transform: `translate(0.5px) scale(${zoom})`,\n                    }}></div>\n                </div>\n            );\n        }\n        if (renderDirections) {\n            const ables = getKeys(resolveAblesWithRotatable || {});\n            const resolveMap: Record<string, string> = {};\n\n            ables.forEach(name => {\n                resolveAblesWithRotatable![name]!.forEach(direction => {\n                    resolveMap[direction] = name;\n                });\n            });\n\n            let directionControlInfos: DirectionControlInfo[] = [];\n\n            if (isArray(renderDirections)) {\n                directionControlInfos = renderDirections.map(dir => {\n                    const able = resolveMap[dir];\n\n                    return {\n                        data: able ? { resolve: able } : {},\n                        classNames: able ? [`move`] : [],\n                        dir,\n                    };\n                });\n            }\n\n            jsxs.push(...renderDirectionControlsByInfos(\n                moveable,\n                \"rotatable\",\n                directionControlInfos,\n                React,\n            ));\n        }\n        if (rotateAroundControls) {\n            jsxs.push(...renderAroundControls(moveable, React));\n        }\n\n        return jsxs;\n    },\n    dragControlCondition: dragControlCondition as (moveable: any, e: any) => boolean,\n    dragControlStart(\n        moveable: MoveableManagerInterface<RotatableProps & SnappableProps & DraggableProps, SnappableState>,\n        e: any) {\n        const {\n            datas,\n            clientX, clientY,\n            parentRotate, parentFlag, isPinch,\n            isRequest,\n        } = e;\n        const state = moveable.state;\n        const {\n            target, left, top,\n            direction, beforeDirection, targetTransform,\n            moveableClientRect,\n            offsetMatrix,\n            targetMatrix,\n            allMatrix,\n            width,\n            height,\n        } = state;\n\n        if (!isRequest && !target) {\n            return false;\n        }\n\n        const rect = moveable.getRect();\n        datas.rect = rect;\n        datas.transform = targetTransform;\n        datas.left = left;\n        datas.top = top;\n        let setFixedDirection: OnRotateStart[\"setFixedDirection\"] = (fixedDirection: number[]) => {\n            datas.fixedDirection = fixedDirection;\n            datas.fixedPosition = getDirectionOffset(moveable, fixedDirection);\n\n            if (resizeStart) {\n                resizeStart.setFixedDirection(fixedDirection);\n            }\n        };\n        let startClientX = clientX;\n        let startClientY = clientY;\n\n        if (isRequest || isPinch || parentFlag) {\n            const externalRotate = parentRotate || 0;\n\n            datas.beforeInfo = {\n                origin: rect.beforeOrigin,\n                prevDeg: externalRotate,\n                defaultDeg: externalRotate,\n                prevSnapDeg: 0,\n                startDist: 0,\n            };\n            datas.afterInfo = {\n                ...datas.beforeInfo,\n                origin: rect.origin,\n            };\n            datas.absoluteInfo = {\n                ...datas.beforeInfo,\n                origin: rect.origin,\n                startValue: externalRotate,\n            };\n        } else {\n            const inputTarget = e.inputEvent?.target;\n\n            if (inputTarget) {\n                const regionDirection = inputTarget.getAttribute(\"data-direction\") || \"\";\n                const controlDirection = DIRECTION_REGION_TO_DIRECTION[regionDirection];\n\n                if (controlDirection) {\n                    datas.isControl = true;\n                    datas.isAroundControl = hasClass(inputTarget, prefix(\"around-control\"));\n                    datas.controlDirection = controlDirection;\n                    const resolve = inputTarget.getAttribute(\"data-resolve\");\n\n                    if (resolve) {\n                        datas.resolveAble = resolve;\n                    }\n\n                    const clientPoses = calculateMoveableClientPositions(\n                        state.rootMatrix,\n                        state.renderPoses,\n                        moveableClientRect,\n                    );\n\n\n                    [startClientX, startClientY] = getPosByDirection(clientPoses, controlDirection);\n                }\n            }\n\n\n            datas.beforeInfo = { origin: rect.beforeOrigin };\n            datas.afterInfo = { origin: rect.origin };\n            datas.absoluteInfo = {\n                origin: rect.origin,\n                startValue: rect.rotation,\n            };\n\n            const originalFixedDirection = setFixedDirection;\n\n            setFixedDirection = (fixedDirection: number[]) => {\n                const n = state.is3d ? 4 : 3;\n                const originalPosition = getPosByDirection([\n                    [0, 0],\n                    [width, 0],\n                    [0, height],\n                    [width, height],\n                ], fixedDirection);\n                const [originX, originY] = plus(getOrigin(targetMatrix, n), originalPosition);\n                const fixedBeforeOrigin = calculate(\n                    offsetMatrix,\n                    convertPositionMatrix([originX, originY], n),\n                );\n                const fixedAfterOrigin = calculate(\n                    allMatrix,\n                    convertPositionMatrix([originalPosition[0], originalPosition[1]], n),\n                );\n                originalFixedDirection(fixedDirection);\n\n                datas.beforeInfo.origin = fixedBeforeOrigin;\n                datas.afterInfo.origin = fixedAfterOrigin;\n                datas.absoluteInfo.origin = fixedAfterOrigin;\n\n                setRotateStartInfo(moveable, datas.beforeInfo, startClientX, startClientY, moveableClientRect);\n                setRotateStartInfo(moveable, datas.afterInfo, startClientX, startClientY, moveableClientRect);\n                setRotateStartInfo(moveable, datas.absoluteInfo, startClientX, startClientY, moveableClientRect);\n            };\n        }\n\n        datas.startClientX = startClientX;\n        datas.startClientY = startClientY;\n        datas.direction = direction;\n        datas.beforeDirection = beforeDirection;\n        datas.startValue = 0;\n        datas.datas = {};\n\n        setDefaultTransformIndex(e, \"rotate\");\n\n        let dragStart: OnDragStart | false = false;\n        let resizeStart: OnResizeStart | false = false;\n\n\n\n        if (datas.isControl && datas.resolveAble) {\n            const resolveAble = datas.resolveAble;\n\n            if  (resolveAble === \"resizable\") {\n                resizeStart = Resizable.dragControlStart(moveable, {\n                    ...(new CustomGesto(\"resizable\").dragStart([0, 0], e)),\n                    parentDirection: datas.controlDirection,\n                    parentFixedDirection: datas.fixedDirection,\n                });\n            }\n        }\n\n        if (!resizeStart) {\n            dragStart = Draggable.dragStart!(\n                moveable,\n                new CustomGesto().dragStart([0, 0], e),\n            );\n        }\n\n        setFixedDirection(getOriginDirection(moveable));\n        const params = fillParams<OnRotateStart>(moveable, e, {\n            set: (rotatation: number) => {\n                datas.startValue = rotatation * Math.PI / 180;\n            },\n            setFixedDirection,\n            ...fillTransformStartEvent(e),\n            dragStart,\n            resizeStart,\n        });\n        const result = triggerEvent(moveable, \"onRotateStart\", params);\n        datas.isRotate = result !== false;\n        state.snapRenderInfo = {\n            request: e.isRequest,\n        };\n\n        return datas.isRotate ? params : false;\n    },\n    dragControl(\n        moveable: MoveableManagerInterface<RotatableProps & DraggableProps>,\n        e: any,\n    ) {\n        const { datas, distX, distY, parentRotate, parentFlag, isPinch, groupDelta } = e;\n        const {\n            beforeDirection,\n            beforeInfo,\n            afterInfo,\n            absoluteInfo,\n            isRotate,\n            startValue,\n            rect,\n            startClientX,\n            startClientY,\n        } = datas;\n\n        if (!isRotate) {\n            return;\n        }\n\n        resolveTransformEvent(e, \"rotate\");\n\n        const targetDirection = getTransformDirection(e);\n        const direction = beforeDirection * targetDirection;\n        const {\n            parentMoveable,\n        } = moveable.props;\n\n\n        let beforeDelta = 0;\n        let beforeDist: number;\n        let beforeRotation: number;\n\n        let delta = 0;\n        let dist: number;\n        let rotation: number;\n\n        let absoluteDelta = 0;\n        let absoluteDist: number;\n        let absoluteRotation: number;\n\n        const startRotation = 180 / Math.PI * startValue;\n        const absoluteStartRotation = absoluteInfo.startValue;\n        let isSnap = false;\n        const nextClientX = startClientX + distX;\n        const nextClientY = startClientY + distY;\n\n        if (!parentFlag && \"parentDist\" in e) {\n            const parentDist = e.parentDist;\n\n            beforeDist = parentDist;\n            dist = parentDist;\n            absoluteDist = parentDist;\n        } else if (isPinch || parentFlag) {\n            beforeDist = getAbsoluteDist(parentRotate, beforeDirection, beforeInfo);\n            dist = getAbsoluteDist(parentRotate, direction, afterInfo);\n            absoluteDist = getAbsoluteDist(parentRotate, direction, absoluteInfo);\n        } else {\n            beforeDist = getAbsoluteDistByClient(nextClientX, nextClientY, beforeDirection, beforeInfo);\n            dist = getAbsoluteDistByClient(nextClientX, nextClientY, direction, afterInfo);\n            absoluteDist = getAbsoluteDistByClient(nextClientX, nextClientY, direction, absoluteInfo);\n            isSnap = true;\n        }\n        beforeRotation = startRotation + beforeDist;\n        rotation = startRotation + dist;\n        absoluteRotation = absoluteStartRotation + absoluteDist;\n\n\n        triggerEvent(moveable, \"onBeforeRotate\", fillParams<OnBeforeRotate>(moveable, e, {\n            beforeRotation,\n            rotation,\n            absoluteRotation,\n            setRotation(nextRotation: number) {\n                dist = nextRotation - startRotation;\n                beforeDist = dist;\n                absoluteDist = dist;\n            },\n        }, true));\n        [\n            beforeDelta,\n            beforeDist,\n            beforeRotation,\n        ] = getRotateInfo(moveable, rect, beforeInfo, beforeDist, startRotation, isSnap);\n\n        [\n            delta,\n            dist,\n            rotation,\n        ] = getRotateInfo(moveable, rect, afterInfo, dist, startRotation, isSnap);\n\n        [\n            absoluteDelta,\n            absoluteDist,\n            absoluteRotation,\n        ] = getRotateInfo(moveable, rect, absoluteInfo, absoluteDist, absoluteStartRotation, isSnap);\n\n        if (!absoluteDelta && !delta && !beforeDelta && !parentMoveable) {\n            return;\n        }\n\n        const nextTransform = convertTransformFormat(\n            datas, `rotate(${rotation}deg)`, `rotate(${dist}deg)`,\n        );\n\n        const inverseDist = getRotateDist(moveable, dist, datas);\n        const inverseDelta = minus(\n            plus(groupDelta || [0, 0], inverseDist),\n            datas.prevInverseDist || [0, 0],\n        );\n        datas.prevInverseDist = inverseDist;\n\n        datas.requestValue = null;\n\n        const dragEvent = fillTransformEvent(\n            moveable,\n            nextTransform,\n            inverseDelta,\n            isPinch,\n            e,\n        );\n\n        let transformEvent: TransformObject = dragEvent;\n        const parentDistance = getDist(\n            [nextClientX, nextClientY],\n            absoluteInfo.startAbsoluteOrigin,\n        ) - absoluteInfo.startDist;\n\n        let resize: OnResize | undefined = undefined;\n\n        if (datas.resolveAble === \"resizable\") {\n            const resizeEvent = Resizable.dragControl(\n                moveable,\n                {\n                    ...setCustomDrag(e, moveable.state, [e.deltaX, e.deltaY], !!isPinch, false, \"resizable\"),\n                    resolveMatrix: true,\n                    parentDistance,\n                },\n            );\n\n            if (resizeEvent) {\n                resize = resizeEvent;\n                transformEvent = fillAfterTransform(transformEvent, resizeEvent, e);\n            }\n        }\n\n        const params = fillParams<OnRotate>(moveable, e, {\n            delta,\n            dist,\n            rotate: rotation,\n            rotation,\n\n            beforeDist,\n            beforeDelta,\n            beforeRotate: beforeRotation,\n            beforeRotation,\n\n            absoluteDist,\n            absoluteDelta,\n            absoluteRotate: absoluteRotation,\n            absoluteRotation,\n\n            isPinch: !!isPinch,\n            resize,\n            ...dragEvent,\n            ...transformEvent,\n        });\n        triggerEvent(moveable, \"onRotate\", params);\n\n        return params;\n    },\n    dragControlAfter(moveable: MoveableManagerInterface<RotatableProps>, e: any) {\n        const requestValue = e.datas.requestValue;\n\n        if (requestValue != null) {\n            // return this.dragControl(moveable, {...e, parentDist: });\n        }\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<RotatableProps>, e: any) {\n        const { datas } = e;\n\n        if (!datas.isRotate) {\n            return;\n        }\n        datas.isRotate = false;\n\n        const params = fillEndParams<OnRotateEnd>(moveable, e, {});\n\n        triggerEvent(moveable, \"onRotateEnd\", params);\n        return params;\n    },\n    dragGroupControlCondition: dragControlCondition as (moveable: any, e: any) => boolean,\n    dragGroupControlStart(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas } = e;\n        const {\n            left: parentLeft,\n            top: parentTop,\n            beforeOrigin: parentBeforeOrigin,\n        } = moveable.state;\n\n        const params = this.dragControlStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n\n        params.set(datas.beforeDirection * moveable.rotation);\n\n        const events = triggerChildAbles(\n            moveable,\n            this,\n            \"dragControlStart\",\n            e,\n            (child, ev) => {\n                const { left, top, beforeOrigin } = child.state;\n                const childClient = plus(\n                    minus([left, top], [parentLeft, parentTop]),\n                    minus(beforeOrigin, parentBeforeOrigin),\n                );\n\n                ev.datas.groupClient = childClient;\n                return { ...ev, parentRotate: 0 };\n            },\n        );\n\n        const nextParams: OnRotateGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events,\n        };\n        const result = triggerEvent(moveable, \"onRotateGroupStart\", nextParams);\n\n        datas.isRotate = result !== false;\n\n        return datas.isRotate ? params : false;\n    },\n    dragGroupControl(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas } = e;\n\n        if (!datas.isRotate) {\n            return;\n        }\n\n        catchEvent(moveable, \"onBeforeRotate\", parentEvent => {\n            triggerEvent(moveable, \"onBeforeRotateGroup\", fillParams<OnBeforeRotateGroup>(moveable, e, {\n                ...parentEvent,\n                targets: moveable.props.targets!,\n            }, true));\n        });\n        const params = this.dragControl(moveable, e);\n\n        if (!params) {\n            return;\n        }\n        const direction = datas.beforeDirection;\n        const parentRotate = params.beforeDist;\n        const deg = params.beforeDelta;\n        const rad = deg / 180 * Math.PI;\n\n        const events = triggerChildAbles(\n            moveable,\n            this,\n            \"dragControl\",\n            e,\n            (_, ev) => {\n                const [prevX, prevY] = ev.datas.groupClient;\n                const [clientX, clientY] = rotateMatrix([prevX, prevY], rad * direction);\n                const delta = [clientX - prevX, clientY - prevY];\n\n                ev.datas.groupClient = [clientX, clientY];\n                return { ...ev, parentRotate, groupDelta: delta };\n            },\n        );\n        moveable.rotation = direction * params.beforeRotation;\n\n        const nextParams: OnRotateGroup = {\n            targets: moveable.props.targets!,\n            events,\n            set(rotation: number) {\n                moveable.rotation = rotation;\n            },\n            setGroupRotation(rotation: number) {\n                moveable.rotation = rotation;\n            },\n            ...params,\n        };\n\n        triggerEvent(moveable, \"onRotateGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupControlEnd(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isRotate) {\n            return;\n        }\n\n        this.dragControlEnd(moveable, e);\n        const events = triggerChildAbles(moveable, this, \"dragControlEnd\", e);\n\n        const nextParams = fillEndParams<OnRotateGroupEnd>(moveable, e, {\n            targets: moveable.props.targets!,\n            events,\n        });\n\n        triggerEvent(moveable, \"onRotateGroupEnd\", nextParams);\n        return isDrag;\n    },\n    /**\n     * @method Moveable.Rotatable#request\n     * @param {object} [e] - the Resizable's request parameter\n     * @param {number} [e.deltaRotate=0] -  delta number of rotation\n     * @param {number} [e.rotate=0] - absolute number of moveable's rotation\n     * @return {Moveable.Requester} Moveable Requester\n     * @example\n\n     * // Instantly Request (requestStart - request - requestEnd)\n     * moveable.request(\"rotatable\", { deltaRotate: 10 }, true);\n     *\n     * * moveable.request(\"rotatable\", { rotate: 10 }, true);\n     *\n     * // requestStart\n     * const requester = moveable.request(\"rotatable\");\n     *\n     * // request\n     * requester.request({ deltaRotate: 10 });\n     * requester.request({ deltaRotate: 10 });\n     * requester.request({ deltaRotate: 10 });\n     *\n     * requester.request({ rotate: 10 });\n     * requester.request({ rotate: 20 });\n     * requester.request({ rotate: 30 });\n     *\n     * // requestEnd\n     * requester.requestEnd();\n     */\n    request(moveable: MoveableManagerInterface<RotatableProps>) {\n        const datas = {};\n        let distRotate = 0;\n\n        const startRotation = moveable.getRotation();\n        return {\n            isControl: true,\n            requestStart() {\n                return { datas };\n            },\n            request(e: IObject<any>) {\n                if (\"deltaRotate\" in e) {\n                    distRotate += e.deltaRotate;\n                } else if (\"rotate\" in e) {\n                    distRotate = e.rotate - startRotation;\n                }\n\n                return { datas, parentDist: distRotate };\n            },\n            requestEnd() {\n                return { datas, isDrag: true };\n            },\n        };\n    },\n};\n/**\n * Whether or not target can be rotated. (default: false)\n * @name Moveable.Rotatable#rotatable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.rotatable = true;\n */\n/**\n * You can specify the position of the rotation. (default: \"top\")\n * @name Moveable.Rotatable#rotationPosition\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   rotationPosition: \"top\",\n * });\n *\n * moveable.rotationPosition = \"bottom\"\n */\n\n/**\n * throttle of angle(degree) when rotate.\n * @name Moveable.Rotatable#throttleRotate\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.throttleRotate = 1;\n */\n\n/**\n * When the rotate starts, the rotateStart event is called.\n * @memberof Moveable.Rotatable\n * @event rotateStart\n * @param {Moveable.Rotatable.OnRotateStart} - Parameters for the rotateStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { rotatable: true });\n * moveable.on(\"rotateStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n\n/**\n* When rotating, the rotate event is called.\n* @memberof Moveable.Rotatable\n* @event rotate\n* @param {Moveable.Rotatable.OnRotate} - Parameters for the rotate event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, { rotatable: true });\n* moveable.on(\"rotate\", ({ target, transform, dist }) => {\n*     target.style.transform = transform;\n* });\n*/\n/**\n * When the rotate finishes, the rotateEnd event is called.\n * @memberof Moveable.Rotatable\n * @event rotateEnd\n * @param {Moveable.Rotatable.OnRotateEnd} - Parameters for the rotateEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { rotatable: true });\n * moveable.on(\"rotateEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n/**\n * When the group rotate starts, the `rotateGroupStart` event is called.\n * @memberof Moveable.Rotatable\n * @event rotateGroupStart\n * @param {Moveable.Rotatable.OnRotateGroupStart} - Parameters for the `rotateGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     rotatable: true\n * });\n * moveable.on(\"rotateGroupStart\", ({ targets }) => {\n *     console.log(\"onRotateGroupStart\", targets);\n * });\n */\n\n/**\n* When the group rotate, the `rotateGroup` event is called.\n* @memberof Moveable.Rotatable\n* @event rotateGroup\n* @param {Moveable.Rotatable.OnRotateGroup} - Parameters for the `rotateGroup` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     rotatable: true\n* });\n* moveable.on(\"rotateGroup\", ({ targets, events }) => {\n*     console.log(\"onRotateGroup\", targets);\n*     events.forEach(ev => {\n*         const target = ev.target;\n*         // ev.drag is a drag event that occurs when the group rotate.\n*         const left = ev.drag.beforeDist[0];\n*         const top = ev.drag.beforeDist[1];\n*         const deg = ev.beforeDist;\n*     });\n* });\n*/\n\n/**\n * When the group rotate finishes, the `rotateGroupEnd` event is called.\n * @memberof Moveable.Rotatable\n * @event rotateGroupEnd\n * @param {Moveable.Rotatable.OnRotateGroupEnd} - Parameters for the `rotateGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     rotatable: true\n * });\n * moveable.on(\"rotateGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onRotateGroupEnd\", targets, isDrag);\n * });\n */\n","import {\n    getDirection, triggerEvent, multiply2,\n    fillParams, fillEndParams, getAbsolutePosesByState, catchEvent, getOffsetSizeDist, getDirectionCondition,\n} from \"../utils\";\nimport { MIN_SCALE } from \"../consts\";\nimport {\n    setDragStart, resolveTransformEvent,\n    convertTransformFormat,\n    getScaleDist,\n    fillTransformStartEvent,\n    fillTransformEvent,\n    getAbsolutePosition,\n    setDefaultTransformIndex,\n    getPosByDirection,\n} from \"../gesto/GestoUtils\";\nimport { getRenderDirections } from \"../renderDirections\";\nimport {\n    ScalableProps, OnScaleGroup, OnScaleGroupEnd,\n    OnScaleGroupStart, DraggableProps, OnDragStart,\n    SnappableState, GroupableProps, OnScaleStart,\n    OnScale, OnScaleEnd, MoveableManagerInterface, MoveableGroupInterface,\n    OnBeforeScaleGroup,\n    OnBeforeScale,\n} from \"../types\";\nimport {\n    fillChildEvents,\n    triggerChildAbles,\n} from \"../groupUtils\";\nimport Draggable from \"./Draggable\";\nimport { calculate, createRotateMatrix, plus, minus } from \"@scena/matrix\";\nimport CustomGesto from \"../gesto/CustomGesto\";\nimport { checkSnapScale } from \"./Snappable\";\nimport {\n    isArray, IObject, getDist,\n    throttle,\n} from \"@daybrush/utils\";\n\nconst directionCondition = getDirectionCondition(\"scalable\");\n\n/**\n * @namespace Scalable\n * @memberof Moveable\n * @description Scalable indicates whether the target's x and y can be scale of transform.\n */\nexport default {\n    name: \"scalable\",\n    ableGroup: \"size\",\n    canPinch: true,\n    props: {\n        scalable: Boolean,\n        throttleScale: Number,\n        renderDirections: String,\n        keepRatio: Boolean,\n        edge: Boolean,\n    } as const,\n    events: {\n        onScaleStart: \"scaleStart\",\n        onBeforeScale: \"beforeScale\",\n        onScale: \"scale\",\n        onScaleEnd: \"scaleEnd\",\n        onScaleGroupStart: \"scaleGroupStart\",\n        onBeforeScaleGroup: \"beforeScaleGroup\",\n        onScaleGroup: \"scaleGroup\",\n        onScaleGroupEnd: \"scaleGroupEnd\",\n    } as const,\n    render: getRenderDirections(\"scalable\"),\n    dragControlCondition: directionCondition,\n    dragControlStart(\n        moveable: MoveableManagerInterface<ScalableProps & DraggableProps, SnappableState>,\n        e: any) {\n        const { datas, isPinch, inputEvent, parentDirection } = e;\n        const direction = parentDirection || (isPinch ? [0, 0] : getDirection(inputEvent.target));\n        const {\n            width,\n            height,\n            targetTransform,\n            target,\n            pos1,\n            pos2,\n            pos4,\n        } = moveable.state;\n\n        if (!direction || !target) {\n            return false;\n        }\n        if (!isPinch) {\n            setDragStart(moveable, e);\n        }\n        datas.datas = {};\n        datas.transform = targetTransform;\n        datas.prevDist = [1, 1];\n        datas.direction = direction;\n        datas.startOffsetWidth = width;\n        datas.startOffsetHeight = height;\n        datas.startValue = [1, 1];\n\n        const scaleWidth = getDist(pos1, pos2);\n        const scaleHeight = getDist(pos2, pos4);\n        const isWidth = (!direction[0] && !direction[1]) || direction[0] || !direction[1];\n\n\n        datas.scaleWidth = scaleWidth;\n        datas.scaleHeight = scaleHeight;\n        datas.scaleXRatio = scaleWidth / width;\n        datas.scaleYRatio = scaleHeight / height;\n\n        setDefaultTransformIndex(e, \"scale\");\n\n\n\n        datas.isWidth = isWidth;\n\n\n        function setRatio(ratio: number) {\n            datas.ratio = ratio && isFinite(ratio) ? ratio : 0;\n        }\n\n        datas.startPositions = getAbsolutePosesByState(moveable.state);\n        function setFixedDirection(fixedDirection: number[]) {\n            datas.fixedDirection = fixedDirection;\n            datas.fixedPosition = getPosByDirection(datas.startPositions, fixedDirection);\n        }\n\n\n        datas.setFixedDirection = setFixedDirection;\n        setRatio(getDist(pos1, pos2) / getDist(pos2, pos4));\n        setFixedDirection([-direction[0], -direction[1]]);\n\n        const params = fillParams<OnScaleStart>(moveable, e, {\n            direction,\n            set: (scale: number[]) => {\n                datas.startValue = scale;\n            },\n            setRatio,\n            setFixedDirection,\n            ...fillTransformStartEvent(e),\n            dragStart: Draggable.dragStart(\n                moveable,\n                new CustomGesto().dragStart([0, 0], e),\n            ) as OnDragStart,\n        });\n        const result = triggerEvent(moveable, \"onScaleStart\", params);\n\n        datas.startFixedDirection = datas.fixedDirection;\n\n        if (result !== false) {\n            datas.isScale = true;\n            moveable.state.snapRenderInfo = {\n                request: e.isRequest,\n                direction,\n            };\n\n        }\n        return datas.isScale ? params : false;\n    },\n    dragControl(\n        moveable: MoveableManagerInterface<ScalableProps & DraggableProps & GroupableProps, SnappableState>,\n        e: any) {\n        resolveTransformEvent(e, \"scale\");\n        const {\n            datas,\n            parentKeepRatio,\n            parentFlag, isPinch,\n            dragClient,\n            isRequest,\n        } = e;\n        const {\n            prevDist,\n            direction,\n            startOffsetWidth,\n            startOffsetHeight,\n            isScale,\n            startValue,\n            isWidth,\n            ratio,\n        } = datas;\n\n        if (!isScale) {\n            return false;\n        }\n\n        const props = moveable.props;\n        const {\n            throttleScale,\n            parentMoveable,\n        } = props;\n        let sizeDirection = direction;\n\n        if (!direction[0] && !direction[1]) {\n            sizeDirection = [1, 1];\n        }\n        const keepRatio = (ratio && (parentKeepRatio != null ? parentKeepRatio : props.keepRatio)) || false;\n        const state = moveable.state;\n\n        function getNextScale() {\n            const {\n                distWidth,\n                distHeight,\n            } = getOffsetSizeDist(sizeDirection, keepRatio, datas, e);\n\n\n            let scaleX = (startOffsetWidth + distWidth) / startOffsetWidth;\n            let scaleY = (startOffsetHeight + distHeight) / startOffsetHeight;\n\n            scaleX = sizeDirection[0] || keepRatio ? scaleX * startValue[0] : startValue[0];\n            scaleY = sizeDirection[1] || keepRatio ? scaleY * startValue[1] : startValue[1];\n\n            if (scaleX === 0) {\n                scaleX = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;\n            }\n            if (scaleY === 0) {\n                scaleY = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;\n            }\n            return [scaleX, scaleY];\n        }\n\n\n        let scale = getNextScale();\n\n        if (!isPinch && moveable.props.groupable) {\n            const snapRenderInfo = state.snapRenderInfo || {};\n            const stateDirection = snapRenderInfo.direction;\n\n            if (isArray(stateDirection) && (stateDirection[0] || stateDirection[1])) {\n                state.snapRenderInfo = { direction, request: e.isRequest };\n            }\n        }\n\n        triggerEvent(moveable, \"onBeforeScale\", fillParams<OnBeforeScale>(moveable, e, {\n            scale,\n            setFixedDirection(nextFixedDirection: number[]) {\n                datas.setFixedDirection(nextFixedDirection);\n\n                scale = getNextScale();\n\n                return scale;\n            },\n            startFixedDirection: datas.startFixedDirection,\n            setScale(nextScale: number[]) {\n                scale = nextScale;\n            },\n        }, true));\n\n        const dist = [scale[0] / startValue[0], scale[1] / startValue[1]];\n        let fixedPosition = dragClient;\n        let snapDist = [0, 0];\n\n\n        if (!dragClient) {\n            if (!parentFlag && isPinch) {\n                fixedPosition = getAbsolutePosition(moveable, [0, 0]);\n            } else {\n                fixedPosition = datas.fixedPosition;\n            }\n        }\n        if (!isPinch) {\n            snapDist = checkSnapScale(\n                moveable,\n                dist,\n                direction,\n                isRequest,\n                datas,\n            );\n        }\n\n        if (keepRatio) {\n            if (sizeDirection[0] && sizeDirection[1] && snapDist[0] && snapDist[1]) {\n                if (Math.abs(snapDist[0] * startOffsetWidth) > Math.abs(snapDist[1] * startOffsetHeight)) {\n                    snapDist[1] = 0;\n                } else {\n                    snapDist[0] = 0;\n                }\n            }\n\n            const isNoSnap = !snapDist[0] && !snapDist[1];\n\n            if (isNoSnap) {\n                if (isWidth) {\n                    dist[0] = throttle(dist[0] * startValue[0], throttleScale!) / startValue[0];\n                } else {\n                    dist[1] = throttle(dist[1] * startValue[1], throttleScale!) / startValue[1];\n                }\n            }\n            if (\n                (sizeDirection[0] && !sizeDirection[1])\n                || (snapDist[0] && !snapDist[1])\n                || (isNoSnap && isWidth)\n            ) {\n                dist[0] += snapDist[0];\n                const snapHeight = startOffsetWidth * dist[0] * startValue[0] / ratio;\n\n                dist[1] = snapHeight / startOffsetHeight / startValue[1];\n            } else if (\n                (!sizeDirection[0] && sizeDirection[1])\n                || (!snapDist[0] && snapDist[1])\n                || (isNoSnap && !isWidth)\n            ) {\n                dist[1] += snapDist[1];\n                const snapWidth = startOffsetHeight * dist[1] * startValue[1] * ratio;\n\n                dist[0] = snapWidth / startOffsetWidth / startValue[0];\n            }\n        } else {\n            dist[0] += snapDist[0];\n            dist[1] += snapDist[1];\n            if (!snapDist[0]) {\n                dist[0] = throttle(dist[0] * startValue[0], throttleScale!) / startValue[0];\n            }\n            if (!snapDist[1]) {\n                dist[1] = throttle(dist[1] * startValue[1], throttleScale!) / startValue[1];\n            }\n        }\n\n        if (dist[0] === 0) {\n            dist[0] = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;\n        }\n        if (dist[1] === 0) {\n            dist[1] = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;\n        }\n        const delta = [dist[0] / prevDist[0], dist[1] / prevDist[1]];\n        scale = multiply2(dist, startValue);\n\n        const inverseDist = getScaleDist(moveable, dist, datas.fixedDirection, fixedPosition, datas);\n        const inverseDelta = minus(inverseDist, datas.prevInverseDist || [0, 0]);\n\n        datas.prevDist = dist;\n        datas.prevInverseDist = inverseDist;\n        if (\n            scale[0] === prevDist[0] && scale[1] === prevDist[1]\n            && inverseDelta.every(num => !num)\n            && !parentMoveable\n        ) {\n            return false;\n        }\n\n\n        const nextTransform = convertTransformFormat(\n            datas, `scale(${scale.join(\", \")})`, `scale(${dist.join(\", \")})`);\n        const params = fillParams<OnScale>(moveable, e, {\n            offsetWidth: startOffsetWidth,\n            offsetHeight: startOffsetHeight,\n            direction,\n\n            scale,\n            dist,\n            delta,\n\n            isPinch: !!isPinch,\n            ...fillTransformEvent(\n                moveable,\n                nextTransform,\n                inverseDelta,\n                isPinch,\n                e,\n            ),\n        });\n        triggerEvent(moveable, \"onScale\", params);\n\n        return params;\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<ScalableProps>, e: any) {\n        const { datas, isDrag } = e;\n        if (!datas.isScale) {\n            return false;\n        }\n\n        datas.isScale = false;\n\n        triggerEvent(moveable, \"onScaleEnd\", fillEndParams<OnScaleEnd>(moveable, e, {}));\n        return isDrag;\n    },\n    dragGroupControlCondition: directionCondition,\n    dragGroupControlStart(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas } = e;\n\n        const params = this.dragControlStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n        const originalEvents = fillChildEvents(moveable, \"resizable\", e);\n\n        function setDist(child: MoveableManagerInterface, ev: any) {\n            const fixedDirection = datas.fixedDirection;\n            const fixedPosition = datas.fixedPosition;\n            const startPositions = ev.datas.startPositions || getAbsolutePosesByState(child.state);\n            const pos = getPosByDirection(startPositions, fixedDirection);\n            const [originalX, originalY] = calculate(\n                createRotateMatrix(-moveable.rotation / 180 * Math.PI, 3),\n                [pos[0] - fixedPosition[0], pos[1] - fixedPosition[1], 1],\n                3,\n            );\n            ev.datas.originalX = originalX;\n            ev.datas.originalY = originalY;\n\n            return ev;\n        }\n\n        datas.moveableScale = moveable.scale;\n\n        const events = triggerChildAbles(\n            moveable,\n            this,\n            \"dragControlStart\",\n            e,\n            (child, ev) => {\n                return setDist(child, ev);\n            },\n        );\n\n        const setFixedDirection = (fixedDirection: number[]) => {\n            params.setFixedDirection(fixedDirection);\n            events.forEach((ev, i) => {\n                ev.setFixedDirection(fixedDirection);\n                setDist(ev.moveable, originalEvents[i]);\n            });\n        };\n\n        datas.setFixedDirection = setFixedDirection;\n        const nextParams: OnScaleGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events,\n            setFixedDirection,\n        };\n        const result = triggerEvent(moveable, \"onScaleGroupStart\", nextParams);\n\n        datas.isScale = result !== false;\n        return datas.isScale ? nextParams : false;\n    },\n    dragGroupControl(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas } = e;\n        if (!datas.isScale) {\n            return;\n        }\n\n        catchEvent(moveable, \"onBeforeScale\", parentEvent => {\n            triggerEvent(moveable, \"onBeforeScaleGroup\", fillParams<OnBeforeScaleGroup>(moveable, e, {\n                ...parentEvent,\n                targets: moveable.props.targets!,\n            }, true));\n        });\n\n        const params = this.dragControl(moveable, e);\n        if (!params) {\n            return;\n        }\n\n        const moveableScale = datas.moveableScale;\n        moveable.scale = [\n            params.scale[0] * moveableScale[0],\n            params.scale[1] * moveableScale[1],\n        ];\n        const keepRatio = moveable.props.keepRatio;\n        const { dist, scale } = params;\n\n        const fixedPosition = datas.fixedPosition;\n\n        const events = triggerChildAbles(\n            moveable,\n            this,\n            \"dragControl\",\n            e,\n            (_, ev) => {\n                const [clientX, clientY] = calculate(\n                    createRotateMatrix(moveable.rotation / 180 * Math.PI, 3),\n                    [\n                        ev.datas.originalX * dist[0],\n                        ev.datas.originalY * dist[1],\n                        1,\n                    ],\n                    3,\n                );\n\n                return {\n                    ...ev,\n                    parentDist: null,\n                    parentScale: scale,\n                    parentKeepRatio: keepRatio,\n                    dragClient: plus(fixedPosition, [clientX, clientY]),\n                };\n            },\n        );\n        const nextParams: OnScaleGroup = {\n            targets: moveable.props.targets!,\n            events,\n            ...params,\n        };\n\n        triggerEvent(moveable, \"onScaleGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupControlEnd(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isScale) {\n            return;\n        }\n        this.dragControlEnd(moveable, e);\n        const events = triggerChildAbles(moveable, this, \"dragControlEnd\", e);\n\n        const nextParams = fillEndParams<OnScaleGroupEnd>(moveable, e, {\n            targets: moveable.props.targets!,\n            events,\n        });\n\n        triggerEvent(moveable, \"onScaleGroupEnd\", nextParams);\n        return isDrag;\n    },\n    /**\n     * @method Moveable.Scalable#request\n     * @param {Moveable.Scalable.ScalableRequestParam} e - the Scalable's request parameter\n     * @return {Moveable.Requester} Moveable Requester\n     * @example\n\n     * // Instantly Request (requestStart - request - requestEnd)\n     * moveable.request(\"scalable\", { deltaWidth: 10, deltaHeight: 10 }, true);\n     *\n     * // requestStart\n     * const requester = moveable.request(\"scalable\");\n     *\n     * // request\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     *\n     * // requestEnd\n     * requester.requestEnd();\n     */\n    request() {\n        const datas = {};\n        let distWidth = 0;\n        let distHeight = 0;\n\n        return {\n            isControl: true,\n            requestStart(e: IObject<any>) {\n                return { datas, parentDirection: e.direction || [1, 1] };\n            },\n            request(e: IObject<any>) {\n                distWidth += e.deltaWidth;\n                distHeight += e.deltaHeight;\n\n                return { datas, parentDist: [distWidth, distHeight], parentKeepRatio: e.keepRatio };\n            },\n            requestEnd() {\n                return { datas, isDrag: true };\n            },\n        };\n    },\n};\n\n/**\n * Whether or not target can scaled.\n *\n * @name Moveable.Scalable#scalable\n * @default false\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.scalable = true;\n */\n\n/**\n * throttle of scaleX, scaleY when scale.\n * @name Moveable.Scalable#throttleScale\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.throttleScale = 0.1;\n */\n/**\n * Set directions to show the control box. (default: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"])\n * @name Moveable.Scalable#renderDirections\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     scalable: true,\n *   renderDirections: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"],\n * });\n *\n * moveable.renderDirections = [\"nw\", \"ne\", \"sw\", \"se\"];\n */\n/**\n * When resize or scale, keeps a ratio of the width, height. (default: false)\n * @name Moveable.Scalable#keepRatio\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     scalable: true,\n * });\n *\n * moveable.keepRatio = true;\n */\n/**\n * When the scale starts, the scaleStart event is called.\n * @memberof Moveable.Scalable\n * @event scaleStart\n * @param {Moveable.Scalable.OnScaleStart} - Parameters for the scaleStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { scalable: true });\n * moveable.on(\"scaleStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When scaling, `beforeScale` is called before `scale` occurs. In `beforeScale`, you can get and set the pre-value before scaling.\n * @memberof Moveable.Scalable\n * @event beforeScale\n * @param {Moveable.Scalable.OnBeforeScale} - Parameters for the `beforeScale` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { scalable: true });\n * moveable.on(\"beforeScale\", ({ setFixedDirection }) => {\n *     if (shiftKey) {\n *        setFixedDirection([0, 0]);\n *     }\n * });\n * moveable.on(\"scale\", ({ target, transform, dist }) => {\n *     target.style.transform = transform;\n * });\n */\n\n/**\n * When scaling, the `scale` event is called.\n * @memberof Moveable.Scalable\n * @event scale\n * @param {Moveable.Scalable.OnScale} - Parameters for the `scale` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { scalable: true });\n * moveable.on(\"scale\", ({ target, transform, dist }) => {\n *     target.style.transform = transform;\n * });\n */\n/**\n * When the scale finishes, the `scaleEnd` event is called.\n * @memberof Moveable.Scalable\n * @event scaleEnd\n * @param {Moveable.Scalable.OnScaleEnd} - Parameters for the `scaleEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { scalable: true });\n * moveable.on(\"scaleEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n/**\n* When the group scale starts, the `scaleGroupStart` event is called.\n* @memberof Moveable.Scalable\n* @event scaleGroupStart\n* @param {Moveable.Scalable.OnScaleGroupStart} - Parameters for the `scaleGroupStart` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     scalable: true\n* });\n* moveable.on(\"scaleGroupStart\", ({ targets }) => {\n*     console.log(\"onScaleGroupStart\", targets);\n* });\n*/\n\n/**\n* When the group scale, the `scaleGroup` event is called.\n* @memberof Moveable.Scalable\n* @event scaleGroup\n* @param {Moveable.Scalable.OnScaleGroup} - Parameters for the `scaleGroup` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     scalable: true\n* });\n* moveable.on(\"scaleGroup\", ({ targets, events }) => {\n*     console.log(\"onScaleGroup\", targets);\n*     events.forEach(ev => {\n*         const target = ev.target;\n*         // ev.drag is a drag event that occurs when the group scale.\n*         const left = ev.drag.beforeDist[0];\n*         const top = ev.drag.beforeDist[1];\n*         const scaleX = ev.scale[0];\n*         const scaleY = ev.scale[1];\n*     });\n* });\n*/\n\n/**\n * When the group scale finishes, the `scaleGroupEnd` event is called.\n * @memberof Moveable.Scalable\n * @event scaleGroupEnd\n * @param {Moveable.Scalable.OnScaleGroupEnd} - Parameters for the `scaleGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     scalable: true\n * });\n * moveable.on(\"scaleGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onScaleGroupEnd\", targets, isDrag);\n * });\n */\n","import {\n    prefix, getLineStyle, getDirection, getAbsolutePosesByState,\n    triggerEvent, fillParams, fillEndParams,\n} from \"../utils\";\nimport {\n    convertDimension, invert, multiply,\n    calculate,\n    createIdentityMatrix,\n    ignoreDimension,\n    minus,\n    createWarpMatrix,\n    plus,\n} from \"@scena/matrix\";\nimport { NEARBY_POS } from \"../consts\";\nimport {\n    setDragStart, getDragDist, getPosIndexesByDirection, setDefaultTransformIndex,\n    fillTransformStartEvent, resolveTransformEvent,\n    convertTransformFormat, fillOriginalTransform, getTransfromMatrix,\n} from \"../gesto/GestoUtils\";\nimport {\n    WarpableProps, ScalableProps, ResizableProps,\n    Renderer, SnappableProps, SnappableState,\n    OnWarpStart, OnWarp, OnWarpEnd, MoveableManagerInterface,\n} from \"../types\";\nimport { hasClass, dot, getRad } from \"@daybrush/utils\";\nimport { renderAllDirections } from \"../renderDirections\";\nimport { hasGuidelines } from \"./snappable/utils\";\nimport { checkMoveableSnapBounds } from \"./snappable/snapBounds\";\n\nfunction getMiddleLinePos(pos1: number[], pos2: number[]) {\n    return pos1.map((pos, i) => dot(pos, pos2[i], 1, 2));\n}\n\nfunction getTriangleRad(pos1: number[], pos2: number[], pos3: number[]) {\n    // pos1 Rad\n    const rad1 = getRad(pos1, pos2);\n    const rad2 = getRad(pos1, pos3);\n\n    const rad = rad2 - rad1;\n\n    return rad >= 0 ? rad : rad + 2 * Math.PI;\n}\n\nfunction isValidPos(poses1: number[][], poses2: number[][]) {\n    const rad1 = getTriangleRad(poses1[0], poses1[1], poses1[2]);\n    const rad2 = getTriangleRad(poses2[0], poses2[1], poses2[2]);\n    const pi = Math.PI;\n\n    if ((rad1 >= pi && rad2 <= pi) || (rad1 <= pi && rad2 >= pi)) {\n        return false;\n    }\n    return true;\n}\n\n/**\n * @namespace Moveable.Warpable\n * @description Warpable indicates whether the target can be warped(distorted, bented).\n */\nexport default {\n    name: \"warpable\",\n    ableGroup: \"size\",\n    props: {\n        warpable: Boolean,\n        renderDirections: Array,\n        edge: Boolean,\n    } as const,\n    events: {\n        onWarpStart: \"warpStart\",\n        onWarp: \"warp\",\n        onWarpEnd: \"warpEnd\",\n    } as const,\n    render(moveable: MoveableManagerInterface<ResizableProps & ScalableProps & WarpableProps>, React: Renderer): any[] {\n        const { resizable, scalable, warpable, zoom } = moveable.props;\n\n        if (resizable || scalable || !warpable) {\n            return [];\n        }\n        const { pos1, pos2, pos3, pos4 } = moveable.state;\n\n        const linePosFrom1 = getMiddleLinePos(pos1, pos2);\n        const linePosFrom2 = getMiddleLinePos(pos2, pos1);\n        const linePosFrom3 = getMiddleLinePos(pos1, pos3);\n        const linePosFrom4 = getMiddleLinePos(pos3, pos1);\n        const linePosTo1 = getMiddleLinePos(pos3, pos4);\n        const linePosTo2 = getMiddleLinePos(pos4, pos3);\n        const linePosTo3 = getMiddleLinePos(pos2, pos4);\n        const linePosTo4 = getMiddleLinePos(pos4, pos2);\n\n        return [\n            <div className={prefix(\"line\")}\n                key=\"middeLine1\" style={getLineStyle(linePosFrom1, linePosTo1, zoom)}></div>,\n            <div className={prefix(\"line\")}\n                key=\"middeLine2\" style={getLineStyle(linePosFrom2, linePosTo2, zoom)}></div>,\n            <div className={prefix(\"line\")}\n                key=\"middeLine3\" style={getLineStyle(linePosFrom3, linePosTo3, zoom)}></div>,\n            <div className={prefix(\"line\")}\n                key=\"middeLine4\" style={getLineStyle(linePosFrom4, linePosTo4, zoom)}></div>,\n            ...renderAllDirections(moveable, \"warpable\", React),\n        ];\n    },\n    dragControlCondition(moveable: any, e: any) {\n        if (e.isRequest) {\n            return false;\n        }\n        const target = e.inputEvent.target;\n\n        return hasClass(target, prefix(\"direction\")) && hasClass(target, prefix(\"warpable\"));\n    },\n    dragControlStart(\n        moveable: MoveableManagerInterface<WarpableProps, SnappableState>,\n        e: any,\n    ) {\n        const { datas, inputEvent } = e;\n        const { target } = moveable.props;\n        const { target: inputTarget } = inputEvent;\n        const direction = getDirection(inputTarget);\n\n        if (!direction || !target) {\n            return false;\n        }\n        const state = moveable.state;\n        const {\n            transformOrigin, is3d,\n            targetTransform, targetMatrix,\n            width, height,\n            left, top,\n        } = state;\n\n        datas.datas = {};\n        datas.targetTransform = targetTransform;\n        datas.warpTargetMatrix = is3d ? targetMatrix : convertDimension(targetMatrix, 3, 4);\n        datas.targetInverseMatrix = ignoreDimension(invert(datas.warpTargetMatrix, 4), 3, 4);\n        datas.direction = direction;\n        datas.left = left;\n        datas.top = top;\n        datas.poses = [\n            [0, 0],\n            [width, 0],\n            [0, height],\n            [width, height],\n        ].map(p => minus(p, transformOrigin));\n\n        datas.nextPoses = datas.poses.map(([x, y]: number[]) => calculate(datas.warpTargetMatrix, [x, y, 0, 1], 4));\n        datas.startValue = createIdentityMatrix(4);\n        datas.prevMatrix = createIdentityMatrix(4);\n        datas.absolutePoses = getAbsolutePosesByState(state);\n        datas.posIndexes = getPosIndexesByDirection(direction);\n\n        setDragStart(moveable, e);\n        setDefaultTransformIndex(e, \"matrix3d\");\n\n        state.snapRenderInfo = {\n            request: e.isRequest,\n            direction,\n        };\n\n        const params = fillParams<OnWarpStart>(moveable, e, {\n            set: (matrix: number[]) => {\n                datas.startValue = matrix;\n            },\n            ...fillTransformStartEvent(e),\n        });\n        const result = triggerEvent(moveable, \"onWarpStart\", params);\n        if (result !== false) {\n            datas.isWarp = true;\n        }\n        return datas.isWarp;\n    },\n    dragControl(\n        moveable: MoveableManagerInterface<WarpableProps & SnappableProps, SnappableState>,\n        e: any,\n    ) {\n        const { datas, isRequest } = e;\n        let { distX, distY } = e;\n        const {\n            targetInverseMatrix, prevMatrix, isWarp, startValue,\n            poses,\n            posIndexes,\n            absolutePoses,\n        } = datas;\n\n        if (!isWarp) {\n            return false;\n        }\n        resolveTransformEvent(e, \"matrix3d\");\n        if (hasGuidelines(moveable, \"warpable\")) {\n            const selectedPoses: number[][] = posIndexes.map((index: number) => absolutePoses[index]);\n\n            if (selectedPoses.length > 1) {\n                selectedPoses.push([\n                    (selectedPoses[0][0] + selectedPoses[1][0]) / 2,\n                    (selectedPoses[0][1] + selectedPoses[1][1]) / 2,\n                ]);\n            }\n\n            const {\n                horizontal: horizontalSnapInfo,\n                vertical: verticalSnapInfo,\n            } = checkMoveableSnapBounds(\n                moveable,\n                isRequest,\n                {\n                    horizontal: selectedPoses.map(pos => pos[1] + distY),\n                    vertical: selectedPoses.map(pos => pos[0] + distX),\n                },\n            );\n\n            distY -= horizontalSnapInfo.offset;\n            distX -= verticalSnapInfo.offset;\n        }\n\n        const dist = getDragDist({ datas, distX, distY }, true);\n        const nextPoses = datas.nextPoses.slice();\n\n        posIndexes.forEach((index: number) => {\n            nextPoses[index] = plus(nextPoses[index], dist);\n        });\n\n        if (!NEARBY_POS.every(\n            nearByPoses => isValidPos(nearByPoses.map(i => poses[i]), nearByPoses.map(i => nextPoses[i])),\n        )) {\n            return false;\n        }\n        const h = createWarpMatrix(\n            poses[0],\n            poses[2],\n            poses[1],\n            poses[3],\n            nextPoses[0],\n            nextPoses[2],\n            nextPoses[1],\n            nextPoses[3],\n        );\n\n        if (!h.length) {\n            return false;\n        }\n        // B * A * M\n        const afterMatrix = multiply(targetInverseMatrix, h, 4);\n\n        // B * M * A\n        const matrix = getTransfromMatrix(datas, afterMatrix, true);\n\n        const delta = multiply(invert(prevMatrix, 4), matrix, 4);\n\n        datas.prevMatrix = matrix;\n        const totalMatrix = multiply(startValue, matrix, 4);\n        const nextTransform = convertTransformFormat(\n            datas, `matrix3d(${totalMatrix.join(\", \")})`, `matrix3d(${matrix.join(\", \")})`);\n\n        fillOriginalTransform(e, nextTransform);\n        triggerEvent(moveable, \"onWarp\", fillParams<OnWarp>(moveable, e, {\n            delta,\n            matrix: totalMatrix,\n            dist: matrix,\n            multiply,\n            transform: nextTransform,\n        }));\n        return true;\n    },\n    dragControlEnd(\n        moveable: MoveableManagerInterface<WarpableProps>,\n        e: any,\n    ) {\n        const { datas, isDrag } = e;\n        if (!datas.isWarp) {\n            return false;\n        }\n        datas.isWarp = false;\n\n        triggerEvent(moveable, \"onWarpEnd\", fillEndParams<OnWarpEnd>(moveable, e, {}));\n        return isDrag;\n    },\n};\n\n/**\n * Whether or not target can be warped. (default: false)\n * @name Moveable.Warpable#warpable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.warpable = true;\n */\n\n/**\n* Set directions to show the control box. (default: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"])\n* @name Moveable.Warpable#renderDirections\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     warpable: true,\n*     renderDirections: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"],\n* });\n*\n* moveable.renderDirections = [\"nw\", \"ne\", \"sw\", \"se\"];\n*/\n/**\n* When the warp starts, the warpStart event is called.\n* @memberof Moveable.Warpable\n* @event warpStart\n* @param {Moveable.Warpable.OnWarpStart} - Parameters for the warpStart event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, { warpable: true });\n* moveable.on(\"warpStart\", ({ target }) => {\n*     console.log(target);\n* });\n*/\n/**\n * When warping, the warp event is called.\n * @memberof Moveable.Warpable\n * @event warp\n * @param {Moveable.Warpable.OnWarp} - Parameters for the warp event\n * @example\n * import Moveable from \"moveable\";\n * let matrix = [\n *  1, 0, 0, 0,\n *  0, 1, 0, 0,\n *  0, 0, 1, 0,\n *  0, 0, 0, 1,\n * ];\n * const moveable = new Moveable(document.body, { warpable: true });\n * moveable.on(\"warp\", ({ target, transform, delta, multiply }) => {\n *    // target.style.transform = transform;\n *    matrix = multiply(matrix, delta);\n *    target.style.transform = `matrix3d(${matrix.join(\",\")})`;\n * });\n */\n/**\n * When the warp finishes, the warpEnd event is called.\n * @memberof Moveable.Warpable\n * @event warpEnd\n * @param {Moveable.Warpable.OnWarpEnd} - Parameters for the warpEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { warpable: true });\n * moveable.on(\"warpEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n","import { prefix } from \"./utils\";\n\nexport const AREA_PIECES = /*#__PURE__*/prefix(\"area-pieces\");\nexport const AREA_PIECE = /*#__PURE__*/prefix(\"area-piece\");\nexport const AVOID = /*#__PURE__*/prefix(\"avoid\");\n","import {\n    createWarpMatrix,\n} from \"@scena/matrix\";\nimport { ref } from \"framework-utils\";\nimport { getRect, calculateInversePosition, makeMatrixCSS, prefix } from \"../utils\";\nimport {\n    Renderer, GroupableProps, DragAreaProps, MoveableManagerInterface, MoveableGroupInterface,\n} from \"../types\";\nimport { AREA_PIECE, AVOID, AREA_PIECES } from \"../classNames\";\nimport { addClass, removeClass, requestAnimationFrame } from \"@daybrush/utils\";\n\nfunction restoreStyle(moveable: MoveableManagerInterface) {\n    const el = moveable.areaElement;\n\n    if (!el) {\n        return;\n    }\n    const { width, height } = moveable.state;\n\n    removeClass(el, AVOID);\n\n    el.style.cssText += `left: 0px; top: 0px; width: ${width}px; height: ${height}px`;\n}\n\nfunction renderPieces(React: Renderer): any {\n    return (<div key=\"area_pieces\" className={AREA_PIECES}>\n        <div className={AREA_PIECE}></div>\n        <div className={AREA_PIECE}></div>\n        <div className={AREA_PIECE}></div>\n        <div className={AREA_PIECE}></div>\n    </div>);\n}\nexport default {\n    name: \"dragArea\",\n    props: {\n        dragArea: Boolean,\n        passDragArea: Boolean,\n    } as const,\n    events: {\n        onClick: \"click\",\n        onClickGroup: \"clickGroup\",\n    } as const,\n    render(moveable: MoveableManagerInterface<GroupableProps>, React: Renderer): any[] {\n        const { target, dragArea, groupable, passDragArea } = moveable.props;\n        const { width, height, renderPoses } = moveable.state;\n\n        const className = passDragArea ? prefix(\"area\", \"pass\") : prefix(\"area\");\n        if (groupable) {\n            return [\n                <div key=\"area\" ref={ref(moveable, \"areaElement\")} className={className}></div>,\n                renderPieces(React),\n            ];\n        }\n        if (!target || !dragArea) {\n            return [];\n        }\n        const h = createWarpMatrix(\n            [0, 0],\n            [width, 0],\n            [0, height],\n            [width, height],\n            renderPoses[0],\n            renderPoses[1],\n            renderPoses[2],\n            renderPoses[3],\n        );\n        const transform = h.length ? makeMatrixCSS(h, true) : \"none\";\n\n        return [\n            <div key=\"area\" ref={ref(moveable, \"areaElement\")} className={className} style={{\n                top: \"0px\",\n                left: \"0px\",\n                width: `${width}px`,\n                height: `${height}px`,\n                transformOrigin: \"0 0\",\n                transform,\n            }}></div>,\n            renderPieces(React),\n        ];\n    },\n    dragStart(moveable: MoveableManagerInterface, { datas, clientX, clientY, inputEvent }: any) {\n        if (!inputEvent) {\n            return false;\n        }\n        datas.isDragArea = false;\n        const areaElement = moveable.areaElement;\n        const state = moveable.state;\n        const {\n            moveableClientRect,\n            renderPoses,\n            rootMatrix,\n            is3d,\n        } = state;\n        const { left, top } = moveableClientRect;\n        const {\n            left: relativeLeft,\n            top: relativeTop,\n            width,\n            height,\n        } = getRect(renderPoses);\n        const n = is3d ? 4 : 3;\n        let [posX, posY] = calculateInversePosition(rootMatrix, [clientX - left, clientY - top], n);\n\n        posX -= relativeLeft;\n        posY -= relativeTop;\n        const rects = [\n            { left: relativeLeft, top: relativeTop, width, height: posY - 10 },\n            { left: relativeLeft, top: relativeTop, width: posX - 10, height },\n            { left: relativeLeft, top: relativeTop + posY + 10, width, height: height - posY - 10 },\n            { left: relativeLeft + posX + 10, top: relativeTop, width: width - posX - 10, height },\n        ];\n\n        const children = [].slice.call(areaElement.nextElementSibling!.children) as HTMLElement[];\n        rects.forEach((rect, i) => {\n            children[i].style.cssText\n                = `left: ${rect.left}px;top: ${rect.top}px; width: ${rect.width}px; height: ${rect.height}px;`;\n        });\n        addClass(areaElement, AVOID);\n        state.disableNativeEvent = true;\n        return;\n    },\n    drag(moveable: MoveableManagerInterface, { datas, inputEvent }: any) {\n        this.enableNativeEvent(moveable);\n        if (!inputEvent) {\n            return false;\n        }\n        if (!datas.isDragArea) {\n            datas.isDragArea = true;\n            restoreStyle(moveable);\n        }\n    },\n    dragEnd(moveable: MoveableManagerInterface<DragAreaProps>, e: any) {\n        this.enableNativeEvent(moveable);\n        const { inputEvent, datas } = e;\n        if (!inputEvent) {\n            return false;\n        }\n        if (!datas.isDragArea) {\n            restoreStyle(moveable);\n        }\n    },\n    dragGroupStart(moveable: MoveableGroupInterface, e: any) {\n        return this.dragStart(moveable, e);\n    },\n    dragGroup(moveable: MoveableGroupInterface, e: any) {\n        return this.drag(moveable, e);\n    },\n    dragGroupEnd(\n        moveable: MoveableGroupInterface<DragAreaProps>,\n        e: any,\n    ) {\n        return this.dragEnd(moveable, e);\n    },\n    unset(moveable: MoveableManagerInterface<DragAreaProps>) {\n        restoreStyle(moveable);\n        moveable.state.disableNativeEvent = false;\n    },\n    enableNativeEvent(moveable: MoveableManagerInterface<DragAreaProps>) {\n        const state = moveable.state;\n        if (state.disableNativeEvent) {\n            requestAnimationFrame(() => {\n                state.disableNativeEvent = false;\n            });\n        }\n    },\n};\n\n/**\n * Add an event to the moveable area instead of the target for stopPropagation. (default: false, true in group)\n * @name Moveable#dragArea\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  dragArea: false,\n * });\n */\n/**\n * Set `pointerEvents: none;` css to pass events in dragArea. (default: false)\n * @name Moveable#passDragArea\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  dragArea: false,\n * });\n */\n","import { prefix, getControlTransform } from \"../utils\";\nimport { Renderer, OriginOptions, MoveableManagerInterface } from \"../types\";\nimport { makeAble } from \"./AbleManager\";\n\nexport default makeAble(\"origin\", {\n    render(moveable: MoveableManagerInterface<OriginOptions>, React: Renderer): any[] {\n        const { zoom } = moveable.props;\n        const { beforeOrigin, rotation } = moveable.state;\n\n        return [\n            <div className={prefix(\"control\", \"origin\")}\n                style={getControlTransform(rotation, zoom!, beforeOrigin)} key=\"beforeOrigin\"></div>,\n        ];\n    },\n});\n\n/**\n * Whether or not the origin controlbox will be visible or not (default: true)\n * @name Moveable#origin\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.origin = true;\n */\n","\nimport { ScrollableProps, OnScroll, MoveableManagerInterface, MoveableGroupInterface } from \"../types\";\nimport { triggerEvent, fillParams, getRefTarget } from \"../utils\";\nimport DragScroll from \"@scena/dragscroll\";\n\nfunction getDefaultScrollPosition(e: { scrollContainer: HTMLElement, direction: number[] }) {\n    const scrollContainer = e.scrollContainer;\n\n    return [\n        scrollContainer.scrollLeft,\n        scrollContainer.scrollTop,\n    ];\n}\n/**\n * @namespace Moveable.Scrollable\n * @description Whether or not target can be scrolled to the scroll container (default: false)\n */\nexport default {\n    name: \"scrollable\",\n    canPinch: true,\n    props: {\n        scrollable: Boolean,\n        scrollContainer: Object,\n        scrollThreshold: Number,\n        getScrollPosition: Function,\n    } as const,\n    events: {\n        onScroll: \"scroll\",\n        onScrollGroup: \"scrollGroup\",\n    } as const,\n    dragRelation: \"strong\",\n    dragStart(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        const props = moveable.props;\n        const {\n            scrollContainer = moveable.getContainer() as HTMLElement,\n        } = props;\n\n        const dragScroll = new DragScroll();\n        const scrollContainerElement = getRefTarget<HTMLElement>(scrollContainer, true);\n\n        e.datas.dragScroll = dragScroll;\n\n        const gestoName = e.isControl ? \"controlGesto\" : \"targetGesto\";\n        const targets = e.targets;\n\n        dragScroll.on(\"scroll\", ({ container, direction }) => {\n            const params = fillParams<OnScroll>(moveable, e, {\n                scrollContainer: container,\n                direction,\n            }) as any;\n\n            const eventName = targets ? \"onScrollGroup\" : \"onScroll\" as any;\n            if (targets) {\n                params.targets = targets;\n            }\n            triggerEvent(moveable, eventName, params);\n        }).on(\"move\", ({ offsetX, offsetY }) => {\n            moveable[gestoName].scrollBy(offsetX, offsetY, e.inputEvent, false);\n        });\n        dragScroll.dragStart(e, {\n            container: scrollContainerElement!,\n        });\n    },\n    checkScroll(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        const {\n            dragScroll,\n        } = e.datas;\n        if (!dragScroll) {\n            return;\n        }\n        const {\n            scrollContainer = moveable.getContainer(),\n            scrollThreshold = 0,\n            getScrollPosition = getDefaultScrollPosition,\n        } = moveable.props;\n\n        dragScroll.drag(e, {\n            container: scrollContainer,\n            threshold: scrollThreshold,\n            getScrollPosition: (ev: any) => {\n                return getScrollPosition({ scrollContainer: ev.container, direction: ev.direction });\n            },\n        });\n\n        return true;\n    },\n    drag(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        return this.checkScroll(moveable, e);\n    },\n    dragEnd(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        e.datas.dragScroll.dragEnd();\n        e.datas.dragScroll = null;\n    },\n    dragControlStart(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        return this.dragStart(moveable, { ...e, isControl: true });\n    },\n    dragControl(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        return this.drag(moveable, e);\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        return this.dragEnd(moveable, e);\n    },\n    dragGroupStart(moveable: MoveableGroupInterface, e: any) {\n        return this.dragStart(moveable, { ...e, targets: moveable.props.targets });\n    },\n    dragGroup(moveable: MoveableGroupInterface, e: any) {\n        return this.drag(moveable, { ...e, targets: moveable.props.targets });\n    },\n    dragGroupEnd(moveable: MoveableGroupInterface, e: any) {\n        return this.dragEnd(moveable, { ...e, targets: moveable.props.targets });\n    },\n    dragGroupControlStart(moveable: MoveableGroupInterface, e: any) {\n        return this.dragStart(moveable, { ...e, targets: moveable.props.targets, isControl: true });\n    },\n    dragGroupContro(moveable: MoveableGroupInterface, e: any) {\n        return this.drag(moveable, { ...e, targets: moveable.props.targets });\n    },\n    dragGroupControEnd(moveable: MoveableGroupInterface, e: any) {\n        return this.dragEnd(moveable, { ...e, targets: moveable.props.targets });\n    },\n};\n\n/**\n * Whether or not target can be scrolled to the scroll container (default: false)\n * @name Moveable.Scrollable#scrollable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   scrollable: true,\n *   scrollContainer: document.body,\n *   scrollThreshold: 0,\n *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),\n * });\n *\n * moveable.scrollable = true;\n */\n\n/**\n * The container to which scroll is applied (default: container)\n * @name Moveable.Scrollable#scrollContainer\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   scrollable: true,\n *   scrollContainer: document.body,\n *   scrollThreshold: 0,\n *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),\n * });\n */\n/**\n * Expand the range of the scroll check area. (default: 0)\n * @name Moveable.Scrollable#scrollThreshold\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   scrollable: true,\n *   scrollContainer: document.body,\n *   scrollThreshold: 0,\n *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),\n * });\n */\n\n/**\n * Sets a function to get the scroll position. (default: Function)\n * @name Moveable.Scrollable#getScrollPosition\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   scrollable: true,\n *   scrollContainer: document.body,\n *   scrollThreshold: 0,\n *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),\n * });\n *\n */\n\n/**\n * When the drag cursor leaves the scrollContainer, the `scroll` event occur to scroll.\n * @memberof Moveable.Scrollable\n * @event scroll\n * @param {Moveable.Scrollable.OnScroll} - Parameters for the `scroll` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"scroll\", ({ scrollContainer, direction }) => {\n *   scrollContainer.scrollLeft += direction[0] * 10;\n *   scrollContainer.scrollTop += direction[1] * 10;\n * });\n */\n\n/**\n * When the drag cursor leaves the scrollContainer, the `scrollGroup` event occur to scroll in group.\n * @memberof Moveable.Scrollable\n * @event scrollGroup\n * @param {Moveable.Scrollable.OnScrollGroup} - Parameters for the `scrollGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"scroll\", ({ scrollContainer, direction }) => {\n *   scrollContainer.scrollLeft += direction[0] * 10;\n *   scrollContainer.scrollTop += direction[1] * 10;\n * });\n */\n","export default {\n    name: \"\",\n    props: {\n        target: Object,\n        dragTarget: Object,\n        container: Object,\n        portalContainer: Object,\n        rootContainer: Object,\n        useResizeObserver: Boolean,\n        zoom: Number,\n        transformOrigin: Array,\n        edge: Object,\n        ables: Array,\n        className: String,\n        pinchThreshold: Number,\n        pinchOutside: Boolean,\n        triggerAblesSimultaneously: Boolean,\n        checkInput: Boolean,\n        cspNonce: String,\n        translateZ: Number,\n        hideDefaultLines: Boolean,\n        props: Object,\n        flushSync: Function,\n        stopPropagation: Boolean,\n        preventClickEventOnDrag: Boolean,\n        preventClickDefault: Boolean,\n    } as const,\n    events: {} as const,\n};\n","import { prefix, makeMatrixCSS } from \"../utils\";\nimport { Renderer, MoveableManagerInterface } from \"../types\";\nimport { createWarpMatrix } from \"@scena/matrix\";\nimport { makeAble } from \"./AbleManager\";\n\nexport default makeAble(\"padding\", {\n    render(moveable: MoveableManagerInterface, React: Renderer): any[] {\n        const props = moveable.props;\n        if (props.dragArea) {\n            return [];\n        }\n        const padding = props.padding || {};\n        const {\n            left = 0,\n            top = 0,\n            right = 0,\n            bottom = 0,\n        } = padding;\n        const {\n            renderPoses,\n            pos1,\n            pos2,\n            pos3,\n            pos4,\n        } = moveable.state;\n\n        const poses = [pos1, pos2, pos3, pos4];\n        const paddingDirections: number[][] = [];\n\n        if (left > 0) {\n            paddingDirections.push([0, 2]);\n        }\n        if (top > 0) {\n            paddingDirections.push([0, 1]);\n        }\n        if (right > 0) {\n            paddingDirections.push([1, 3]);\n        }\n        if (bottom > 0) {\n            paddingDirections.push([2, 3]);\n        }\n        return paddingDirections.map(([dir1, dir2], i) => {\n            const paddingPos1 = poses[dir1];\n            const paddingPos2 = poses[dir2];\n            const paddingPos3 = renderPoses[dir1];\n            const paddingPos4 = renderPoses[dir2];\n\n            const h = createWarpMatrix(\n                [0, 0],\n                [100, 0],\n                [0, 100],\n                [100, 100],\n                paddingPos1,\n                paddingPos2,\n                paddingPos3,\n                paddingPos4,\n            );\n            if (!h.length) {\n                return undefined;\n            }\n            return (<div key={`padding${i}`} className={prefix(\"padding\")} style={{\n                transform: makeMatrixCSS(h, true),\n            }}></div>);\n        });\n    },\n});\n\n/**\n * Add padding around the target to increase the drag area.\n * @name Moveable#padding\n * @default null\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  target: document.querySelector(\".target\"),\n *  padding: { left: 0, top: 0, right: 0, bottom: 0 },\n * });\n * moveable.padding = { left: 10, top: 10, right: 10, bottom: 10 },\n * moveable.updateRect();\n */\n","import { convertCSSSize } from \"../../utils\";\nimport { ControlPose } from \"../../types\";\nimport { convertUnitSize } from \"@daybrush/utils\";\n\nconst RADIUS_DIRECTIONS = [\"nw\", \"ne\", \"se\", \"sw\"] as const;\n\nfunction calculateRatio(values: number[], size: number) {\n    const sumSize = values[0] + values[1];\n    const sumRatio = sumSize > size ? size / sumSize : 1;\n\n    values[0] *= sumRatio;\n    values[1] = size - values[1] * sumRatio;\n\n    return values;\n}\nexport const HORIZONTAL_RADIUS_ORDER = [1, 2, 5, 6];\nexport const VERTICAL_RADIUS_ORDER = [0, 3, 4, 7];\nexport const HORIZONTAL_RADIUS_DIRECTIONS = [1, -1, -1, 1] as const;\nexport const VERTICAL_RADIUS_DIRECTIONS = [1, 1, -1, -1] as const;\n\nexport function getRadiusStyles(\n    poses: number[][], controlPoses: ControlPose[],\n    isRelative: boolean,\n    width: number,\n    height: number,\n    left = 0,\n    top = 0,\n    right: number = width,\n    bottom: number = height,\n) {\n    const clipStyles: string[] = [];\n    let isVertical = false;\n\n    const raws = poses.map((pos, i) => {\n        const { horizontal, vertical } = controlPoses[i];\n        if (vertical && !isVertical) {\n            isVertical = true;\n            clipStyles.push(\"/\");\n        }\n\n        if (isVertical) {\n            const rawPos = Math.max(0, vertical === 1 ? pos[1] - top : bottom - pos[1]);\n            clipStyles.push(convertCSSSize(rawPos, height, isRelative));\n\n            return rawPos;\n        } else {\n            const rawPos = Math.max(0, horizontal === 1 ? pos[0] - left : right - pos[0]);\n            clipStyles.push(convertCSSSize(rawPos, width, isRelative));\n\n            return rawPos;\n        }\n    });\n\n    return {\n        styles: clipStyles,\n        raws,\n    };\n}\nexport function getRadiusRange(controlPoses: ControlPose[]) {\n    // [start, length]\n    const horizontalRange = [0, 0];\n    const verticalRange = [0, 0];\n    const length = controlPoses.length;\n\n    for (let i = 0; i < length; ++i) {\n        const clipPose = controlPoses[i];\n\n        if (!clipPose.sub) {\n            continue;\n        }\n        if (clipPose.horizontal) {\n            if (horizontalRange[1] === 0) {\n                horizontalRange[0] = i;\n            }\n            horizontalRange[1] = i - horizontalRange[0] + 1;\n            verticalRange[0] = i + 1;\n        }\n        if (clipPose.vertical) {\n            if (verticalRange[1] === 0) {\n                verticalRange[0] = i;\n            }\n            verticalRange[1] = i - verticalRange[0] + 1;\n        }\n    }\n\n    return {\n        horizontalRange,\n        verticalRange,\n    };\n}\nexport function getRadiusValues(\n    values: string[],\n    width: number,\n    height: number,\n    left: number,\n    top: number,\n    minCounts: number[] = [0, 0],\n): ControlPose[] {\n    const splitIndex = values.indexOf(\"/\");\n    const splitLength = (splitIndex > -1 ? values.slice(0, splitIndex) : values).length;\n    const horizontalValues = values.slice(0, splitLength);\n    const verticalValues = values.slice(splitLength + 1);\n    const [\n        nwValue = \"0px\",\n        neValue = nwValue,\n        seValue = nwValue,\n        swValue = neValue,\n    ] = horizontalValues;\n    const [\n        wnValue = nwValue,\n        enValue = wnValue,\n        esValue = wnValue,\n        wsValue = enValue,\n    ] = verticalValues;\n\n    const horizontalRawPoses = [nwValue, neValue, seValue, swValue].map(pos => convertUnitSize(pos, width));\n    const verticalRawPoses = [wnValue, enValue, esValue, wsValue].map(pos => convertUnitSize(pos, height));\n    const horizontalPoses = horizontalRawPoses.slice();\n    const verticalPoses = verticalRawPoses.slice();\n\n    [horizontalPoses[0], horizontalPoses[1]] = calculateRatio([horizontalPoses[0], horizontalPoses[1]], width);\n    [horizontalPoses[3], horizontalPoses[2]] = calculateRatio([horizontalPoses[3], horizontalPoses[2]], width);\n    [verticalPoses[0], verticalPoses[3]] = calculateRatio([verticalPoses[0], verticalPoses[3]], height);\n    [verticalPoses[1], verticalPoses[2]] = calculateRatio([verticalPoses[1], verticalPoses[2]], height);\n\n    const nextHorizontalPoses\n        = horizontalPoses.slice(0, Math.max(minCounts[0], horizontalValues.length));\n    const nextVerticalPoses\n        = verticalPoses.slice(0, Math.max(minCounts[1], verticalValues.length));\n    return [\n        ...nextHorizontalPoses.map((pos, i) => {\n            const direction = RADIUS_DIRECTIONS[i];\n\n            return {\n                horizontal: HORIZONTAL_RADIUS_DIRECTIONS[i],\n                vertical: 0,\n                pos: [left + pos, top + (VERTICAL_RADIUS_DIRECTIONS[i] === -1 ? height : 0)],\n                sub: true,\n                raw: horizontalRawPoses[i],\n                direction,\n            };\n        }),\n        ...nextVerticalPoses.map((pos, i) => {\n            const direction = RADIUS_DIRECTIONS[i];\n\n            return {\n                horizontal: 0,\n                vertical: VERTICAL_RADIUS_DIRECTIONS[i],\n                pos: [left + (HORIZONTAL_RADIUS_DIRECTIONS[i] === -1 ? width : 0), top + pos],\n                sub: true,\n                raw: verticalRawPoses[i],\n                direction,\n            };\n        }),\n    ];\n}\nexport function removeRadiusPos(\n    controlPoses: ControlPose[],\n    poses: number[][],\n    index: number,\n    startIndex: number,\n    length: number = poses.length,\n) {\n    const {\n        horizontalRange,\n        verticalRange,\n    } = getRadiusRange(controlPoses.slice(startIndex));\n    const radiuslIndex = index - startIndex;\n    let deleteCount = 0;\n\n    if (radiuslIndex === 0) {\n        deleteCount = length;\n    } else if (radiuslIndex > 0 && radiuslIndex < horizontalRange[1]) {\n        deleteCount = horizontalRange[1] - radiuslIndex;\n    } else if (radiuslIndex >= verticalRange[0]) {\n        deleteCount = verticalRange[0] + verticalRange[1] - radiuslIndex;\n    } else {\n        return;\n    }\n    controlPoses.splice(index, deleteCount);\n    poses.splice(index, deleteCount);\n}\nexport function addRadiusPos(\n    controlPoses: ControlPose[],\n    poses: number[][],\n    startIndex: number,\n    horizontalIndex: number,\n    verticalIndex: number,\n    distX: number,\n    distY: number,\n    right: number,\n    bottom: number,\n    left = 0,\n    top = 0,\n) {\n    const {\n        horizontalRange,\n        verticalRange,\n    } = getRadiusRange(controlPoses.slice(startIndex));\n    if (horizontalIndex > -1) {\n        const radiusX = HORIZONTAL_RADIUS_DIRECTIONS[horizontalIndex] === 1\n            ? distX - left\n            : right - distX;\n        for (let i = horizontalRange[1]; i <= horizontalIndex; ++i) {\n            const y = VERTICAL_RADIUS_DIRECTIONS[i] === 1 ? top : bottom;\n            let x = 0;\n            if (horizontalIndex === i) {\n                x = distX;\n            } else if (i === 0) {\n                x = left + radiusX;\n            } else if (HORIZONTAL_RADIUS_DIRECTIONS[i] === -1) {\n                x = right - (poses[startIndex][0] - left);\n            }\n            controlPoses.splice(startIndex + i, 0, {\n                horizontal: HORIZONTAL_RADIUS_DIRECTIONS[i],\n                vertical: 0,\n                pos: [x, y],\n            });\n            poses.splice(startIndex + i, 0, [x, y]);\n\n            if (i === 0) {\n                break;\n            }\n        }\n    } else if (verticalIndex > - 1) {\n        const radiusY = VERTICAL_RADIUS_DIRECTIONS[verticalIndex] === 1\n            ? distY - top\n            : bottom - distY;\n        if (horizontalRange[1] === 0 && verticalRange[1] === 0) {\n            const pos = [\n                left + radiusY,\n                top,\n            ];\n            controlPoses.push({\n                horizontal: HORIZONTAL_RADIUS_DIRECTIONS[0],\n                vertical: 0,\n                pos,\n            });\n            poses.push(pos);\n        }\n\n        const startVerticalIndex = verticalRange[0];\n        for (let i = verticalRange[1]; i <= verticalIndex; ++i) {\n            const x = HORIZONTAL_RADIUS_DIRECTIONS[i] === 1 ? left : right;\n            let y = 0;\n            if (verticalIndex === i) {\n                y = distY;\n            } else if (i === 0) {\n                y = top + radiusY;\n            } else if (VERTICAL_RADIUS_DIRECTIONS[i] === 1) {\n                y = poses[startIndex + startVerticalIndex][1];\n            } else if (VERTICAL_RADIUS_DIRECTIONS[i] === -1) {\n                y = bottom - (poses[startIndex + startVerticalIndex][1] - top);\n            }\n            controlPoses.push({\n                horizontal: 0,\n                vertical: VERTICAL_RADIUS_DIRECTIONS[i],\n                pos: [x, y],\n            });\n            poses.push([x, y]);\n            if (i === 0) {\n                break;\n            }\n        }\n    }\n}\nexport function splitRadiusPoses(\n    controlPoses: ControlPose[],\n    raws: number[] = controlPoses.map(pos => pos.raw!),\n) {\n    const horizontals = controlPoses\n        .map((pos, i) => pos.horizontal ? raws[i] : null).filter(pos => pos != null) as number[];\n    const verticals = controlPoses\n        .map((pos, i) => pos.vertical ? raws[i] : null).filter(pos => pos != null) as number[];\n\n    return {\n        horizontals,\n        verticals,\n    };\n}\n","import {\n    Renderer, ClippableProps, OnClip,\n    ClippableState, OnClipEnd, OnClipStart,\n    ControlPose, MoveableManagerInterface, DraggableProps,\n} from \"../types\";\nimport { splitBracket, splitComma, splitUnit, splitSpace, convertUnitSize, getRad } from \"@daybrush/utils\";\nimport {\n    prefix, calculatePosition, getDiagonalSize,\n    fillParams, triggerEvent,\n    makeMatrixCSS, getRect, fillEndParams,\n    convertCSSSize,\n    getComputedStyle,\n    getSizeDistByDist,\n    getProps,\n} from \"../utils\";\nimport { plus, minus, multiply } from \"@scena/matrix\";\nimport { getDragDist, calculatePointerDist, setDragStart } from \"../gesto/GestoUtils\";\nimport {\n    getRadiusValues,\n    HORIZONTAL_RADIUS_ORDER, VERTICAL_RADIUS_ORDER, getRadiusStyles, addRadiusPos, removeRadiusPos,\n} from \"./roundable/borderRadius\";\nimport { renderLine } from \"../renderDirections\";\nimport { checkSnapBoundPriority } from \"./snappable/snap\";\nimport { checkSnapBounds } from \"./snappable/snapBounds\";\nimport { getDefaultGuidelines } from \"./snappable/getTotalGuidelines\";\n\n\nconst CLIP_DIRECTIONS = [\n    [0, -1, \"n\"],\n    [1, 0, \"e\"],\n] as const;\nconst CLIP_RECT_DIRECTIONS = [\n    [-1, -1, \"nw\"],\n    [0, -1, \"n\"],\n    [1, -1, \"ne\"],\n    [1, 0, \"e\"],\n    [1, 1, \"se\"],\n    [0, 1, \"s\"],\n    [-1, 1, \"sw\"],\n    [-1, 0, \"w\"],\n] as const;\n\n// 1 2 5 6 0 3 4 7\n// 0 1 2 3 4 5 6 7\n\nfunction getClipStyles(\n    moveable: MoveableManagerInterface<ClippableProps>,\n    clipPath: ReturnType<typeof getClipPath>,\n    poses: number[][],\n) {\n    const {\n        clipRelative,\n    } = moveable.props;\n    const {\n        width,\n        height,\n    } = moveable.state;\n    const {\n        type: clipType,\n        poses: clipPoses,\n    } = clipPath!;\n\n    const isRect = clipType === \"rect\";\n    const isCircle = clipType === \"circle\";\n    if (clipType === \"polygon\") {\n        return poses.map(pos => `${convertCSSSize(pos[0], width, clipRelative)} ${convertCSSSize(pos[1], height, clipRelative)}`);\n    } else if (isRect || clipType === \"inset\") {\n        const top = poses[1][1];\n        const right = poses[3][0];\n        const left = poses[7][0];\n        const bottom = poses[5][1];\n\n        if (isRect) {\n            return [\n                top,\n                right,\n                bottom,\n                left,\n            ].map(pos => `${pos}px`);\n        }\n        const clipStyles\n            = [top, width - right, height - bottom, left]\n                .map((pos, i) => convertCSSSize(pos, i % 2 ? width : height, clipRelative));\n\n        if (poses.length > 8) {\n            const [subWidth, subHeight] = minus(poses[4], poses[0]);\n\n            clipStyles.push(\"round\", ...getRadiusStyles(\n                poses.slice(8),\n                clipPoses.slice(8),\n                clipRelative!,\n                subWidth,\n                subHeight,\n                left, top, right, bottom,\n            ).styles);\n        }\n        return clipStyles;\n    } else if (isCircle || clipType === \"ellipse\") {\n        const center = poses[0];\n        const ry = convertCSSSize(\n            Math.abs(poses[1][1] - center[1]),\n            isCircle ? Math.sqrt((width * width + height * height) / 2) : height,\n            clipRelative,\n        );\n\n        const clipStyles = isCircle ? [ry]\n            : [convertCSSSize(Math.abs(poses[2][0] - center[0]), width, clipRelative), ry];\n\n        clipStyles.push(\n            \"at\", convertCSSSize(center[0], width, clipRelative),\n            convertCSSSize(center[1], height, clipRelative));\n\n        return clipStyles;\n    }\n}\n\nfunction getRectPoses(top: number, right: number, bottom: number, left: number): ControlPose[] {\n    const xs = [left, (left + right) / 2, right];\n    const ys = [top, (top + bottom) / 2, bottom];\n\n    return CLIP_RECT_DIRECTIONS.map(([dirx, diry, dir]) => {\n        const x = xs[dirx + 1];\n        const y = ys[diry + 1];\n        return {\n            vertical: Math.abs(diry),\n            horizontal: Math.abs(dirx),\n            direction: dir,\n            pos: [x, y],\n        };\n    });\n}\n\nexport function getControlSize(\n    controlPoses: ControlPose[],\n) {\n    const xRange = [Infinity, -Infinity];\n    const yRange = [Infinity, -Infinity];\n\n    controlPoses.forEach(({ pos }) => {\n        xRange[0] = Math.min(xRange[0], pos[0]);\n        xRange[1] = Math.max(xRange[1], pos[0]);\n        yRange[0] = Math.min(yRange[0], pos[1]);\n        yRange[1] = Math.max(yRange[1], pos[1]);\n    });\n\n    return [\n        Math.abs(xRange[1] - xRange[0]),\n        Math.abs(yRange[1] - yRange[0]),\n    ];\n}\n\nexport function moveControlPos(\n    controlPoses: ControlPose[],\n    index: number,\n    dist: number[],\n    isRect?: boolean,\n    keepRatio?: boolean,\n) {\n    const { direction, sub } = controlPoses[index];\n    const dists = controlPoses.map(() => [0, 0]);\n    const directions = direction ? direction.split(\"\") : [];\n\n    if (isRect && index < 8) {\n        const verticalDirections = directions.filter(dir => dir === \"w\" || dir === \"e\");\n        const horizontalDirections = directions.filter(dir => dir === \"n\" || dir === \"s\");\n\n        const verticalDirection = verticalDirections[0];\n        const horizontalDirection = horizontalDirections[0];\n\n        dists[index] = dist;\n        const [width, height] = getControlSize(controlPoses);\n        const ratio = width && height ? width / height : 0;\n\n        if (ratio && keepRatio) {\n            // 0 1 2\n            // 7   3\n            // 6 5 4\n\n            const fixedIndex = (index + 4) % 8;\n            const fixedPosition = controlPoses[fixedIndex].pos;\n            const sizeDirection = [0, 0];\n\n            if (direction!.indexOf(\"w\") > -1) {\n                sizeDirection[0] = -1;\n            } else if (direction!.indexOf(\"e\") > -1) {\n                sizeDirection[0] = 1;\n            }\n            if (direction!.indexOf(\"n\") > -1) {\n                sizeDirection[1] = -1;\n            } else if (direction!.indexOf(\"s\") > -1) {\n                sizeDirection[1] = 1;\n            }\n\n\n            const nextDist = getSizeDistByDist(\n                [width, height],\n                dist,\n                ratio,\n                sizeDirection,\n                true,\n            );\n            const nextWidth = width + nextDist[0];\n            const nextHeight = height + nextDist[1];\n            let top = fixedPosition[1];\n            let bottom = fixedPosition[1];\n            let left = fixedPosition[0];\n            let right = fixedPosition[0];\n\n            if (sizeDirection[0] === -1) {\n                left = right - nextWidth;\n            } else if (sizeDirection[0] === 1) {\n                right = left + nextWidth;\n            } else {\n                left = left - nextWidth / 2;\n                right = right + nextWidth / 2;\n            }\n            if (sizeDirection[1] === -1) {\n                top = bottom - nextHeight;\n            } else if (sizeDirection[1] === 1) {\n                bottom = top + nextHeight;\n            } else {\n                top = bottom - nextHeight / 2;\n                bottom = top + nextHeight;\n            }\n\n            const nextControlPoses = getRectPoses(top, right, bottom, left);\n\n            controlPoses.forEach((controlPose, i) => {\n                dists[i][0] = nextControlPoses[i].pos[0] - controlPose.pos[0];\n                dists[i][1] = nextControlPoses[i].pos[1] - controlPose.pos[1];\n            });\n        } else {\n            controlPoses.forEach((controlPose, i) => {\n                const {\n                    direction: controlDir,\n                } = controlPose;\n\n                if (!controlDir) {\n                    return;\n                }\n                if (controlDir.indexOf(verticalDirection) > -1) {\n                    dists[i][0] = dist[0];\n                }\n                if (controlDir.indexOf(horizontalDirection) > -1) {\n                    dists[i][1] = dist[1];\n                }\n            });\n            if (verticalDirection) {\n                dists[1][0] = dist[0] / 2;\n                dists[5][0] = dist[0] / 2;\n            }\n            if (horizontalDirection) {\n                dists[3][1] = dist[1] / 2;\n                dists[7][1] = dist[1] / 2;\n            }\n        }\n    } else if (direction && !sub) {\n        directions.forEach(dir => {\n            const isVertical = dir === \"n\" || dir === \"s\";\n\n            controlPoses.forEach((controlPose, i) => {\n                const {\n                    direction: dirDir,\n                    horizontal: dirHorizontal,\n                    vertical: dirVertical,\n                } = controlPose;\n\n                if (!dirDir || dirDir.indexOf(dir) === -1) {\n                    return;\n                }\n                dists[i] = [\n                    isVertical || !dirHorizontal ? 0 : dist[0],\n                    !isVertical || !dirVertical ? 0 : dist[1],\n                ];\n            });\n        });\n    } else {\n        dists[index] = dist;\n    }\n\n    return dists;\n}\nfunction getClipPath(\n    target: HTMLElement | SVGElement,\n    width: number,\n    height: number,\n    defaultClip?: string,\n    customClip?: string,\n) {\n    let clipText: string | undefined = customClip;\n\n    if (!clipText) {\n        const style = getComputedStyle(target!);\n        const clipPath = style.clipPath!;\n\n        clipText = clipPath !== \"none\" ? clipPath : style.clip!;\n    }\n    if (!clipText || clipText === \"none\" || clipText === \"auto\") {\n        clipText = defaultClip;\n\n        if (!clipText) {\n            return;\n        }\n    }\n    const {\n        prefix: clipPrefix = clipText,\n        value = \"\",\n    } = splitBracket(clipText);\n    const isCircle = clipPrefix === \"circle\";\n    let splitter = \" \";\n\n    if (clipPrefix === \"polygon\") {\n        const values = splitComma(value! || `0% 0%, 100% 0%, 100% 100%, 0% 100%`);\n        splitter = \",\";\n\n        const poses: ControlPose[] = values.map(pos => {\n            const [xPos, yPos] = pos.split(\" \");\n\n            return {\n                vertical: 1,\n                horizontal: 1,\n                pos: [\n                    convertUnitSize(xPos, width),\n                    convertUnitSize(yPos, height),\n                ],\n            };\n        });\n\n        return {\n            type: clipPrefix,\n            clipText,\n            poses,\n            splitter,\n        } as const;\n    } else if (isCircle || clipPrefix === \"ellipse\") {\n        let xPos = \"\";\n        let yPos = \"\";\n        let radiusX = 0;\n        let radiusY = 0;\n        const values = splitSpace(value!);\n\n        if (isCircle) {\n            let radius = \"\";\n            [radius = \"50%\", , xPos = \"50%\", yPos = \"50%\"] = values;\n\n            radiusX = convertUnitSize(radius, Math.sqrt((width * width + height * height) / 2));\n            radiusY = radiusX;\n        } else {\n            let xRadius = \"\";\n            let yRadius = \"\";\n            [xRadius = \"50%\", yRadius = \"50%\", , xPos = \"50%\", yPos = \"50%\"] = values;\n\n            radiusX = convertUnitSize(xRadius, width);\n            radiusY = convertUnitSize(yRadius, height);\n        }\n        const centerPos = [\n            convertUnitSize(xPos, width),\n            convertUnitSize(yPos, height),\n        ];\n        const poses: ControlPose[] = [\n            {\n                vertical: 1,\n                horizontal: 1,\n                pos: centerPos,\n                direction: \"nesw\",\n            },\n            ...CLIP_DIRECTIONS.slice(0, isCircle ? 1 : 2).map(dir => ({\n                vertical: Math.abs(dir[1]),\n                horizontal: dir[0],\n                direction: dir[2],\n                sub: true,\n                pos: [\n                    centerPos[0] + dir[0] * radiusX,\n                    centerPos[1] + dir[1] * radiusY,\n                ],\n            })),\n        ];\n        return {\n            type: clipPrefix as \"circle\" | \"ellipse\",\n            clipText,\n            radiusX,\n            radiusY,\n            left: centerPos[0] - radiusX,\n            top: centerPos[1] - radiusY,\n            poses,\n            splitter,\n        } as const;\n    } else if (clipPrefix === \"inset\") {\n        const values = splitSpace(value! || \"0 0 0 0\");\n        const roundIndex = values.indexOf(\"round\");\n\n        const rectLength = (roundIndex > -1 ? values.slice(0, roundIndex) : values).length;\n        const radiusValues = values.slice(rectLength + 1);\n        const [\n            topValue,\n            rightValue = topValue,\n            bottomValue = topValue,\n            leftValue = rightValue,\n        ] = values.slice(0, rectLength);\n        const [top, bottom] = [topValue, bottomValue].map(pos => convertUnitSize(pos, height));\n        const [left, right] = [leftValue, rightValue].map(pos => convertUnitSize(pos, width));\n        const nextRight = width - right;\n        const nextBottom = height - bottom;\n        const radiusPoses = getRadiusValues(\n            radiusValues,\n            nextRight - left,\n            nextBottom - top,\n            left,\n            top,\n        );\n        const poses: ControlPose[] = [\n            ...getRectPoses(top, nextRight, nextBottom, left),\n            ...radiusPoses,\n        ];\n\n        return {\n            type: \"inset\",\n            clipText,\n            poses,\n            top,\n            left,\n            right: nextRight,\n            bottom: nextBottom,\n            radius: radiusValues,\n            splitter,\n        } as const;\n    } else if (clipPrefix === \"rect\") {\n        // top right bottom left\n        const values = splitComma(value! || `0px, ${width}px, ${height}px, 0px`);\n\n        splitter = \",\";\n        const [top, right, bottom, left] = values.map(pos => {\n            const { value: posValue } = splitUnit(pos);\n\n            return posValue;\n        });\n        const poses = getRectPoses(top, right, bottom, left);\n\n        return {\n            type: \"rect\",\n            clipText,\n            poses,\n            top,\n            right,\n            bottom,\n            left,\n            values,\n            splitter,\n        } as const;\n    }\n    return;\n}\nfunction addClipPath(moveable: MoveableManagerInterface<ClippableProps>, e: any) {\n    const [distX, distY] = calculatePointerDist(moveable, e);\n    const { clipPath, clipIndex } = e.datas;\n    const {\n        type: clipType,\n        poses: clipPoses,\n        splitter,\n    } = (clipPath as ReturnType<typeof getClipPath>)!;\n    const poses = clipPoses.map(pos => pos.pos);\n    if (clipType === \"polygon\") {\n        poses.splice(clipIndex, 0, [distX, distY]);\n    } else if (clipType === \"inset\") {\n        const horizontalIndex = HORIZONTAL_RADIUS_ORDER.indexOf(clipIndex);\n        const verticalIndex = VERTICAL_RADIUS_ORDER.indexOf(clipIndex);\n        const length = clipPoses.length;\n\n        addRadiusPos(\n            clipPoses,\n            poses,\n            8,\n            horizontalIndex,\n            verticalIndex,\n            distX,\n            distY,\n            poses[4][0],\n            poses[4][1],\n            poses[0][0],\n            poses[0][1],\n        );\n\n        if (length === clipPoses.length) {\n            return;\n        }\n    } else {\n        return;\n    }\n    const clipStyles = getClipStyles(moveable, clipPath, poses)!;\n    triggerEvent(moveable, \"onClip\", fillParams<OnClip>(moveable, e, {\n        clipEventType: \"added\",\n        clipType,\n        poses,\n        clipStyles,\n        clipStyle: `${clipType}(${clipStyles.join(splitter)})`,\n        distX: 0,\n        distY: 0,\n    }));\n}\nfunction removeClipPath(moveable: MoveableManagerInterface<ClippableProps>, e: any) {\n    const { clipPath, clipIndex } = e.datas;\n    const {\n        type: clipType,\n        poses: clipPoses,\n        splitter,\n    } = (clipPath as ReturnType<typeof getClipPath>)!;\n    const poses = clipPoses.map(pos => pos.pos);\n    const length = poses.length;\n    if (clipType === \"polygon\") {\n        clipPoses.splice(clipIndex, 1);\n        poses.splice(clipIndex, 1);\n    } else if (clipType === \"inset\") {\n        if (clipIndex < 8) {\n            return;\n        }\n        removeRadiusPos(clipPoses, poses, clipIndex, 8, length);\n\n        if (length === clipPoses.length) {\n            return;\n        }\n    } else {\n        return;\n    }\n    const clipStyles = getClipStyles(moveable, clipPath, poses)!;\n    triggerEvent(moveable, \"onClip\", fillParams<OnClip>(moveable, e, {\n        clipEventType: \"removed\",\n        clipType,\n        poses,\n        clipStyles,\n        clipStyle: `${clipType}(${clipStyles.join(splitter)})`,\n        distX: 0,\n        distY: 0,\n    }));\n}\n/**\n * @namespace Moveable.Clippable\n * @description Whether to clip the target.\n */\n\nexport default {\n    name: \"clippable\",\n    props: {\n        clippable: Boolean,\n        defaultClipPath: String,\n        customClipPath: String,\n        keepRatio: Boolean,\n        clipRelative: Boolean,\n        clipArea: Boolean,\n        dragWithClip: Boolean,\n        clipTargetBounds: Boolean,\n        clipVerticalGuidelines: Array,\n        clipHorizontalGuidelines: Array,\n        clipSnapThreshold: Boolean,\n    } as const,\n    events: {\n        onClipStart: \"clipStart\",\n        onClip: \"clip\",\n        onClipEnd: \"clipEnd\",\n    } as const,\n    css: [\n        `.control.clip-control {\n    background: #6d6;\n    cursor: pointer;\n}\n.control.clip-control.clip-radius {\n    background: #d66;\n}\n.line.clip-line {\n    background: #6e6;\n    cursor: move;\n    z-index: 1;\n}\n.clip-area {\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.clip-ellipse {\n    position: absolute;\n    cursor: move;\n    border: 1px solid #6d6;\n    border: var(--zoompx) solid #6d6;\n    border-radius: 50%;\n    transform-origin: 0px 0px;\n}`,\n        `:host {\n    --bounds-color: #d66;\n}`,\n        `.guideline {\n    pointer-events: none;\n    z-index: 2;\n}`,\n        `.line.guideline.bounds {\n    background: #d66;\n    background: var(--bounds-color);\n}`,\n    ],\n    render(moveable: MoveableManagerInterface<ClippableProps, ClippableState>, React: Renderer): any[] {\n        const {\n            customClipPath,\n            defaultClipPath,\n            clipArea, zoom,\n        } = moveable.props;\n        const {\n            target, width, height, allMatrix, is3d, left, top,\n            pos1, pos2, pos3, pos4,\n            clipPathState,\n            snapBoundInfos,\n            rotation: rotationRad,\n        } = moveable.state;\n\n        if (!target) {\n            return [];\n        }\n\n        const clipPath = getClipPath(\n            target, width, height, defaultClipPath || \"inset\", clipPathState || customClipPath);\n\n        if (!clipPath) {\n            return [];\n        }\n        const n = is3d ? 4 : 3;\n        const type = clipPath.type;\n        const clipPoses = clipPath.poses;\n        const poses = clipPoses.map(pos => {\n            // return [x, y];\n            const calculatedPos = calculatePosition(allMatrix, pos.pos, n);\n\n            return [\n                calculatedPos[0] - left,\n                calculatedPos[1] - top,\n            ];\n        });\n\n        let controls: any[] = [];\n        let lines: any[] = [];\n\n        const isRect = type === \"rect\";\n        const isInset = type === \"inset\";\n        const isPolygon = type === \"polygon\";\n\n        if (isRect || isInset || isPolygon) {\n            const linePoses = isInset ? poses.slice(0, 8) : poses;\n\n            lines = linePoses.map((to, i) => {\n                const from = i === 0 ? linePoses[linePoses.length - 1] : linePoses[i - 1];\n\n                const rad = getRad(from, to);\n                const dist = getDiagonalSize(from, to);\n                return <div key={`clipLine${i}`} className={prefix(\"line\", \"clip-line\", \"snap-control\")}\n                    data-clip-index={i}\n                    style={{\n                        width: `${dist}px`,\n                        transform: `translate(${from[0]}px, ${from[1]}px) rotate(${rad}rad) scaleY(${zoom})`,\n                    }}></div>;\n            });\n        }\n        controls = poses.map((pos, i) => {\n            return <div key={`clipControl${i}`}\n                className={prefix(\"control\", \"clip-control\", \"snap-control\")}\n                data-clip-index={i}\n                style={{\n                    transform: `translate(${pos[0]}px, ${pos[1]}px) rotate(${rotationRad}rad) scale(${zoom})`,\n                }}></div>;\n        });\n\n        if (isInset) {\n            controls.push(...poses.slice(8).map((pos, i) => {\n                return <div key={`clipRadiusControl${i}`}\n                    className={prefix(\"control\", \"clip-control\", \"clip-radius\", \"snap-control\")}\n                    data-clip-index={8 + i}\n                    style={{\n                        transform: `translate(${pos[0]}px, ${pos[1]}px) rotate(${rotationRad}rad) scale(${zoom})`,\n                    }}></div>;\n            }));\n        }\n        if (type === \"circle\" || type === \"ellipse\") {\n            const {\n                left: clipLeft,\n                top: clipTop,\n                radiusX,\n                radiusY,\n            } = clipPath;\n\n            const [distLeft, distTop] = minus(\n                calculatePosition(allMatrix, [clipLeft!, clipTop!], n),\n                calculatePosition(allMatrix, [0, 0], n),\n            );\n            let ellipseClipPath = \"none\";\n\n            if (!clipArea) {\n                const piece = Math.max(10, radiusX! / 5, radiusY! / 5);\n                const areaPoses: number[][] = [];\n\n                for (let i = 0; i <= piece; ++i) {\n                    const rad = Math.PI * 2 / piece * i;\n                    areaPoses.push([\n                        radiusX! + (radiusX! - zoom!) * Math.cos(rad),\n                        radiusY! + (radiusY! - zoom!) * Math.sin(rad),\n                    ]);\n                }\n                areaPoses.push([radiusX!, -2]);\n                areaPoses.push([-2, -2]);\n                areaPoses.push([-2, radiusY! * 2 + 2]);\n                areaPoses.push([radiusX! * 2 + 2, radiusY! * 2 + 2]);\n                areaPoses.push([radiusX! * 2 + 2, -2]);\n                areaPoses.push([radiusX!, -2]);\n\n                ellipseClipPath = `polygon(${areaPoses.map(pos => `${pos[0]}px ${pos[1]}px`).join(\", \")})`;\n            }\n            controls.push(<div key=\"clipEllipse\" className={prefix(\"clip-ellipse\", \"snap-control\")} style={{\n                width: `${radiusX! * 2}px`,\n                height: `${radiusY! * 2}px`,\n                clipPath: ellipseClipPath,\n                transform: `translate(${-left + distLeft}px, ${-top + distTop}px) ${makeMatrixCSS(allMatrix)}`,\n            }}></div>);\n        }\n        if (clipArea) {\n            const {\n                width: allWidth,\n                height: allHeight,\n                left: allLeft,\n                top: allTop,\n            } = getRect([pos1, pos2, pos3, pos4, ...poses]);\n            if (isPolygon || isRect || isInset) {\n                const areaPoses = isInset ? poses.slice(0, 8) : poses;\n                controls.push(<div key=\"clipArea\" className={prefix(\"clip-area\", \"snap-control\")} style={{\n                    width: `${allWidth}px`,\n                    height: `${allHeight}px`,\n                    transform: `translate(${allLeft}px, ${allTop}px)`,\n                    clipPath: `polygon(${areaPoses.map(pos => `${pos[0] - allLeft}px ${pos[1] - allTop}px`).join(\", \")})`,\n                }}></div>);\n            }\n        }\n        if (snapBoundInfos) {\n            ([\"vertical\", \"horizontal\"] as const).forEach(directionType => {\n                const info = snapBoundInfos[directionType];\n                const isHorizontal = directionType === \"horizontal\";\n\n                if (info.isSnap) {\n                    lines.push(...info.snap.posInfos.map(({ pos }, i) => {\n                        const snapPos1 = minus(calculatePosition(\n                            allMatrix, isHorizontal ? [0, pos] : [pos, 0], n), [left, top]);\n                        const snapPos2 = minus(calculatePosition(\n                            allMatrix, isHorizontal ? [width, pos] : [pos, height], n), [left, top]);\n\n                        return renderLine(\n                            React, \"\", snapPos1, snapPos2, zoom!,\n                            `clip${directionType}snap${i}`, \"guideline\");\n                    }));\n                }\n                if (info.isBound) {\n                    lines.push(...info.bounds.map(({ pos }, i) => {\n                        const snapPos1 = minus(calculatePosition(\n                            allMatrix, isHorizontal ? [0, pos] : [pos, 0], n), [left, top]);\n                        const snapPos2 = minus(calculatePosition(\n                            allMatrix, isHorizontal ? [width, pos] : [pos, height], n), [left, top]);\n\n                        return renderLine(\n                            React, \"\", snapPos1, snapPos2, zoom!,\n                            `clip${directionType}bounds${i}`, \"guideline\", \"bounds\", \"bold\");\n                    }));\n                }\n            });\n        }\n        return [\n            ...controls,\n            ...lines,\n        ];\n    },\n    dragControlCondition(moveable: any, e: any) {\n        return e.inputEvent && (e.inputEvent.target.getAttribute(\"class\") || \"\").indexOf(\"clip\") > -1;\n    },\n    dragStart(moveable: MoveableManagerInterface<ClippableProps, ClippableState>, e: any) {\n        const props = moveable.props;\n        const {\n            dragWithClip = true,\n        } = props;\n\n        if (dragWithClip) {\n            return false;\n        }\n\n        return this.dragControlStart(moveable, e);\n    },\n    drag(moveable: MoveableManagerInterface<ClippableProps, ClippableState>, e: any) {\n        return this.dragControl(moveable, {...e, isDragTarget: true });\n    },\n    dragEnd(moveable: MoveableManagerInterface<ClippableProps, ClippableState>, e: any) {\n        return this.dragControlEnd(moveable, e);\n    },\n    dragControlStart(moveable: MoveableManagerInterface<ClippableProps, ClippableState>, e: any) {\n        const state = moveable.state;\n        const { defaultClipPath, customClipPath } = moveable.props;\n        const { target, width, height } = state;\n        const inputTarget = e.inputEvent ? e.inputEvent.target : null;\n        const className = (inputTarget && inputTarget.getAttribute(\"class\")) || \"\";\n        const datas = e.datas;\n        const clipPath = getClipPath(target!, width, height, defaultClipPath || \"inset\", customClipPath);\n\n        if (!clipPath) {\n            return false;\n        }\n        const { clipText, type, poses } = clipPath;\n        const result = triggerEvent(moveable, \"onClipStart\", fillParams<OnClipStart>(moveable, e, {\n            clipType: type,\n            clipStyle: clipText,\n            poses: poses.map(pos => pos.pos),\n        }));\n\n        if (result === false) {\n            datas.isClipStart = false;\n            return false;\n        }\n        datas.isControl = className && className.indexOf(\"clip-control\") > -1;\n        datas.isLine = className.indexOf(\"clip-line\") > -1;\n        datas.isArea = className.indexOf(\"clip-area\") > -1 || className.indexOf(\"clip-ellipse\") > -1;\n        datas.clipIndex = inputTarget ? parseInt(inputTarget.getAttribute(\"data-clip-index\"), 10) : -1;\n        datas.clipPath = clipPath;\n        datas.isClipStart = true;\n        state.clipPathState = clipText;\n        setDragStart(moveable, e);\n\n        return true;\n    },\n    dragControl(moveable: MoveableManagerInterface<ClippableProps & DraggableProps, ClippableState>, e: any) {\n        const { datas, originalDatas, isDragTarget } = e;\n\n        if (!datas.isClipStart) {\n            return false;\n        }\n        const { isControl, isLine, isArea, clipIndex, clipPath } = datas as {\n            clipPath: ReturnType<typeof getClipPath>,\n            [key: string]: any,\n        };\n        if (!clipPath) {\n            return false;\n        }\n        const props = getProps(moveable.props, \"clippable\");\n\n        const { keepRatio } = props;\n        let distX = 0;\n        let distY = 0;\n\n        const originalDraggable = originalDatas.draggable;\n        const originalDist = getDragDist(e);\n\n        if (isDragTarget && originalDraggable) {\n            [distX, distY] = originalDraggable.prevBeforeDist;\n        } else {\n            [distX, distY] = originalDist;\n        }\n\n        const firstDist = [distX, distY];\n\n        const state = moveable.state;\n        const { width, height } = state;\n        const isDragWithTarget = !isArea && !isControl && !isLine;\n        const {\n            type: clipType,\n            poses: clipPoses,\n            splitter,\n        } = clipPath;\n        const poses = clipPoses.map(pos => pos.pos);\n\n        if (isDragWithTarget) {\n            distX = -distX;\n            distY = -distY;\n        }\n        const isAll = !isControl || clipPoses[clipIndex].direction === \"nesw\";\n        const isRect = clipType === \"inset\" || clipType === \"rect\";\n        let dists = clipPoses.map(() => [0, 0]);\n\n        if (isControl && !isAll) {\n            const { horizontal, vertical } = clipPoses[clipIndex];\n            const dist = [\n                distX * Math.abs(horizontal),\n                distY * Math.abs(vertical),\n            ];\n            dists = moveControlPos(clipPoses, clipIndex, dist, isRect, keepRatio);\n        } else if (isAll) {\n            dists = poses.map(() => [distX, distY]);\n        }\n        const nextPoses: number[][] = poses.map((pos, i) => plus(pos, dists[i]));\n        const guidePoses = [...nextPoses];\n\n        state.snapBoundInfos = null;\n        const isCircle = clipPath.type === \"circle\";\n        const isEllipse = clipPath.type === \"ellipse\";\n\n        if (isCircle || isEllipse) {\n            const guideRect = getRect(nextPoses);\n            const ry = Math.abs(guideRect.bottom - guideRect.top);\n            const rx = Math.abs(isEllipse ? guideRect.right - guideRect.left : ry);\n            const bottom = nextPoses[0][1] + ry;\n            const left = nextPoses[0][0] - rx;\n            const right = nextPoses[0][0] + rx;\n\n            // right\n            if (isCircle) {\n                guidePoses.push([right, guideRect.bottom]);\n                dists.push([1, 0]);\n            }\n            // bottom\n            guidePoses.push([guideRect.left, bottom]);\n            dists.push([0, 1]);\n            // left\n            guidePoses.push([left, guideRect.bottom]);\n            dists.push([1, 0]);\n        }\n\n        const guidelines = getDefaultGuidelines(\n            (props.clipHorizontalGuidelines || []).map(v => convertUnitSize(`${v}`, height)),\n            (props.clipVerticalGuidelines || []).map(v => convertUnitSize(`${v}`, width)),\n            width!, height!,\n        );\n        let guideXPoses: number[] = [];\n        let guideYPoses: number[] = [];\n\n        if (isCircle || isEllipse) {\n            guideXPoses = [guidePoses[4][0], guidePoses[2][0]];\n            guideYPoses = [guidePoses[1][1], guidePoses[3][1]];\n        } else if (isRect) {\n            const rectPoses = [guidePoses[0], guidePoses[2], guidePoses[4], guidePoses[6]];\n            const rectDists = [dists[0], dists[2], dists[4], dists[6]];\n\n            guideXPoses = rectPoses.filter((_, i) => rectDists[i][0]).map(pos => pos[0]);\n            guideYPoses = rectPoses.filter((_, i) => rectDists[i][1]).map(pos => pos[1]);\n        } else {\n            guideXPoses = guidePoses.filter((_, i) => dists[i][0]).map(pos => pos[0]);\n            guideYPoses = guidePoses.filter((_, i) => dists[i][1]).map(pos => pos[1]);\n        }\n        const boundDelta = [0, 0];\n        const {\n            horizontal: horizontalSnapInfo,\n            vertical: verticalSnapInfo,\n        } = checkSnapBounds(\n            guidelines,\n            props.clipTargetBounds && { left: 0, top: 0, right: width, bottom: height },\n            guideXPoses,\n            guideYPoses,\n            5,\n        );\n        let snapOffsetY = horizontalSnapInfo.offset;\n        let snapOffsetX = verticalSnapInfo.offset;\n\n        if (horizontalSnapInfo.isBound) {\n            boundDelta[1] += snapOffsetY;\n        }\n        if (verticalSnapInfo.isBound) {\n            boundDelta[0] += snapOffsetX;\n        }\n        if ((isEllipse || isCircle) && dists[0][0] === 0 && dists[0][1] === 0) {\n            const guideRect = getRect(nextPoses);\n            let cy = guideRect.bottom - guideRect.top;\n            let cx = isEllipse ? guideRect.right - guideRect.left : cy;\n\n\n            const distSnapX = verticalSnapInfo.isBound\n                ? Math.abs(snapOffsetX)\n                : (verticalSnapInfo.snapIndex === 0 ? -snapOffsetX : snapOffsetX);\n            const distSnapY = horizontalSnapInfo.isBound\n                ? Math.abs(snapOffsetY)\n                : (horizontalSnapInfo.snapIndex === 0 ? -snapOffsetY : snapOffsetY);\n            cx -= distSnapX;\n            cy -= distSnapY;\n\n            if (isCircle) {\n                cy = checkSnapBoundPriority(verticalSnapInfo, horizontalSnapInfo) > 0 ? cy : cx;\n                cx = cy;\n            }\n            const center = guidePoses[0];\n\n            guidePoses[1][1] = center[1] - cy;\n            guidePoses[2][0] = center[0] + cx;\n            guidePoses[3][1] = center[1] + cy;\n            guidePoses[4][0] = center[0] - cx;\n        } else if (isRect && keepRatio && isControl) {\n            const [width, height] = getControlSize(clipPoses);\n            const ratio = width && height ? width / height : 0;\n            const clipPose = clipPoses[clipIndex];\n            const direction = clipPose.direction! || \"\";\n            let top = guidePoses[1][1];\n            let bottom = guidePoses[5][1];\n            let left = guidePoses[7][0];\n            let right = guidePoses[3][0];\n\n\n            if (snapOffsetY <= snapOffsetX) {\n                snapOffsetY = snapOffsetX / ratio;\n            } else {\n                snapOffsetX = snapOffsetY * ratio;\n            }\n            if (direction!.indexOf(\"w\") > -1) {\n                left -= snapOffsetX;\n            } else if (direction!.indexOf(\"e\") > -1) {\n                right -= snapOffsetX;\n            } else {\n                left += snapOffsetX / 2;\n                right -= snapOffsetX / 2;\n            }\n            if (direction!.indexOf(\"n\") > -1) {\n                top -= snapOffsetY;\n            } else if (direction!.indexOf(\"s\") > -1) {\n                bottom -= snapOffsetY;\n            } else {\n                top += snapOffsetY / 2;\n                bottom -= snapOffsetY / 2;\n            }\n\n            const nextControlPoses = getRectPoses(top, right, bottom, left);\n\n            guidePoses.forEach((pos, i) => {\n                [pos[0], pos[1]] = nextControlPoses[i].pos;\n            });\n        } else {\n            guidePoses.forEach((pos, j) => {\n                const dist = dists[j];\n\n                if (dist[0]) {\n                    pos[0] -= snapOffsetX;\n                }\n                if (dist[1]) {\n                    pos[1] -= snapOffsetY;\n                }\n            });\n        }\n        const nextClipStyles = getClipStyles(moveable, clipPath, nextPoses)!;\n        const clipStyle = `${clipType}(${nextClipStyles.join(splitter)})`;\n\n        state.clipPathState = clipStyle;\n\n        if (isCircle || isEllipse) {\n            guideXPoses = [guidePoses[4][0], guidePoses[2][0]];\n            guideYPoses = [guidePoses[1][1], guidePoses[3][1]];\n        } else if (isRect) {\n            const rectPoses = [guidePoses[0], guidePoses[2], guidePoses[4], guidePoses[6]];\n\n            guideXPoses = rectPoses.map(pos => pos[0]);\n            guideYPoses = rectPoses.map(pos => pos[1]);\n        } else {\n            guideXPoses = guidePoses.map(pos => pos[0]);\n            guideYPoses = guidePoses.map(pos => pos[1]);\n        }\n        state.snapBoundInfos = checkSnapBounds(\n            guidelines,\n            props.clipTargetBounds && { left: 0, top: 0, right: width, bottom: height },\n            guideXPoses,\n            guideYPoses,\n            1,\n        );\n\n        if (originalDraggable) {\n            const {\n                is3d,\n                allMatrix,\n            } = state;\n            const n = is3d ? 4 : 3;\n\n            let dragDist = boundDelta;\n\n            if (isDragTarget) {\n                dragDist = [\n                    firstDist[0] + boundDelta[0] - originalDist[0],\n                    firstDist[1] + boundDelta[1] - originalDist[1],\n                ];\n            }\n            originalDraggable.deltaOffset = multiply(allMatrix, [dragDist[0], dragDist[1], 0, 0], n);\n        }\n        triggerEvent(moveable, \"onClip\", fillParams<OnClip>(moveable, e, {\n            clipEventType: \"changed\",\n            clipType,\n            poses: nextPoses,\n            clipStyle,\n            clipStyles: nextClipStyles,\n            distX,\n            distY,\n        }));\n\n        return true;\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<ClippableProps, ClippableState>, e: any) {\n        this.unset(moveable);\n        const { isDrag, datas, isDouble } = e;\n        const { isLine, isClipStart, isControl } = datas;\n\n        if (!isClipStart) {\n            return false;\n        }\n        triggerEvent(moveable, \"onClipEnd\", fillEndParams<OnClipEnd>(moveable, e, {}));\n        if (isDouble) {\n            if (isControl) {\n                removeClipPath(moveable, e);\n            } else if (isLine) {\n                // add\n                addClipPath(moveable, e);\n            }\n        }\n        return isDouble || isDrag;\n    },\n    unset(moveable: MoveableManagerInterface<ClippableProps, ClippableState>) {\n        moveable.state.clipPathState = \"\";\n        moveable.state.snapBoundInfos = null;\n    },\n};\n\n/**\n * Whether to clip the target. (default: false)\n * @name Moveable.Clippable#clippable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n *  If clippath is not set, the default value can be set. (defaultClipPath < style < customClipPath < dragging clipPath)\n * @name Moveable.Clippable#defaultClipPath\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * % Can be used instead of the absolute px (`rect` not possible) (default: false)\n * @name Moveable.Clippable#clipRelative\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * You can force the custom clipPath. (defaultClipPath < style < customClipPath < dragging clipPath)\n * @name Moveable.Clippable#customClipPath\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * When dragging the target, the clip also moves. (default: true)\n * @name Moveable.Clippable#dragWithClip\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * You can drag the clip by setting clipArea.\n * @name Moveable.Clippable#clipArea\n * @default false\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n* Whether the clip is bound to the target.\n* @name Moveable.Clippable#clipTargetBounds\n* @default false\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     clippable: true,\n*     defaultClipPath: \"inset\",\n*     customClipPath: \"\",\n*     clipRelative: false,\n*     clipArea: false,\n*     dragWithClip: true,\n*     clipTargetBounds: true,\n* });\n* moveable.on(\"clipStart\", e => {\n*     console.log(e);\n* }).on(\"clip\", e => {\n*     if (e.clipType === \"rect\") {\n*         e.target.style.clip = e.clipStyle;\n*     } else {\n*         e.target.style.clipPath = e.clipStyle;\n*     }\n* }).on(\"clipEnd\", e => {\n*     console.log(e);\n* });\n*/\n\n/**\n * Add clip guidelines in the vertical direction.\n * @name Moveable.Clippable#clipVerticalGuidelines\n * @default 0\n * @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     clippable: true,\n*     defaultClipPath: \"inset\",\n*     customClipPath: \"\",\n*     clipRelative: false,\n*     clipArea: false,\n*     dragWithClip: true,\n*     clipVerticalGuidelines: [0, 100, 200],\n*     clipHorizontalGuidelines: [0, 100, 200],\n*     clipSnapThreshold: 5,\n* });\n*/\n\n/**\n* Add clip guidelines in the horizontal direction.\n* @name Moveable.Clippable#clipHorizontalGuidelines\n* @default []\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     clippable: true,\n*     defaultClipPath: \"inset\",\n*     customClipPath: \"\",\n*     clipRelative: false,\n*     clipArea: false,\n*     dragWithClip: true,\n*     clipVerticalGuidelines: [0, 100, 200],\n*     clipHorizontalGuidelines: [0, 100, 200],\n*     clipSnapThreshold: 5,\n* });\n*/\n/**\n* istance value that can snap to clip guidelines.\n* @name Moveable.Clippable#clipSnapThreshold\n* @default 5\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     clippable: true,\n*     defaultClipPath: \"inset\",\n*     customClipPath: \"\",\n*     clipRelative: false,\n*     clipArea: false,\n*     dragWithClip: true,\n*     clipVerticalGuidelines: [0, 100, 200],\n*     clipHorizontalGuidelines: [0, 100, 200],\n*     clipSnapThreshold: 5,\n* });\n*/\n/**\n * When drag start the clip area or controls, the `clipStart` event is called.\n * @memberof Moveable.Clippable\n * @event clipStart\n * @param {Moveable.Clippable.OnClipStart} - Parameters for the `clipStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n * When drag the clip area or controls, the `clip` event is called.\n * @memberof Moveable.Clippable\n * @event clip\n * @param {Moveable.Clippable.OnClip} - Parameters for the `clip` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n * When drag end the clip area or controls, the `clipEnd` event is called.\n * @memberof Moveable.Clippable\n * @event clipEnd\n * @param {Moveable.Clippable.OnClipEnd} - Parameters for the `clipEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n","import {\n    prefix, triggerEvent,\n    fillParams, calculatePoses, getRect, fillEndParams, convertCSSSize,\n} from \"../utils\";\nimport {\n    OnDragOriginStart, OnDragOrigin,\n    OnDragOriginEnd, MoveableManagerInterface, DraggableProps, OriginDraggableProps, MoveableGroupInterface,\n} from \"../types\";\nimport { hasClass, IObject } from \"@daybrush/utils\";\nimport { setDragStart, getDragDist, getNextMatrix } from \"../gesto/GestoUtils\";\nimport { minus, plus } from \"@scena/matrix\";\nimport Draggable from \"./Draggable\";\nimport CustomGesto, { setCustomDrag } from \"../gesto/CustomGesto\";\n\n/**\n * @namespace OriginDraggable\n * @memberof Moveable\n * @description Whether to drag origin (default: false)\n */\nexport default {\n    name: \"originDraggable\",\n    props: {\n        originDraggable: Boolean,\n        originRelative: Boolean,\n    } as const,\n    events: {\n        onDragOriginStart: \"dragOriginStart\",\n        onDragOrigin: \"dragOrigin\",\n        onDragOriginEnd: \"dragOriginEnd\",\n    } as const,\n    css: [\n        `:host[data-able-origindraggable] .control.origin {\n    pointer-events: auto;\n}`,\n    ],\n    dragControlCondition(_: any, e: any) {\n        if (e.isRequest) {\n            return e.requestAble === \"originDraggable\";\n        }\n        return hasClass(e.inputEvent.target, prefix(\"origin\"));\n    },\n    dragControlStart(moveable: MoveableManagerInterface<OriginDraggableProps & DraggableProps>, e: any) {\n        const { datas } = e;\n\n        setDragStart(moveable, e);\n\n        const params = fillParams<OnDragOriginStart>(moveable, e, {\n            dragStart: Draggable.dragStart(\n                moveable,\n                new CustomGesto().dragStart([0, 0], e),\n            ),\n        });\n        const result = triggerEvent(moveable, \"onDragOriginStart\", params);\n\n        datas.startOrigin = moveable.state.transformOrigin;\n        datas.startTargetOrigin = moveable.state.targetOrigin;\n        datas.prevOrigin = [0, 0];\n        datas.isDragOrigin = true;\n\n        if (result === false) {\n            datas.isDragOrigin = false;\n            return false;\n        }\n\n        return params;\n    },\n    dragControl(moveable: MoveableManagerInterface<OriginDraggableProps & DraggableProps>, e: any) {\n        const { datas, isPinch, isRequest } = e;\n\n        if (!datas.isDragOrigin) {\n            return false;\n        }\n        const [distX, distY] = getDragDist(e);\n        const state = moveable.state;\n        const {\n            width,\n            height,\n            offsetMatrix,\n            targetMatrix,\n            is3d,\n        } = state;\n        const {\n            originRelative = true,\n        } = moveable.props;\n        const n = is3d ? 4 : 3;\n        let dist = [distX, distY];\n\n        if (isRequest) {\n            const distOrigin = e.distOrigin;\n            if (distOrigin[0] || distOrigin[1]) {\n                dist = distOrigin;\n            }\n        }\n        const origin = plus(datas.startOrigin, dist);\n        const targetOrigin = plus(datas.startTargetOrigin, dist);\n        const delta = minus(dist, datas.prevOrigin);\n\n        const nextMatrix = getNextMatrix(\n            offsetMatrix,\n            targetMatrix,\n            origin,\n            n,\n        );\n\n        const rect = moveable.getRect();\n        const nextRect = getRect(calculatePoses(nextMatrix, width, height, n));\n\n        const dragDelta = [\n            rect.left - nextRect.left,\n            rect.top - nextRect.top,\n        ];\n\n        datas.prevOrigin = dist;\n        const transformOrigin = [\n            convertCSSSize(targetOrigin[0], width, originRelative),\n            convertCSSSize(targetOrigin[1], height, originRelative),\n        ].join(\" \");\n        const params = fillParams<OnDragOrigin>(moveable, e, {\n            width,\n            height,\n            origin,\n            dist,\n            delta,\n            transformOrigin,\n            drag: Draggable.drag(\n                moveable,\n                setCustomDrag(e, moveable.state, dragDelta, !!isPinch, false),\n            )!,\n        });\n        triggerEvent(moveable, \"onDragOrigin\", params);\n        return params;\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<OriginDraggableProps>, e: any) {\n        const { datas } = e;\n\n        if (!datas.isDragOrigin) {\n            return false;\n        }\n        triggerEvent(moveable, \"onDragOriginEnd\",\n            fillEndParams<OnDragOriginEnd>(moveable, e, {}));\n        return true;\n    },\n    dragGroupControlCondition(moveable: any, e: any) {\n        return this.dragControlCondition(moveable, e);\n    },\n    dragGroupControlStart(moveable: MoveableGroupInterface<OriginDraggableProps>, e: any) {\n        const params = this.dragControlStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n\n        return true;\n    },\n    dragGroupControl(moveable: MoveableGroupInterface<OriginDraggableProps>, e: any) {\n        const params = this.dragControl(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n        moveable.transformOrigin = params.transformOrigin;\n\n        return true;\n    },\n    /**\n    * @method Moveable.OriginDraggable#request\n    * @param {object} e - the OriginDraggable's request parameter\n    * @param {number} [e.x] - x position\n    * @param {number} [e.y] - y position\n    * @param {number} [e.deltaX] - x number to move\n    * @param {number} [e.deltaY] - y number to move\n    * @param {array} [e.deltaOrigin] - left, top number to move transform-origin\n    * @param {array} [e.origin] - transform-origin position\n    * @param {number} [e.isInstant] - Whether to execute the request instantly\n    * @return {Moveable.Requester} Moveable Requester\n    * @example\n\n    * // Instantly Request (requestStart - request - requestEnd)\n    * // Use Relative Value\n    * moveable.request(\"originDraggable\", { deltaX: 10, deltaY: 10 }, true);\n    * // Use Absolute Value\n    * moveable.request(\"originDraggable\", { x: 200, y: 100 }, true);\n    * // Use Transform Value\n    * moveable.request(\"originDraggable\", { deltaOrigin: [10, 0] }, true);\n    * moveable.request(\"originDraggable\", { origin: [100, 0] }, true);\n    * // requestStart\n    * const requester = moveable.request(\"originDraggable\");\n    *\n    * // request\n    * // Use Relative Value\n    * requester.request({ deltaX: 10, deltaY: 10 });\n    * requester.request({ deltaX: 10, deltaY: 10 });\n    * requester.request({ deltaX: 10, deltaY: 10 });\n    * // Use Absolute Value\n    * moveable.request(\"originDraggable\", { x: 200, y: 100 });\n    * moveable.request(\"originDraggable\", { x: 220, y: 100 });\n    * moveable.request(\"originDraggable\", { x: 240, y: 100 });\n    *\n    * // requestEnd\n    * requester.requestEnd();\n    */\n    request(moveable: MoveableManagerInterface<any, any>) {\n        const datas = {};\n        const rect = moveable.getRect();\n        let distX = 0;\n        let distY = 0;\n\n        const transformOrigin = rect.transformOrigin;\n        const distOrigin = [0, 0];\n\n        return {\n            isControl: true,\n            requestStart() {\n                return { datas };\n            },\n            request(e: IObject<any>) {\n                if (\"deltaOrigin\" in e) {\n                    distOrigin[0] += e.deltaOrigin[0];\n                    distOrigin[1] += e.deltaOrigin[1];\n                } else if (\"origin\" in e) {\n                    distOrigin[0] = e.origin[0] - transformOrigin[0];\n                    distOrigin[1] = e.origin[1] - transformOrigin[1];\n                } else {\n                    if (\"x\" in e) {\n                        distX = e.x - rect.left;\n                    } else if (\"deltaX\" in e) {\n                        distX += e.deltaX;\n                    }\n                    if (\"y\" in e) {\n                        distY = e.y - rect.top;\n                    } else if (\"deltaY\" in e) {\n                        distY += e.deltaY;\n                    }\n                }\n\n                return { datas, distX, distY, distOrigin };\n            },\n            requestEnd() {\n                return { datas, isDrag: true };\n            },\n        };\n    },\n};\n/**\n * Whether to drag origin (default: false)\n * @name Moveable.OriginDraggable#originDraggable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     originDraggable: true,\n * });\n * let translate = [0, 0];\n * moveable.on(\"dragOriginStart\", e => {\n *     e.dragStart && e.dragStart.set(translate);\n * }).on(\"dragOrigin\", e => {\n *     translate = e.drag.beforeTranslate;\n *     e.target.style.cssText\n *         = `transform-origin: ${e.transformOrigin};`\n *         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\n * }).on(\"dragOriginEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * % Can be used instead of the absolute px (default: true)\n * @name Moveable.OriginDraggable#originRelative\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     originDraggable: true,\n *     originRelative: false,\n * });\n * moveable.originRelative = true;\n */\n\n/**\n* When drag start the origin, the `dragOriginStart` event is called.\n* @memberof Moveable.OriginDraggable\n* @event dragOriginStart\n* @param {Moveable.OriginDraggable.OnDragOriginStart} - Parameters for the `dragOriginStart` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     originDraggable: true,\n* });\n* let translate = [0, 0];\n* moveable.on(\"dragOriginStart\", e => {\n*     e.dragStart && e.dragStart.set(translate);\n* }).on(\"dragOrigin\", e => {\n*     translate = e.drag.beforeTranslate;\n*     e.target.style.cssText\n*         = `transform-origin: ${e.transformOrigin};`\n*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\n* }).on(\"dragOriginEnd\", e => {\n*     console.log(e);\n* });\n*/\n\n/**\n* When drag the origin, the `dragOrigin` event is called.\n* @memberof Moveable.OriginDraggable\n* @event dragOrigin\n* @param {Moveable.OriginDraggable.OnDragOrigin} - Parameters for the `dragOrigin` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     originDraggable: true,\n* });\n* let translate = [0, 0];\n* moveable.on(\"dragOriginStart\", e => {\n*     e.dragStart && e.dragStart.set(translate);\n* }).on(\"dragOrigin\", e => {\n*     translate = e.drag.beforeTranslate;\n*     e.target.style.cssText\n*         = `transform-origin: ${e.transformOrigin};`\n*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\n* }).on(\"dragOriginEnd\", e => {\n*     console.log(e);\n* });\n*/\n\n/**\n* When drag end the origin, the `dragOriginEnd` event is called.\n* @memberof Moveable.OriginDraggable\n* @event dragOriginEnd\n* @param {Moveable.OriginDraggable.OnDragOriginEnd} - Parameters for the `dragOriginEnd` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     originDraggable: true,\n* });\n* let translate = [0, 0];\n* moveable.on(\"dragOriginStart\", e => {\n*     e.dragStart && e.dragStart.set(translate);\n* }).on(\"dragOrigin\", e => {\n*     translate = e.drag.beforeTranslate;\n*     e.target.style.cssText\n*         = `transform-origin: ${e.transformOrigin};`\n*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\n* }).on(\"dragOriginEnd\", e => {\n*     console.log(e);\n* });\n*/\n","import {\n    prefix, triggerEvent,\n    fillParams, fillEndParams, calculatePosition,\n    getComputedStyle,\n} from \"../utils\";\nimport {\n    Renderer, RoundableProps, OnRoundStart, RoundableState, OnRound, ControlPose, OnRoundEnd, MoveableManagerInterface,\n} from \"../types\";\nimport { splitSpace } from \"@daybrush/utils\";\nimport { setDragStart, getDragDist, calculatePointerDist } from \"../gesto/GestoUtils\";\nimport { minus, plus } from \"@scena/matrix\";\nimport {\n    getRadiusValues, getRadiusStyles, removeRadiusPos,\n    addRadiusPos, splitRadiusPoses,\n} from \"./roundable/borderRadius\";\n\nfunction addBorderRadius(\n    controlPoses: ControlPose[],\n    poses: number[][],\n    lineIndex: number,\n    distX: number,\n    distY: number,\n    width: number,\n    height: number,\n) {\n    const {\n        horizontals,\n        verticals,\n    } = splitRadiusPoses(controlPoses);\n    const horizontalsLength = horizontals.length;\n    const verticalsLength = verticals.length;\n    // lineIndex\n    // 0 top\n    // 1 right\n    // 2 left\n    // 3 bottom\n\n    // 0 top - left\n    // 1 top - right\n    // 2 bottom - right\n    // 3 bottom - left\n    // 0 left - top\n    // 1 right - top\n    // 2 right - bottom\n    // 3 left - bottom\n    let horizontalIndex = -1;\n    let verticalIndex = -1;\n\n    if (lineIndex === 0) {\n        if (horizontalsLength === 0) {\n            horizontalIndex = 0;\n        } else if (horizontalsLength === 1) {\n            horizontalIndex = 1;\n        }\n    } else if (lineIndex === 3) {\n        if (horizontalsLength <= 2) {\n            horizontalIndex = 2;\n        } else if (horizontalsLength <= 3) {\n            horizontalIndex = 3;\n        }\n    }\n    if (lineIndex === 2) {\n        if (verticalsLength === 0) {\n            verticalIndex = 0;\n        } else if (verticalsLength < 4) {\n            verticalIndex = 3;\n        }\n    } else if (lineIndex === 1) {\n        if (verticalsLength <= 1) {\n            verticalIndex = 1;\n        } else if (verticalsLength <= 2) {\n            verticalIndex = 2;\n        }\n    }\n\n    addRadiusPos(\n        controlPoses, poses, 0,\n        horizontalIndex, verticalIndex,\n        distX, distY, width, height,\n    );\n}\nfunction getBorderRadius(\n    target: HTMLElement | SVGElement,\n    width: number, height: number,\n    minCounts: number[] = [0, 0],\n    state?: string,\n) {\n    let borderRadius: string;\n    let values: string[] = [];\n\n    if (!state) {\n        const style = getComputedStyle(target);\n\n        borderRadius = (style && style.borderRadius) || \"\";\n    } else {\n        borderRadius = state;\n    }\n    if (!borderRadius || (!state && borderRadius === \"0px\")) {\n        values = [];\n    } else {\n        values = splitSpace(borderRadius);\n    }\n\n    return getRadiusValues(values, width, height, 0, 0, minCounts);\n}\n\nfunction triggerRoundEvent(\n    moveable: MoveableManagerInterface<RoundableProps, RoundableState>,\n    e: any,\n    dist: number[],\n    delta: number[],\n    controlPoses: ControlPose[],\n    nextPoses: number[][],\n) {\n    const state = moveable.state;\n    const {\n        width,\n        height,\n    } = state;\n    const {\n        raws,\n        styles,\n    } = getRadiusStyles(\n        nextPoses,\n        controlPoses,\n        moveable.props.roundRelative!,\n        width,\n        height,\n    );\n    const {\n        horizontals,\n        verticals,\n    } = splitRadiusPoses(controlPoses, raws);\n    const borderRadius = styles.join(\" \");\n\n    state.borderRadiusState = borderRadius;\n    triggerEvent(moveable, \"onRound\", fillParams<OnRound>(moveable, e, {\n        horizontals,\n        verticals,\n        borderRadius,\n        width,\n        height,\n        delta,\n        dist,\n    }));\n}\n\n/**\n * @namespace Moveable.Roundable\n * @description Whether to show and drag or double click border-radius\n */\n\nexport default {\n    name: \"roundable\",\n    props: {\n        roundable: Boolean,\n        roundRelative: Boolean,\n        minRoundControls: Array,\n        maxRoundControls: Array,\n        roundClickable: Boolean,\n    } as const,\n    events: {\n        onRoundStart: \"roundStart\",\n        onRound: \"round\",\n        onRoundEnd: \"roundEnd\",\n    } as const,\n    css: [\n        `.control.border-radius {\n    background: #d66;\n    cursor: pointer;\n}`,\n        `:host[data-able-roundable] .line.direction {\n    cursor: pointer;\n}`,\n    ],\n    render(moveable: MoveableManagerInterface<RoundableProps, RoundableState>, React: Renderer): any {\n        const {\n            target,\n            width,\n            height,\n            allMatrix,\n            is3d,\n            left,\n            top,\n            borderRadiusState,\n        } = moveable.state;\n        const {\n            minRoundControls = [0, 0],\n            maxRoundControls = [4, 4],\n            zoom,\n        } = moveable.props;\n\n        if (!target) {\n            return null;\n        }\n\n        const n = is3d ? 4 : 3;\n        const radiusValues = getBorderRadius(\n            target, width, height, minRoundControls, borderRadiusState);\n\n        if (!radiusValues) {\n            return null;\n        }\n        let verticalCount = 0;\n        let horizontalCount = 0;\n\n        return radiusValues.map((v, i) => {\n            horizontalCount += Math.abs(v.horizontal);\n            verticalCount += Math.abs(v.vertical);\n            const pos = minus(calculatePosition(allMatrix, v.pos, n), [left, top]);\n            const isDisplay = v.vertical\n                ? verticalCount <= maxRoundControls[1]\n                : horizontalCount <= maxRoundControls[0];\n\n            return <div key={`borderRadiusControl${i}`}\n                className={prefix(\"control\", \"border-radius\")}\n                data-radius-index={i}\n                style={{\n                    display: isDisplay ? \"block\" : \"none\",\n                    transform: `translate(${pos[0]}px, ${pos[1]}px) scale(${zoom})`,\n                }}></div>;\n        });\n    },\n    dragControlCondition(moveable: any, e: any) {\n        if (!e.inputEvent || e.isRequest) {\n            return false;\n        }\n        const className = (e.inputEvent.target.getAttribute(\"class\") || \"\");\n\n        return className.indexOf(\"border-radius\") > -1\n            || (className.indexOf(\"moveable-line\") > -1 && className.indexOf(\"moveable-direction\") > -1);\n    },\n    dragControlStart(moveable: MoveableManagerInterface<RoundableProps, RoundableState>, e: any) {\n        const { inputEvent, datas } = e;\n        const inputTarget = inputEvent.target;\n        const className = (inputTarget.getAttribute(\"class\") || \"\");\n        const isControl = className.indexOf(\"border-radius\") > -1;\n        const isLine = className.indexOf(\"moveable-line\") > -1 && className.indexOf(\"moveable-direction\") > -1;\n        const controlIndex = isControl ? parseInt(inputTarget.getAttribute(\"data-radius-index\"), 10) : -1;\n        const lineIndex = isLine ? parseInt(inputTarget.getAttribute(\"data-line-index\"), 10) : -1;\n\n        if (!isControl && !isLine) {\n            return false;\n        }\n\n        const result = triggerEvent(\n            moveable, \"onRoundStart\", fillParams<OnRoundStart>(moveable, e, {}));\n\n        if (result === false) {\n            return false;\n        }\n\n        datas.lineIndex = lineIndex;\n        datas.controlIndex = controlIndex;\n        datas.isControl = isControl;\n        datas.isLine = isLine;\n\n        setDragStart(moveable, e);\n\n        const {\n            roundRelative,\n            minRoundControls = [0, 0],\n        } = moveable.props;\n        const state = moveable.state;\n        const {\n            target,\n            width,\n            height,\n        } = state;\n\n        datas.isRound = true;\n        datas.prevDist = [0, 0];\n        const controlPoses = getBorderRadius(target!, width, height, minRoundControls) || [];\n\n        datas.controlPoses = controlPoses;\n\n        state.borderRadiusState = getRadiusStyles(\n            controlPoses.map(pos => pos.pos), controlPoses, roundRelative!, width, height).styles.join(\" \");\n        return true;\n    },\n    dragControl(moveable: MoveableManagerInterface<RoundableProps, RoundableState>, e: any) {\n        const { datas } = e;\n\n        if (!datas.isRound || !datas.isControl || !datas.controlPoses.length) {\n            return false;\n        }\n        const index = datas.controlIndex as number;\n        const controlPoses = datas.controlPoses as ControlPose[];\n        const [distX, distY] = getDragDist(e);\n        const dist = [distX, distY];\n        const delta = minus(dist, datas.prevDist);\n        const {\n            maxRoundControls = [4, 4],\n        } = moveable.props;\n        const { width, height } = moveable.state;\n        const selectedControlPose = controlPoses[index];\n        const selectedVertical = selectedControlPose.vertical;\n        const selectedHorizontal = selectedControlPose.horizontal;\n\n        // 0: [0, 1, 2, 3] maxCount === 1\n        // 0: [0, 2] maxCount === 2\n        // 1: [1, 3] maxCount === 2\n\n        // 0: [0] maxCount === 3\n        // 1: [1, 3] maxCount === 3\n\n        const dists = controlPoses.map(pose => {\n            const { horizontal, vertical } = pose;\n            const poseDist = [\n                horizontal * selectedHorizontal * dist[0],\n                vertical * selectedVertical * dist[1],\n            ];\n            if (horizontal) {\n                if (maxRoundControls[0] === 1) {\n                    return poseDist;\n                } else if (maxRoundControls[0] < 4 && horizontal !== selectedHorizontal) {\n                    return poseDist;\n                }\n            } else if (maxRoundControls[1] === 0) {\n                poseDist[1] = vertical * selectedHorizontal * dist[0] / width * height;\n\n                return poseDist;\n            } else if (selectedVertical) {\n                if (maxRoundControls[1] === 1) {\n                    return poseDist;\n                } else if (maxRoundControls[1] < 4 && vertical !== selectedVertical) {\n                    return poseDist;\n                }\n            }\n            return [0, 0];\n        });\n        dists[index] = dist;\n        const nextPoses = controlPoses.map((pos, i) => plus(pos.pos, dists[i]));\n\n        datas.prevDist = [distX, distY];\n\n        triggerRoundEvent(\n            moveable,\n            e,\n            dist,\n            delta,\n            controlPoses,\n            nextPoses,\n        );\n        return true;\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<RoundableProps, RoundableState>, e: any) {\n        const state = moveable.state;\n\n        state.borderRadiusState = \"\";\n        const { datas, isDouble } = e;\n        if (!datas.isRound) {\n            return false;\n        }\n        const {\n            width,\n            height,\n        } = state;\n        const {\n            isControl,\n            controlIndex,\n            isLine,\n            lineIndex,\n        } = datas;\n        const controlPoses = datas.controlPoses as ControlPose[];\n        const poses = controlPoses.map(pos => pos.pos);\n        const length = poses.length;\n        const {\n            roundClickable = true,\n        } = moveable.props;\n\n        if (isDouble && roundClickable) {\n            if (isControl) {\n                removeRadiusPos(controlPoses, poses, controlIndex, 0);\n            } else if (isLine) {\n                const [distX, distY] = calculatePointerDist(moveable, e);\n\n                addBorderRadius(controlPoses, poses, lineIndex, distX, distY, width, height);\n            }\n            if (length !== controlPoses.length) {\n                triggerRoundEvent(\n                    moveable,\n                    e,\n                    [0, 0],\n                    [0, 0],\n                    controlPoses,\n                    poses,\n                );\n            }\n        }\n        triggerEvent(moveable, \"onRoundEnd\",\n            fillEndParams<OnRoundEnd>(moveable, e, {}));\n        state.borderRadiusState = \"\";\n        return true;\n    },\n    unset(moveable: MoveableManagerInterface<RoundableProps, RoundableState>) {\n        moveable.state.borderRadiusState = \"\";\n    },\n};\n/**\n * Whether to show and drag or double click border-radius, (default: false)\n * @name Moveable.Roundable#roundable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n * % Can be used instead of the absolute px\n * @name Moveable.Roundable#roundRelative\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n * Minimum number of round controls. It moves in proportion by control. [horizontal, vertical] (default: [0, 0])\n * @name Moveable.Roundable#minRoundControls\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n *     minRoundControls: [0, 0],\n * });\n * moveable.maxRoundControls = [1, 0];\n */\n/**\n * Maximum number of round controls. It moves in proportion by control. [horizontal, vertical] (default: [4, 4])\n * @name Moveable.Roundable#maxRoundControls\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n *     maxRoundControls: [4, 4],\n * });\n * moveable.maxRoundControls = [1, 0];\n */\n/**\n * @property - Whether you can add/delete round controls by double-clicking a line or control. (default: true)\n * @name Moveable.Roundable#roundClickable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n *     roundClickable: true,\n * });\n * moveable.roundClickable = false;\n */\n\n/**\n * When drag start the clip area or controls, the `roundStart` event is called.\n * @memberof Moveable.Roundable\n * @event roundStart\n * @param {Moveable.Roundable.OnRoundStart} - Parameters for the `roundStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n * When drag or double click the border area or controls, the `round` event is called.\n * @memberof Moveable.Roundable\n * @event round\n * @param {Moveable.Roundable.OnRound} - Parameters for the `round` event\n * @example\n  * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n * When drag end the border area or controls, the `roundEnd` event is called.\n * @memberof Moveable.Roundable\n * @event roundEnd\n * @param {Moveable.Roundable.onRoundEnd} - Parameters for the `roundEnd` event\n * @example\n  * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n","import {\n    MoveableManagerInterface, BeforeRenderableProps,\n    OnBeforeRenderStart, OnBeforeRender, OnBeforeRenderEnd,\n    MoveableGroupInterface, OnBeforeRenderGroupStart,\n    OnBeforeRenderGroup, OnBeforeRenderGroupEnd,\n} from \"../types\";\nimport { fillParams, triggerEvent } from \"../utils\";\nimport { convertMatrixtoCSS, createIdentityMatrix } from \"@scena/matrix\";\nimport { isArray, splitSpace } from \"@daybrush/utils\";\nimport { fillChildEvents } from \"../groupUtils\";\n\n\nfunction isIdentityMatrix(matrix: string, is3d?: boolean) {\n    const n = is3d ? 4 : 3;\n    const identityMatrix = createIdentityMatrix(n);\n    const value = `matrix${is3d ? \"3d\" : \"\"}(${identityMatrix.join(\",\")})`;\n\n    return matrix === value || matrix === `matrix(1,0,0,1,0,0)`;\n}\nexport default {\n    isPinch: true,\n    name: \"beforeRenderable\",\n    props: {\n    } as const,\n    events: {\n        onBeforeRenderStart: \"beforeRenderStart\",\n        onBeforeRender: \"beforeRender\",\n        onBeforeRenderEnd: \"beforeRenderEnd\",\n        onBeforeRenderGroupStart: \"beforeRenderGroupStart\",\n        onBeforeRenderGroup: \"beforeRenderGroup\",\n        onBeforeRenderGroupEnd: \"beforeRenderGroupEnd\",\n    } as const,\n    dragRelation: \"weak\",\n    setTransform(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        const {\n            is3d,\n            target,\n            targetMatrix,\n        } = moveable.state;\n        const transform = target?.style.transform;\n        const cssMatrix = is3d\n            ? `matrix3d(${targetMatrix.join(\",\")})`\n            : `matrix(${convertMatrixtoCSS(targetMatrix, true)})`;\n        const startTransform = !transform || transform === \"none\" ? cssMatrix : transform;\n\n        e.datas.startTransforms = isIdentityMatrix(startTransform, is3d) ? [] : splitSpace(startTransform);\n    },\n    resetStyle(e: any) {\n        const datas = e.datas;\n\n        datas.nextStyle = {};\n        datas.nextTransforms = e.datas.startTransforms;\n        datas.nextTransformAppendedIndexes = [];\n    },\n    fillDragStartParams(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        return fillParams<OnBeforeRenderStart>(moveable, e, {\n            setTransform: (transform: string | string[]) => {\n                e.datas.startTransforms = isArray(transform) ? transform : splitSpace(transform);\n            },\n            isPinch: !!e.isPinch,\n        });\n    },\n    fillDragParams(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        return fillParams<OnBeforeRender>(moveable, e, {\n            isPinch: !!e.isPinch,\n        });\n    },\n    dragStart(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        this.setTransform(moveable, e);\n\n        triggerEvent(moveable, `onBeforeRenderStart`, this.fillDragStartParams(moveable, e));\n    },\n    drag(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        this.resetStyle(e);\n        const datas = e.datas;\n\n        datas.nextStyle = {};\n        triggerEvent(moveable, `onBeforeRender`, fillParams<OnBeforeRender>(moveable, e, {\n            isPinch: !!e.isPinch,\n        }));\n    },\n    dragEnd(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        triggerEvent(moveable, `onBeforeRenderEnd`, fillParams<OnBeforeRenderEnd>(moveable, e, {\n            isPinch: !!e.isPinch,\n            isDrag: e.isDrag,\n        }));\n    },\n    dragGroupStart(moveable: MoveableGroupInterface<BeforeRenderableProps>, e: any) {\n        this.dragStart(moveable, e);\n\n        const events = fillChildEvents(moveable, \"beforeRenderable\", e);\n        const moveables = moveable.moveables;\n        const params = events.map((childEvent, i) => {\n            const childMoveable = moveables[i];\n\n            this.setTransform(childMoveable, childEvent);\n            return this.fillDragStartParams(childMoveable, childEvent);\n        });\n        triggerEvent(moveable, `onBeforeRenderGroupStart`, fillParams<OnBeforeRenderGroupStart>(moveable, e, {\n            isPinch: !!e.isPinch,\n            targets: moveable.props.targets,\n            setTransform() { },\n            events: params,\n        }));\n    },\n    dragGroup(moveable: MoveableGroupInterface<BeforeRenderableProps>, e: any) {\n        this.drag(moveable, e);\n\n        const events = fillChildEvents(moveable, \"beforeRenderable\", e);\n        const moveables = moveable.moveables;\n        const params = events.map((childEvent, i) => {\n            const childMoveable = moveables[i];\n\n            this.resetStyle(childEvent);\n            const datas = e.datas;\n\n            datas.nextStyle = {};\n            return this.fillDragParams(childMoveable, childEvent);\n        });\n        triggerEvent(moveable, `onBeforeRenderGroup`, fillParams<OnBeforeRenderGroup>(moveable, e, {\n            isPinch: !!e.isPinch,\n            targets: moveable.props.targets,\n            events: params,\n        }));\n    },\n    dragGroupEnd(moveable: MoveableGroupInterface<BeforeRenderableProps>, e: any) {\n        this.dragEnd(moveable, e);\n\n        triggerEvent(moveable, `onBeforeRenderGroupEnd`, fillParams<OnBeforeRenderGroupEnd>(moveable, e, {\n            isPinch: !!e.isPinch,\n            isDrag: e.isDrag,\n            targets: moveable.props.targets,\n        }));\n    },\n    dragControlStart(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        return this.dragStart(moveable, e);\n    },\n    dragControl(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        return this.drag(moveable, e);\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        return this.dragEnd(moveable, e);\n    },\n    dragGroupControlStart(moveable: MoveableGroupInterface<BeforeRenderableProps>, e: any) {\n        return this.dragGroupStart(moveable, e);\n    },\n    dragGroupControl(moveable: MoveableGroupInterface<BeforeRenderableProps>, e: any) {\n        return this.dragGroup(moveable, e);\n    },\n    dragGroupControlEnd(moveable: MoveableGroupInterface<BeforeRenderableProps>, e: any) {\n        return this.dragGroupEnd(moveable, e);\n    },\n} as const;\n","import { getNextStyle, getNextTransformText } from \"../gesto/GestoUtils\";\nimport { fillChildEvents } from \"../groupUtils\";\nimport {\n    MoveableManagerInterface, RenderableProps, OnRenderStart, OnRender,\n    OnRenderEnd, MoveableGroupInterface,\n    OnRenderGroupStart, OnRenderGroup, OnRenderGroupEnd,\n} from \"../types\";\nimport { triggerEvent, fillParams, fillCSSObject } from \"../utils\";\n\nexport default {\n    name: \"renderable\",\n    props: {\n    } as const,\n    events: {\n        onRenderStart: \"renderStart\",\n        onRender: \"render\",\n        onRenderEnd: \"renderEnd\",\n        onRenderGroupStart: \"renderGroupStart\",\n        onRenderGroup: \"renderGroup\",\n        onRenderGroupEnd: \"renderGroupEnd\",\n    } as const,\n    dragRelation: \"weak\",\n    dragStart(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        triggerEvent(moveable, `onRenderStart`, fillParams<OnRenderStart>(moveable, e, {\n            isPinch: !!e.isPinch,\n        }));\n    },\n    drag(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        triggerEvent(moveable, `onRender`, this.fillDragParams(moveable, e));\n    },\n    dragAfter(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        if (e.resultCount) {\n            return this.drag(moveable, e);\n        }\n    },\n    dragEnd(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        triggerEvent(moveable, `onRenderEnd`, this.fillDragEndParams(moveable, e));\n    },\n    dragGroupStart(moveable: MoveableGroupInterface<RenderableProps>, e: any) {\n        triggerEvent(moveable, `onRenderGroupStart`, fillParams<OnRenderGroupStart>(moveable, e, {\n            isPinch: !!e.isPinch,\n            targets: moveable.props.targets,\n        }));\n    },\n    dragGroup(moveable: MoveableGroupInterface<RenderableProps>, e: any) {\n        const events = fillChildEvents(moveable, \"beforeRenderable\", e);\n        const moveables = moveable.moveables;\n        const params = events.map((childEvent, i) => {\n            const childMoveable = moveables[i];\n\n            return this.fillDragParams(childMoveable, childEvent);\n        });\n\n        triggerEvent(moveable, `onRenderGroup`, fillParams<OnRenderGroup>(moveable, e, {\n            isPinch: !!e.isPinch,\n            targets: moveable.props.targets,\n            transform: getNextTransformText(e),\n            ...fillCSSObject(getNextStyle(e)),\n            events: params,\n        },));\n    },\n    dragGroupEnd(moveable: MoveableGroupInterface<RenderableProps>, e: any) {\n        const events = fillChildEvents(moveable, \"beforeRenderable\", e);\n        const moveables = moveable.moveables;\n        const params = events.map((childEvent, i) => {\n            const childMoveable = moveables[i];\n\n            return this.fillDragEndParams(childMoveable, childEvent);\n        });\n\n        triggerEvent(moveable, `onRenderGroupEnd`, fillParams<OnRenderGroupEnd>(moveable, e, {\n            isPinch: !!e.isPinch,\n            isDrag: e.isDrag,\n            targets: moveable.props.targets,\n            events: params,\n        }));\n    },\n    dragControlStart(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        return this.dragStart(moveable, e);\n    },\n    dragControl(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        return this.drag(moveable, e);\n    },\n    dragControlAfter(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        return this.dragAfter(moveable, e);\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        return this.dragEnd(moveable, e);\n    },\n    dragGroupControlStart(moveable: MoveableGroupInterface<RenderableProps>, e: any) {\n        return this.dragGroupStart(moveable, e);\n    },\n    dragGroupControl(moveable: MoveableGroupInterface<RenderableProps>, e: any) {\n        return this.dragGroup(moveable, e);\n    },\n    dragGroupControlEnd(moveable: MoveableGroupInterface<RenderableProps>, e: any) {\n        return this.dragGroupEnd(moveable, e);\n    },\n    fillDragParams(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        return fillParams<OnRender>(moveable, e, {\n            isPinch: !!e.isPinch,\n            transform: getNextTransformText(e),\n            ...fillCSSObject(getNextStyle(e)),\n        });\n    },\n    fillDragEndParams(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        return fillParams<OnRenderEnd>(moveable, e, {\n            isPinch: !!e.isPinch,\n            isDrag: e.isDrag,\n        });\n    },\n} as const;\n","import { Able, MoveableManagerInterface, MoveableGroupInterface } from \"../types\";\nimport { hasClass, IObject } from \"@daybrush/utils\";\nimport { convertDragDist, defaultSync } from \"../utils\";\nimport Gesto, { GestoOptions } from \"gesto\";\nimport BeforeRenderable from \"../ables/BeforeRenderable\";\nimport Renderable from \"../ables/Renderable\";\n\nexport function triggerAble(\n    moveable: MoveableManagerInterface,\n    ableType: string,\n    eventOperation: string,\n    eventAffix: string,\n    eventType: any,\n    e: any,\n    requestInstant?: boolean,\n) {\n    const isStart = eventType === \"Start\";\n    const target = moveable.state.target;\n    const isRequest = e.isRequest;\n\n    if (\n        !target\n        || (isStart && eventAffix.indexOf(\"Control\") > -1\n            && !isRequest && moveable.areaElement === e.inputEvent.target)\n    ) {\n        return false;\n    }\n    // \"drag\" \"Control\" \"After\"\n    const eventName = `${eventOperation}${eventAffix}${eventType}`;\n    const conditionName = `${eventOperation}${eventAffix}Condition`;\n    const isEnd = eventType === \"End\";\n    const isAfter = eventType === \"After\";\n    const isFirstStart = isStart && (\n        !moveable.targetGesto || !moveable.controlGesto\n        || (!moveable.targetGesto.isFlag() || !moveable.controlGesto.isFlag())\n    );\n\n    if (isFirstStart) {\n        moveable.updateRect(eventType, true, false);\n    }\n    if (eventType === \"\" && !isRequest) {\n        convertDragDist(moveable.state, e);\n    }\n    // const isGroup = eventAffix.indexOf(\"Group\") > -1;\n    const ables: Able[] = [...(moveable as any)[ableType]];\n\n    if (isRequest) {\n        const requestAble = e.requestAble;\n\n        if (!ables.some(able => able.name === requestAble)) {\n            ables.push(...moveable.props.ables!.filter(able => able.name === requestAble));\n        }\n    }\n    if (!ables.length) {\n        return false;\n    }\n    const eventAbles: Able[] = [BeforeRenderable, ...ables, Renderable].filter((able: any) => able[eventName]);\n    const datas = e.datas;\n\n    if (isFirstStart) {\n        eventAbles.forEach(able => {\n            able.unset && able.unset(moveable);\n        });\n    }\n\n    const inputEvent = e.inputEvent;\n    let inputTarget: Element;\n\n    if (isEnd && inputEvent) {\n        inputTarget = document.elementFromPoint(e.clientX, e.clientY) || inputEvent.target;\n    }\n    let resultCount = 0;\n    const results = eventAbles.filter((able: any) => {\n        const ableName = able.name;\n        const nextDatas = datas[ableName] || (datas[ableName] = {});\n\n        if (isStart) {\n            nextDatas.isEventStart = !able[conditionName] || able[conditionName](moveable, e);\n        }\n\n        if (nextDatas.isEventStart) {\n            const result = able[eventName](moveable, {\n                ...e,\n                resultCount,\n                datas: nextDatas,\n                originalDatas: datas,\n                inputTarget,\n            });\n\n            (moveable as any)._emitter.off();\n            if (isStart && result === false) {\n                nextDatas.isEventStart = false;\n            }\n            resultCount += result ? 1 : 0;\n            return result;\n        }\n        return false;\n    });\n\n    const isUpdate = results.length;\n    let isForceEnd = false;\n\n    // end ables\n    if (isStart && eventAbles.length && !isUpdate) {\n        isForceEnd = eventAbles.filter(able => {\n            const ableName = able.name;\n            const nextDatas = datas[ableName];\n\n            if (nextDatas.isEventStart) {\n                if (able.dragRelation === \"strong\") {\n                    // cancel drag\n                    nextDatas.isEventStart = false;\n\n                    return false;\n                }\n                // start drag\n                return true;\n            }\n            // cancel event\n            return false;\n        }).length === 0;\n    }\n    if (isEnd || isForceEnd) {\n        moveable.state.gestos = {};\n\n        if ((moveable as MoveableGroupInterface).moveables) {\n            (moveable as MoveableGroupInterface).moveables.forEach(childMoveable => {\n                childMoveable.state.gestos = {};\n            });\n        }\n    }\n    if (isFirstStart && isForceEnd) {\n        eventAbles.forEach(able => {\n            able.unset && able.unset(moveable);\n        });\n    }\n    if (isStart && !isRequest && isUpdate) {\n        e?.preventDefault();\n    }\n    if (moveable.isUnmounted || isForceEnd) {\n        return false;\n    }\n    if ((!isStart && isUpdate && !requestInstant) || isEnd) {\n        const flushSync = moveable.props.flushSync || defaultSync;\n\n        flushSync(() => {\n            moveable.updateRect(isEnd ? eventType : \"\", true, false);\n            moveable.forceUpdate();\n        });\n\n    }\n    if (!isStart && !isEnd && !isAfter && isUpdate && !requestInstant) {\n        triggerAble(moveable, ableType, eventOperation, eventAffix, eventType + \"After\", e);\n    }\n    return true;\n}\n\nexport function getTargetAbleGesto(\n    moveable: MoveableManagerInterface,\n    moveableTarget: HTMLElement | SVGElement,\n    eventAffix: string,\n) {\n    const controlBox = moveable.controlBox.getElement();\n    const targets: Array<HTMLElement | SVGElement> = [];\n\n    targets.push(controlBox);\n\n    if (!moveable.props.dragArea || moveable.props.dragTarget) {\n        targets.push(moveableTarget);\n    }\n\n    const startFunc = (e: any) => {\n        const eventTarget = e.inputEvent.target;\n        const areaElement = moveable.areaElement;\n\n        return eventTarget === areaElement\n            || (!moveable.isMoveableElement(eventTarget) && !moveable.controlBox.getElement().contains(eventTarget))\n            || hasClass(eventTarget, \"moveable-area\")\n            || hasClass(eventTarget, \"moveable-padding\");\n    };\n\n    return getAbleGesto(moveable, targets, \"targetAbles\", eventAffix, {\n        dragStart: startFunc,\n        pinchStart: startFunc,\n    });\n}\nexport function getAbleGesto(\n    moveable: MoveableManagerInterface,\n    target: HTMLElement | SVGElement | Array<HTMLElement | SVGElement>,\n    ableType: string,\n    eventAffix: string,\n    conditionFunctions: IObject<any> = {},\n) {\n    const isTargetAbles = ableType === \"targetAbles\";\n    const {\n        pinchOutside,\n        pinchThreshold,\n        preventClickEventOnDrag,\n        preventClickDefault,\n        checkInput,\n    } = moveable.props;\n    const options: GestoOptions = {\n        preventDefault: false,\n        preventRightClick: true,\n        preventWheelClick: true,\n        container: window,\n        pinchThreshold,\n        pinchOutside,\n        preventClickEventOnDrag: isTargetAbles ? preventClickEventOnDrag : false,\n        preventClickEventOnDragStart: isTargetAbles ? preventClickDefault : false,\n        checkInput: isTargetAbles ? checkInput : false,\n    };\n    const gesto = new Gesto(target!, options);\n\n    const isControl = eventAffix === \"Control\";\n\n    [\"drag\", \"pinch\"].forEach(eventOperation => {\n        [\"Start\", \"\", \"End\"].forEach(eventType => {\n            gesto.on(`${eventOperation}${eventType}` as any, e => {\n                const eventName = e.eventType;\n\n                if (conditionFunctions[eventName] && !conditionFunctions[eventName](e)) {\n                    e.stop();\n                    return;\n                }\n                const result = triggerAble(moveable, ableType, eventOperation, eventAffix, eventType, e);\n\n                if (!result) {\n                    e.stop();\n                } else if (moveable.props.stopPropagation || (eventType === \"Start\" && isControl)) {\n                    e?.inputEvent?.stopPropagation();\n                }\n            });\n        });\n    });\n\n    return gesto;\n}\n","import { Able, MoveableManagerInterface } from \"./types\";\n\nexport default class EventManager {\n    private ables: Able[] = [];\n    constructor(\n        private target: HTMLElement | SVGElement | null,\n        private moveable: MoveableManagerInterface | null,\n        private eventName: string,\n    ) {\n        target!.addEventListener(eventName.toLowerCase(), this._onEvent);\n    }\n    public setAbles(ables: Able[]) {\n        this.ables = ables;\n    }\n    public destroy() {\n        this.target!.removeEventListener(this.eventName.toLowerCase(), this._onEvent);\n        this.target = null;\n        this.moveable = null;\n    }\n    private _onEvent = (e: Event) => {\n        const eventName = this.eventName;\n        const moveable = this.moveable!;\n\n        if (moveable.state.disableNativeEvent) {\n            return;\n        }\n        this.ables.forEach(able => {\n            (able as any)[eventName](moveable, {\n                inputEvent: e,\n            });\n        });\n    }\n}\n","import { createIdentityMatrix, convertDimension, multiply, createOriginMatrix, ignoreDimension } from \"@scena/matrix\";\nimport { getMatrixStackInfo, convert3DMatrixes, getOffsetInfo, getSVGOffset, makeMatrixCSS } from \"../utils\";\n\nexport interface MoveableElementMatrixInfo {\n    hasFixed: boolean;\n    rootMatrix: number[];\n    beforeMatrix: number[];\n    offsetMatrix: number[];\n    allMatrix: number[];\n    targetMatrix: number[];\n    transformOrigin: number[];\n    targetOrigin: number[];\n    is3d: boolean;\n    targetTransform: string;\n    offsetContainer: HTMLElement | null,\n    offsetRootContainer: HTMLElement | null,\n}\n\nexport function calculateMatrixStack(\n    target: SVGElement | HTMLElement,\n    container?: SVGElement | HTMLElement | null,\n    rootContainer: SVGElement | HTMLElement | null | undefined = container,\n    isAbsolute3d?: boolean,\n    // prevMatrix?: number[],\n    // prevRootMatrix?: number[],\n    // prevN?: number,\n): MoveableElementMatrixInfo {\n    const {\n        matrixes,\n        is3d,\n        targetMatrix: prevTargetMatrix,\n        transformOrigin,\n        targetOrigin,\n        offsetContainer,\n        hasFixed,\n    } = getMatrixStackInfo(target, container); // prevMatrix\n    const {\n        matrixes: rootMatrixes,\n        is3d: isRoot3d,\n        offsetContainer: offsetRootContainer,\n    } = getMatrixStackInfo(offsetContainer, rootContainer, true); // prevRootMatrix\n\n    // if (rootContainer === document.body) {\n    //     console.log(offsetContainer, rootContainer, rootMatrixes);\n    // }\n    const isNext3d = isAbsolute3d || isRoot3d || is3d;\n    const n = isNext3d ? 4 : 3;\n    const isSVGGraphicElement = target.tagName.toLowerCase() !== \"svg\" && \"ownerSVGElement\" in target;\n    let targetMatrix = prevTargetMatrix;\n    // let allMatrix = prevMatrix ? convertDimension(prevMatrix, prevN!, n) : createIdentityMatrix(n);\n    // let rootMatrix = prevRootMatrix ? convertDimension(prevRootMatrix, prevN!, n) : createIdentityMatrix(n);\n    // let beforeMatrix = prevMatrix ? convertDimension(prevMatrix, prevN!, n) : createIdentityMatrix(n);\n    let allMatrix = createIdentityMatrix(n);\n    let rootMatrix = createIdentityMatrix(n);\n    let beforeMatrix = createIdentityMatrix(n);\n    let offsetMatrix = createIdentityMatrix(n);\n    const length = matrixes.length;\n\n    rootMatrixes.reverse();\n    matrixes.reverse();\n\n    if (!is3d && isNext3d) {\n        targetMatrix = convertDimension(targetMatrix, 3, 4);\n\n        convert3DMatrixes(matrixes);\n    }\n    if (!isRoot3d && isNext3d) {\n        convert3DMatrixes(rootMatrixes);\n    }\n\n    // rootMatrix = (...) -> container -> offset -> absolute -> offset -> absolute(targetMatrix)\n    // rootMatrixBeforeOffset = lastOffsetMatrix -> (...) -> container\n    // beforeMatrix = (... -> container -> offset -> absolute) -> offset -> absolute(targetMatrix)\n    // offsetMatrix = (... -> container -> offset -> absolute -> offset) -> absolute(targetMatrix)\n\n    rootMatrixes.forEach(info => {\n        rootMatrix = multiply(rootMatrix, info.matrix!, n);\n    });\n    const originalRootContainer = rootContainer || document.body;\n    const endContainer = rootMatrixes[0]?.target\n        || getOffsetInfo(originalRootContainer, originalRootContainer, true).offsetParent;\n    const rootMatrixBeforeOffset = rootMatrixes.slice(1).reduce((matrix, info) => {\n        return multiply(matrix, info.matrix!, n);\n    }, createIdentityMatrix(n));\n    matrixes.forEach((info, i) => {\n        if (length - 2 === i) {\n            // length - 3\n            beforeMatrix = allMatrix.slice();\n        }\n        if (length - 1 === i) {\n            // length - 2\n            offsetMatrix = allMatrix.slice();\n        }\n\n        // calculate for SVGElement\n        if (!info.matrix) {\n            const nextInfo = matrixes[i + 1];\n            const offset = getSVGOffset(\n                info,\n                nextInfo,\n                endContainer,\n                n,\n                multiply(rootMatrixBeforeOffset, allMatrix, n),\n            );\n            info.matrix = createOriginMatrix(offset, n);\n        }\n        allMatrix = multiply(allMatrix, info.matrix!, n);\n    });\n    const isMatrix3d = !isSVGGraphicElement && is3d;\n\n    if (!targetMatrix) {\n        targetMatrix = createIdentityMatrix(isMatrix3d ? 4 : 3);\n    }\n    const targetTransform = makeMatrixCSS(\n        isSVGGraphicElement && targetMatrix.length === 16\n            ? convertDimension(targetMatrix, 4, 3) : targetMatrix,\n        isMatrix3d,\n    );\n\n    rootMatrix = ignoreDimension(rootMatrix, n, n);\n\n    return {\n        hasFixed,\n        rootMatrix,\n        beforeMatrix,\n        offsetMatrix,\n        allMatrix,\n        targetMatrix,\n        targetTransform,\n        transformOrigin,\n        targetOrigin,\n        is3d: isNext3d,\n        offsetContainer,\n        offsetRootContainer,\n    };\n}\n","import { createIdentityMatrix } from \"@scena/matrix\";\nimport { ElementSizes, MoveablePosition } from \"../types\";\nimport { calculateMoveablePosition, getSize, getRotationRad } from \"../utils\";\nimport { calculateMatrixStack, MoveableElementMatrixInfo } from \"./calculateMatrixStack\";\n\nexport interface MoveableElementInfo extends MoveableElementMatrixInfo, MoveablePosition, ElementSizes {\n    width: number;\n    height: number;\n    rotation: number;\n}\n\nexport function calculateElementInfo(\n    target?: SVGElement | HTMLElement | null,\n    container?: SVGElement | HTMLElement | null,\n    rootContainer: HTMLElement | SVGElement | null | undefined = container,\n    isAbsolute3d?: boolean,\n): MoveableElementInfo {\n    let width = 0;\n    let height = 0;\n    let rotation = 0;\n    let allResult: {} = {};\n\n    const sizes = getSize(target);\n\n    if (target) {\n        width = sizes.offsetWidth;\n        height = sizes.offsetHeight;\n    }\n\n    if (target) {\n        const result = calculateMatrixStack(\n            target,\n            container,\n            rootContainer,\n            isAbsolute3d,\n            // prevMatrix, prevRootMatrix, prevN,\n        );\n\n        const position = calculateMoveablePosition(\n            result.allMatrix,\n            result.transformOrigin,\n            width, height,\n        );\n        allResult = {\n            ...result,\n            ...position,\n        };\n        const rotationPosition = calculateMoveablePosition(\n            result.allMatrix, [50, 50], 100, 100,\n        );\n        rotation = getRotationRad([rotationPosition.pos1, rotationPosition.pos2], rotationPosition.direction);\n    }\n    const n = isAbsolute3d ? 4 : 3;\n\n    return {\n        width,\n        height,\n        rotation,\n        ...sizes,\n        rootMatrix: createIdentityMatrix(n),\n        beforeMatrix: createIdentityMatrix(n),\n        offsetMatrix: createIdentityMatrix(n),\n        allMatrix: createIdentityMatrix(n),\n        targetMatrix: createIdentityMatrix(n),\n        targetTransform: \"\",\n        transformOrigin: [0, 0],\n        targetOrigin: [0, 0],\n        is3d: !!isAbsolute3d,\n        left: 0,\n        top: 0,\n        right: 0,\n        bottom: 0,\n        origin: [0, 0],\n        pos1: [0, 0],\n        pos2: [0, 0],\n        pos3: [0, 0],\n        pos4: [0, 0],\n        direction: 1,\n        hasFixed: false,\n        offsetContainer: null,\n        offsetRootContainer: null,\n        ...allResult,\n    };\n}\n\n\nexport function getElementInfo(\n    target: SVGElement | HTMLElement,\n    container?: SVGElement | HTMLElement | null,\n    rootContainer: SVGElement | HTMLElement | null | undefined = container,\n) {\n    return calculateElementInfo(target, container, rootContainer, true);\n}\n","import { plus, getOrigin } from \"@scena/matrix\";\nimport { MoveableClientRect } from \"../types\";\nimport {\n    calculateMoveablePosition,\n    getClientRect, getOffsetInfo, resetClientRect,\n} from \"../utils\";\nimport { calculateElementInfo, MoveableElementInfo } from \"./getElementInfo\";\n\n\nexport interface MoveableTargetInfo extends MoveableElementInfo {\n    targetClientRect: MoveableClientRect;\n    containerClientRect: MoveableClientRect;\n    moveableClientRect: MoveableClientRect;\n    rootContainerClientRect: MoveableClientRect;\n    beforeDirection: 1 | -1;\n    beforeOrigin: number[];\n    originalBeforeOrigin: number[];\n    target: HTMLElement | SVGElement | null | undefined;\n}\n\nexport function getMoveableTargetInfo(\n    moveableElement?: HTMLElement | null,\n    target?: HTMLElement | SVGElement | null,\n    container?: HTMLElement | SVGElement | null,\n    parentContainer?: HTMLElement | SVGElement | null,\n    rootContainer?: HTMLElement | SVGElement | null,\n    // state?: Partial<MoveableManagerState> | false | undefined,\n): MoveableTargetInfo {\n    let beforeDirection: 1 | -1 = 1;\n    let beforeOrigin = [0, 0];\n    let targetClientRect = resetClientRect();\n    let moveableClientRect = resetClientRect();\n    let containerClientRect = resetClientRect();\n    let rootContainerClientRect = resetClientRect();\n\n    const result = calculateElementInfo(\n        target, container!, rootContainer!,\n        true,\n    );\n    if (target) {\n        const n = result.is3d ? 4 : 3;\n        const beforePosition = calculateMoveablePosition(\n            result.offsetMatrix,\n            plus(result.transformOrigin, getOrigin(result.targetMatrix, n)),\n            result.width, result.height,\n        );\n        beforeDirection = beforePosition.direction;\n        beforeOrigin = plus(\n            beforePosition.origin,\n            [beforePosition.left - result.left, beforePosition.top - result.top],\n        );\n\n        targetClientRect = getClientRect(target);\n        const offsetContainer = getOffsetInfo(parentContainer, parentContainer, true).offsetParent\n            || result.offsetRootContainer!;\n        containerClientRect = getClientRect(offsetContainer, true);\n        rootContainerClientRect = getClientRect(result.offsetRootContainer!);\n        if (moveableElement) {\n            moveableClientRect = getClientRect(moveableElement);\n        }\n    }\n\n    return {\n        targetClientRect,\n        containerClientRect,\n        moveableClientRect,\n        rootContainerClientRect,\n        beforeDirection,\n        beforeOrigin,\n        originalBeforeOrigin: beforeOrigin,\n        target,\n        ...result,\n    };\n}\n","import * as React from \"react\";\nimport { createElement } from \"react\";\nimport { PREFIX } from \"./consts\";\nimport {\n    prefix,\n    unset,\n    getAbsolutePosesByState,\n    getRect,\n    filterAbles,\n    equals,\n    flat,\n    groupByMap,\n    calculatePadding,\n    getAbsoluteRotation,\n    defaultSync,\n} from \"./utils\";\nimport Gesto from \"gesto\";\nimport { ref } from \"framework-utils\";\nimport {\n    MoveableManagerProps, MoveableManagerState, Able,\n    RectInfo, Requester, PaddingBox, HitRect, MoveableManagerInterface,\n    MoveableDefaultOptions,\n    GroupableProps,\n} from \"./types\";\nimport { triggerAble, getTargetAbleGesto, getAbleGesto } from \"./gesto/getAbleGesto\";\nimport { plus } from \"@scena/matrix\";\nimport { cancelAnimationFrame, find, getKeys, IObject, requestAnimationFrame } from \"@daybrush/utils\";\nimport { renderLine } from \"./renderDirections\";\nimport { fitPoints, getAreaSize, getOverlapSize, isInside } from \"overlap-area\";\nimport EventManager from \"./EventManager\";\nimport styled from \"react-css-styled\";\nimport EventEmitter from \"@scena/event-emitter\";\nimport { getMoveableTargetInfo } from \"./utils/getMoveableTargetInfo\";\n\nexport default class MoveableManager<T = {}>\n    extends React.PureComponent<MoveableManagerProps<T>, MoveableManagerState> {\n    public static defaultProps: Required<MoveableManagerProps> = {\n        target: null,\n        dragTarget: null,\n        container: null,\n        rootContainer: null,\n        origin: true,\n        parentMoveable: null,\n        wrapperMoveable: null,\n        parentPosition: null,\n        portalContainer: null,\n        useResizeObserver: false,\n        ables: [],\n        pinchThreshold: 20,\n        dragArea: false,\n        passDragArea: false,\n        transformOrigin: \"\",\n        className: \"\",\n        zoom: 1,\n        triggerAblesSimultaneously: false,\n        padding: {},\n        pinchOutside: true,\n        checkInput: false,\n        groupable: false,\n        hideDefaultLines: false,\n        cspNonce: \"\",\n        translateZ: 0,\n        cssStyled: null,\n        customStyledMap: {},\n        props: {},\n        stopPropagation: false,\n        preventClickDefault: false,\n        preventClickEventOnDrag: true,\n        flushSync: defaultSync,\n    };\n    public state: MoveableManagerState = {\n        container: null,\n        gestos: {},\n        renderPoses: [[0, 0], [0, 0], [0, 0], [0, 0]],\n        disableNativeEvent: false,\n        ...getMoveableTargetInfo(null),\n    };\n    public renderState: Record<string, any> = {};\n    public enabledAbles: Able[] = [];\n    public targetAbles: Able[] = [];\n    public controlAbles: Able[] = [];\n    public controlBox!: { getElement(): HTMLElement };\n    public areaElement!: HTMLElement;\n    public targetGesto!: Gesto;\n    public controlGesto!: Gesto;\n    public rotation = 0;\n    public scale: number[] = [1, 1];\n    public isUnmounted = false;\n    public events: Record<string, EventManager | null> = {\n        \"mouseEnter\": null,\n        \"mouseLeave\": null,\n    };\n\n    protected _emitter: EventEmitter = new EventEmitter();\n    protected _prevTarget: HTMLElement | SVGElement | null | undefined = null;\n    protected _prevDragArea = false;\n\n    private _observer: ResizeObserver | null = null;\n    private _observerId = 0;\n\n    public render() {\n        const props = this.props;\n        const state = this.state;\n        const {\n            parentPosition, className,\n            target: propsTarget,\n            zoom, cspNonce,\n            translateZ,\n            cssStyled: ControlBoxElement,\n            portalContainer,\n        } = props;\n\n        this.checkUpdate();\n        this.updateRenderPoses();\n\n        const { left: parentLeft, top: parentTop } = parentPosition! || { left: 0, top: 0 };\n        const {\n            left,\n            top,\n            target: stateTarget,\n            direction,\n            hasFixed,\n        } = state;\n        const groupTargets = (props as any).targets;\n        const isDisplay = ((groupTargets && groupTargets.length) || propsTarget) && stateTarget;\n        const isDragging = this.isDragging();\n        const ableAttributes: IObject<boolean> = {};\n        this.getEnabledAbles().forEach(able => {\n            ableAttributes[`data-able-${able.name.toLowerCase()}`] = true;\n        });\n        return (\n            <ControlBoxElement\n                cspNonce={cspNonce}\n                ref={ref(this, \"controlBox\")}\n                className={`${prefix(\"control-box\", direction === -1\n                    ? \"reverse\" : \"\", isDragging ? \"dragging\" : \"\")} ${className}`}\n                {...ableAttributes}\n                onClick={this.onPreventClick}\n                portalContainer={portalContainer}\n                style={{\n                    \"position\": hasFixed ? \"fixed\" : \"absolute\",\n                    \"display\": isDisplay ? \"block\" : \"none\",\n                    \"transform\": `translate3d(${left - parentLeft}px, ${top - parentTop}px, ${translateZ})`,\n                    \"--zoom\": zoom,\n                    \"--zoompx\": `${zoom}px`,\n                }}>\n                {this.renderAbles()}\n                {this._renderLines()}\n            </ControlBoxElement>\n        );\n    }\n    public componentDidMount() {\n        this.isUnmounted = false;\n        this.controlBox.getElement();\n        const props = this.props;\n        const { parentMoveable, container, wrapperMoveable } = props;\n\n        this._updateTargets();\n        this._updateNativeEvents();\n        this._updateEvents();\n\n        if (!container && !parentMoveable && !wrapperMoveable) {\n            this.updateRect(\"\", false, true);\n        }\n        this.updateCheckInput();\n        this._updateObserver(this.props);\n    }\n    public componentDidUpdate(prevProps: any) {\n        this._updateNativeEvents();\n        this._updateEvents();\n        this._updateTargets();\n        this.updateCheckInput();\n        this._updateObserver(prevProps);\n    }\n    public componentWillUnmount() {\n        this.isUnmounted = true;\n        this._emitter.off();\n        unset(this, \"targetGesto\");\n        unset(this, \"controlGesto\");\n\n        const events = this.events;\n        for (const name in events) {\n            const manager = events[name];\n            manager && manager.destroy();\n        }\n    }\n    /**\n     * Get the able used in MoveableManager.\n     * @method Moveable#getAble\n     * @param - able name\n     */\n    public getAble<T extends Able>(ableName: string): T | undefined {\n        const ables: Able[] = this.props.ables || [];\n\n        return find(ables, able => able.name === ableName) as T;\n    }\n    public getContainer(): HTMLElement | SVGElement {\n        const { parentMoveable, wrapperMoveable, container } = this.props;\n\n        return container!\n            || (wrapperMoveable && wrapperMoveable.getContainer())\n            || (parentMoveable && parentMoveable.getContainer())\n            || this.controlBox.getElement().parentElement!;\n    }\n    /**\n     * Check if the target is an element included in the moveable.\n     * @method Moveable#isMoveableElement\n     * @param - the target\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * window.addEventListener(\"click\", e => {\n     *     if (!moveable.isMoveableElement(e.target)) {\n     *         moveable.target = e.target;\n     *     }\n     * });\n     */\n    public isMoveableElement(target: Element) {\n        return target && (target.getAttribute(\"class\") || \"\").indexOf(PREFIX) > -1;\n    }\n    /**\n     * You can drag start the Moveable through the external `MouseEvent`or `TouchEvent`. (Angular: ngDragStart)\n     * @method Moveable#dragStart\n     * @param - external `MouseEvent`or `TouchEvent`\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * document.body.addEventListener(\"mousedown\", e => {\n     *     if (!moveable.isMoveableElement(e.target)) {\n     *          moveable.dragStart(e);\n     *     }\n     * });\n     */\n    public dragStart(e: MouseEvent | TouchEvent) {\n        const targetGesto = this.targetGesto;\n\n        if (targetGesto && !targetGesto.isFlag()) {\n            targetGesto.triggerDragStart(e);\n        }\n        return this;\n    }\n    /**\n     * Hit test an element or rect on a moveable target.\n     * @method Moveable#hitTest\n     * @param - element or rect to test\n     * @return - Get hit test rate (rate > 0 is hitted)\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * document.body.addEventListener(\"mousedown\", e => {\n     *     if (moveable.hitTest(e.target) > 0) {\n     *          console.log(\"hiited\");\n     *     }\n     * });\n     */\n    public hitTest(el: Element | HitRect): number {\n        const { target, pos1, pos2, pos3, pos4, targetClientRect } = this.state;\n\n        if (!target) {\n            return 0;\n        }\n        let rect: Required<HitRect>;\n\n        if (el instanceof Element) {\n            const clientRect = el.getBoundingClientRect();\n\n            rect = {\n                left: clientRect.left,\n                top: clientRect.top,\n                width: clientRect.width,\n                height: clientRect.height,\n            };\n        } else {\n            rect = { width: 0, height: 0, ...el };\n        }\n\n        const {\n            left: rectLeft,\n            top: rectTop,\n            width: rectWidth,\n            height: rectHeight,\n        } = rect;\n        const points = fitPoints([pos1, pos2, pos4, pos3], targetClientRect);\n        const size = getOverlapSize(points, [\n            [rectLeft, rectTop],\n            [rectLeft + rectWidth, rectTop],\n            [rectLeft + rectWidth, rectTop + rectHeight],\n            [rectLeft, rectTop + rectHeight],\n        ]);\n        const totalSize = getAreaSize(points);\n\n        if (!size || !totalSize) {\n            return 0;\n        }\n\n        return Math.min(100, size / totalSize * 100);\n    }\n    /**\n     * Whether the coordinates are inside Moveable\n     * @method Moveable#isInside\n     * @param - x coordinate\n     * @param - y coordinate\n     * @return - True if the coordinate is in moveable or false\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * document.body.addEventListener(\"mousedown\", e => {\n     *     if (moveable.isInside(e.clientX, e.clientY)) {\n     *          console.log(\"inside\");\n     *     }\n     * });\n     */\n    public isInside(clientX: number, clientY: number) {\n        const { target, pos1, pos2, pos3, pos4, targetClientRect } = this.state;\n\n        if (!target) {\n            return false;\n        }\n        return isInside([clientX, clientY], fitPoints([pos1, pos2, pos4, pos3], targetClientRect));\n    }\n    /**\n     * If the width, height, left, and top of all elements change, update the shape of the moveable.\n     * @method Moveable#updateRect\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * window.addEventListener(\"resize\", e => {\n     *     moveable.updateRect();\n     * });\n     */\n    public updateRect(type?: \"Start\" | \"\" | \"End\", isTarget?: boolean, isSetState: boolean = true) {\n        const props = this.props;\n        const parentMoveable = props.parentMoveable;\n        const state = this.state;\n        const target = (state.target || this.props.target) as HTMLElement | SVGElement;\n        const container = this.getContainer();\n        const rootContainer = parentMoveable\n            ? parentMoveable.props.rootContainer\n            : props.rootContainer;\n        this.updateState(\n            getMoveableTargetInfo(this.controlBox && this.controlBox.getElement(),\n                target,\n                container,\n                container,\n                rootContainer || container,\n                // isTarget ? state : undefined\n            ),\n            parentMoveable ? false : isSetState,\n        );\n    }\n    /**\n     * Check if the moveable state is being dragged.\n     * @method Moveable#isDragging\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * // false\n     * console.log(moveable.isDragging());\n     *\n     * moveable.on(\"drag\", () => {\n     *   // true\n     *   console.log(moveable.isDragging());\n     * });\n     */\n    public isDragging() {\n        return (this.targetGesto ? this.targetGesto.isFlag() : false)\n            || (this.controlGesto ? this.controlGesto.isFlag() : false);\n    }\n    /**\n     * If the width, height, left, and top of the only target change, update the shape of the moveable.\n     * @method Moveable#updateTarget\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * moveable.updateTarget();\n     */\n    public updateTarget(type?: \"Start\" | \"\" | \"End\") {\n        this.updateRect(type, true);\n    }\n    /**\n     * You can get the vertex information, position and offset size information of the target based on the container.\n     * @method Moveable#getRect\n     * @return - The Rect Info\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * const rectInfo = moveable.getRect();\n     */\n    public getRect(): RectInfo {\n        const state = this.state;\n        const poses = getAbsolutePosesByState(this.state);\n        const [pos1, pos2, pos3, pos4] = poses;\n        const rect = getRect(poses);\n        const {\n            width: offsetWidth,\n            height: offsetHeight,\n        } = state;\n        const {\n            width,\n            height,\n            left,\n            top,\n        } = rect;\n        const statePos = [state.left, state.top];\n        const origin = plus(statePos, state.origin);\n        const beforeOrigin = plus(statePos, state.beforeOrigin);\n        const transformOrigin = state.transformOrigin;\n\n        return {\n            width,\n            height,\n            left,\n            top,\n            pos1,\n            pos2,\n            pos3,\n            pos4,\n            offsetWidth,\n            offsetHeight,\n            beforeOrigin,\n            origin,\n            transformOrigin,\n            rotation: this.getRotation(),\n        };\n    }\n    /**\n     * Get a manager that manages the moveable's state and props.\n     * @method Moveable#getManager\n     * @return - The Rect Info\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * const manager = moveable.getManager(); // real moveable class instance\n     */\n    public getManager(): MoveableManagerInterface<any, any> {\n        return this as any;\n    }\n    public getRotation() {\n        const {\n            pos1,\n            pos2,\n            direction,\n        } = this.state;\n\n        return getAbsoluteRotation(pos1, pos2, direction);\n    }\n    /**\n     * Request able through a method rather than an event.\n     * At the moment of execution, requestStart is executed,\n     * and then request and requestEnd can be executed through Requester.\n     * @method Moveable#request\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Draggable.html#request|Draggable Requester}\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Resizable.html#request|Resizable Requester}\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Scalable.html#request|Scalable Requester}\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Rotatable.html#request|Rotatable Requester}\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.OriginDraggable.html#request|OriginDraggable Requester}\n     * @param - ableName\n     * @param - request to be able params.\n     * @param - If isInstant is true, request and requestEnd are executed immediately.\n     * @return - Able Requester. If there is no request in able, nothing will work.\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * // Instantly Request (requestStart - request - requestEnd)\n     * moveable.request(\"draggable\", { deltaX: 10, deltaY: 10 }, true);\n     *\n     * // Start move\n     * const requester = moveable.request(\"draggable\");\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.requestEnd();\n     */\n    public request(ableName: string, param: IObject<any> = {}, isInstant?: boolean): Requester {\n        const { ables, groupable } = this.props as any;\n        const requsetAble: Able = ables!.filter((able: Able) => able.name === ableName)[0];\n\n        if (this.isDragging() || !requsetAble || !requsetAble.request) {\n            return {\n                request() {\n                    return this;\n                },\n                requestEnd() {\n                    return this;\n                },\n            };\n        }\n        const self = this;\n        const ableRequester = requsetAble.request(this);\n\n        const requestInstant = isInstant || param.isInstant;\n        const ableType = ableRequester.isControl ? \"controlAbles\" : \"targetAbles\";\n        const eventAffix = `${(groupable ? \"Group\" : \"\")}${ableRequester.isControl ? \"Control\" : \"\"}`;\n\n        const requester = {\n            request(ableParam: IObject<any>) {\n                triggerAble(self, ableType, \"drag\", eventAffix, \"\", {\n                    ...ableRequester.request(ableParam),\n                    requestAble: ableName,\n                    isRequest: true,\n                }, requestInstant);\n                return this;\n            },\n            requestEnd() {\n                triggerAble(self, ableType, \"drag\", eventAffix, \"End\", {\n                    ...ableRequester.requestEnd(),\n                    requestAble: ableName,\n                    isRequest: true,\n                }, requestInstant);\n                return this;\n            },\n        };\n\n        triggerAble(self, ableType, \"drag\", eventAffix, \"Start\", {\n            ...ableRequester.requestStart(param),\n            requestAble: ableName,\n            isRequest: true,\n        }, requestInstant);\n\n        return requestInstant ? requester.request(param).requestEnd() : requester;\n    }\n    /**\n     * Remove the Moveable object and the events.\n     * @method Moveable#destroy\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * moveable.destroy();\n     */\n    public destroy(): void {\n        this.componentWillUnmount();\n    }\n    public updateRenderPoses() {\n        const state = this.state;\n        const props = this.props;\n        const {\n            originalBeforeOrigin, transformOrigin,\n            allMatrix, is3d,\n            pos1, pos2, pos3, pos4,\n            left: stateLeft, top: stateTop,\n        } = state;\n        const {\n            left = 0,\n            top = 0,\n            bottom = 0,\n            right = 0,\n        } = (props.padding || {}) as PaddingBox;\n        const n = is3d ? 4 : 3;\n        const absoluteOrigin = (props as any).groupable\n            ? originalBeforeOrigin : plus(originalBeforeOrigin, [stateLeft, stateTop]);\n\n        state.renderPoses = [\n            plus(pos1, calculatePadding(allMatrix, [-left, -top], transformOrigin, absoluteOrigin, n)),\n            plus(pos2, calculatePadding(allMatrix, [right, -top], transformOrigin, absoluteOrigin, n)),\n            plus(pos3, calculatePadding(allMatrix, [-left, bottom], transformOrigin, absoluteOrigin, n)),\n            plus(pos4, calculatePadding(allMatrix, [right, bottom], transformOrigin, absoluteOrigin, n)),\n        ];\n    }\n    public checkUpdate() {\n        const { target, container, parentMoveable } = this.props;\n        const {\n            target: stateTarget,\n            container: stateContainer,\n        } = this.state;\n\n        if (!stateTarget && !target) {\n            return;\n        }\n        this.updateAbles();\n\n        const isChanged = !equals(stateTarget, target) || !equals(stateContainer, container);\n\n        if (!isChanged) {\n            return;\n        }\n        const moveableContainer = container || this.controlBox;\n\n        if (moveableContainer) {\n            this.unsetAbles();\n        }\n        this.updateState({ target, container });\n\n        if (!parentMoveable && moveableContainer) {\n            this.updateRect(\"End\", false, false);\n        }\n    }\n    public triggerEvent(name: string, e: any): any {\n        this._emitter.trigger(name, e);\n        const callback = (this.props as any)[name];\n\n        return callback && callback(e);\n    }\n    public useCSS(tag: string, css: string) {\n        const customStyleMap = this.props.customStyledMap as Record<string, any>;\n\n        const key = tag + css;\n\n        if (!customStyleMap[key]) {\n            customStyleMap[key] = styled(tag, css);\n        }\n        return customStyleMap[key];\n    }\n    public onPreventClick = (e: any) => {\n        e.stopPropagation();\n        e.preventDefault();\n        // removeEvent(window, \"click\", this.onPreventClick, true);\n    }\n    public checkUpdateRect = () => {\n        if (this.isDragging()) {\n            return;\n        }\n        const parentMoveable = this.props.parentMoveable;\n\n        if (parentMoveable) {\n            (parentMoveable as MoveableManager).checkUpdateRect();\n            return;\n        }\n        cancelAnimationFrame(this._observerId);\n        this._observerId = requestAnimationFrame(() => {\n            if (this.isDragging()) {\n                return;\n            }\n            this.updateRect();\n        });\n    }\n    protected unsetAbles() {\n        this.targetAbles.forEach(able => {\n            if (able.unset) {\n                able.unset(this);\n            }\n        });\n    }\n    protected updateAbles(\n        ables: Able[] = this.props.ables!,\n        eventAffix: string = \"\",\n    ) {\n        const props = this.props as any;\n        const triggerAblesSimultaneously = props.triggerAblesSimultaneously;\n        const enabledAbles = ables!.filter(able => able && (\n            (able.always && props[able.name] !== false)\n            || props[able.name]));\n\n        const dragStart = `drag${eventAffix}Start` as \"dragStart\";\n        const pinchStart = `pinch${eventAffix}Start` as \"pinchStart\";\n        const dragControlStart = `drag${eventAffix}ControlStart` as \"dragControlStart\";\n\n        const targetAbles = filterAbles(enabledAbles, [dragStart, pinchStart], triggerAblesSimultaneously);\n        const controlAbles = filterAbles(enabledAbles, [dragControlStart], triggerAblesSimultaneously);\n\n        this.enabledAbles = enabledAbles;\n        this.targetAbles = targetAbles;\n        this.controlAbles = controlAbles;\n    }\n    protected updateState(nextState: any, isSetState?: boolean) {\n        if (isSetState) {\n            if (this.isUnmounted) {\n                return;\n            }\n            this.setState(nextState);\n        } else {\n            const state = this.state;\n\n            for (const name in nextState) {\n                (state as any)[name] = nextState[name];\n            }\n        }\n    }\n    protected getEnabledAbles() {\n        const props = this.props as any;\n        const ables: Able[] = props.ables!;\n        return ables.filter(able => able && props[able.name]);\n    }\n    protected renderAbles() {\n        const props = this.props as any;\n        const triggerAblesSimultaneously = props.triggerAblesSimultaneously;\n        const Renderer = {\n            createElement,\n        };\n\n        this.renderState = {};\n\n        return groupByMap(flat<any>(\n            filterAbles(this.getEnabledAbles(), [\"render\"], triggerAblesSimultaneously).map(({ render }) => {\n                return render!(this, Renderer) || [];\n            })).filter(el => el), ({ key }) => key).map(group => group[0]);\n    }\n    protected updateCheckInput() {\n        this.targetGesto && (this.targetGesto.options.checkInput = this.props.checkInput);\n    }\n    protected _updateObserver(prevProps: MoveableDefaultOptions) {\n        const props = this.props;\n        const target = props.target;\n\n        if (!window.ResizeObserver || !target || !props.useResizeObserver) {\n            this._observer?.disconnect();\n            return;\n        }\n\n        if (prevProps.target === target && this._observer) {\n            return;\n        }\n\n        const observer = new ResizeObserver(this.checkUpdateRect);\n\n        observer.observe(target!, {\n            box: \"border-box\",\n        });\n        this._observer = observer;\n\n        return;\n    }\n    protected _updateEvents() {\n        const controlBoxElement = this.controlBox.getElement();\n        const hasTargetAble = this.targetAbles.length;\n        const hasControlAble = this.controlAbles.length;\n        const props = this.props;\n        const target = props.dragTarget || props.target;\n        const isUnset = (!hasTargetAble && this.targetGesto)\n            || this._isTargetChanged(true);\n\n        if (isUnset) {\n            unset(this, \"targetGesto\");\n            this.updateState({ gesto: null });\n        }\n        if (!hasControlAble) {\n            unset(this, \"controlGesto\");\n        }\n\n        if (target && hasTargetAble && !this.targetGesto) {\n            this.targetGesto = getTargetAbleGesto(this, target!, \"\");\n        }\n        if (!this.controlGesto && hasControlAble) {\n            this.controlGesto = getAbleGesto(this, controlBoxElement, \"controlAbles\", \"Control\");\n        }\n    }\n    protected _updateTargets() {\n        const props = this.props;\n\n        this._prevTarget = props.dragTarget || props.target;\n        this._prevDragArea = props.dragArea!;\n    }\n    private _renderLines() {\n        const props = this.props;\n        const {\n            zoom,\n            hideDefaultLines,\n            hideChildMoveableDefaultLines,\n            parentMoveable,\n        } = props as MoveableManagerProps<GroupableProps>;\n\n        if (hideDefaultLines || (parentMoveable && hideChildMoveableDefaultLines)) {\n            return [];\n        }\n        const renderPoses = this.state.renderPoses;\n        const Renderer = {\n            createElement,\n        };\n\n        return [\n            [0, 1],\n            [1, 3],\n            [3, 2],\n            [2, 0],\n        ].map(([from, to], i) => {\n            return renderLine(Renderer, \"\", renderPoses[from], renderPoses[to], zoom!, i);\n        });\n    }\n    private _isTargetChanged(useDragArea?: boolean) {\n        const props = this.props;\n        const target = props.dragTarget || props.target;\n        const prevTarget = this._prevTarget;\n        const prevDragArea = this._prevDragArea;\n        const dragArea = props.dragArea;\n\n        // check target without dragArea\n        const isTargetChanged = !dragArea && prevTarget !== target;\n        const isDragAreaChanged = (useDragArea || dragArea) && prevDragArea !== dragArea;\n\n        return isTargetChanged || isDragAreaChanged;\n    }\n    private _updateNativeEvents() {\n        const props = this.props;\n        const target = props.dragArea ? this.areaElement : this.state.target;\n        const events = this.events;\n        const eventKeys = getKeys(events);\n\n        if (this._isTargetChanged()) {\n            for (const eventName in events) {\n                const manager = events[eventName];\n                manager && manager.destroy();\n                events[eventName] = null;\n            }\n        }\n        if (!target) {\n            return;\n        }\n        const enabledAbles = this.enabledAbles;\n        eventKeys.forEach(eventName => {\n            const ables = filterAbles(enabledAbles, [eventName] as any);\n            const hasAbles = ables.length > 0;\n            let manager = events[eventName];\n\n            if (!hasAbles) {\n                if (manager) {\n                    manager.destroy();\n                    events[eventName] = null;\n                }\n                return;\n            }\n            if (!manager) {\n                manager = new EventManager(target, this, eventName);\n                events[eventName] = manager;\n            }\n            manager.setAbles(ables);\n        });\n    }\n}\n\n/**\n * The target to indicate Moveable Control Box.\n * @name Moveable#target\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.target = document.querySelector(\".target\");\n */\n/**\n * Zooms in the elements of a moveable.\n * @name Moveable#zoom\n * @default 1\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.zoom = 2;\n */\n\n/**\n * Whether the target size is detected and updated whenever it changes.\n * @name Moveable#useResizeObserver\n * @default false\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.useResizeObserver = true;\n */\n\n/**\n * Resize, Scale Events at edges\n * @name Moveable#edge\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.edge = true;\n */\n\n/**\n * You can specify the className of the moveable controlbox.\n * @name Moveable#className\n * @default \"\"\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   className: \"\",\n * });\n *\n * moveable.className = \"moveable1\";\n */\n\n/**\n * The target(s) to drag Moveable target(s)\n * @name Moveable#dragTarget\n * @default target\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.target = document.querySelector(\".target\");\n * moveable.dragTarget = document.querySelector(\".dragTarget\");\n */\n\n/**\n * `renderStart` event occurs at the first start of all events.\n * @memberof Moveable\n * @event renderStart\n * @param {Moveable.OnRenderStart} - Parameters for the `renderStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"renderStart\", ({ target }) => {\n *     console.log(\"onRenderStart\", target);\n * });\n */\n\n/**\n * `render` event occurs before the target is drawn on the screen.\n * @memberof Moveable\n * @event render\n * @param {Moveable.OnRender} - Parameters for the `render` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"render\", ({ target }) => {\n *     console.log(\"onRender\", target);\n * });\n */\n\n/**\n * `renderEnd` event occurs at the end of all events.\n * @memberof Moveable\n * @event renderEnd\n * @param {Moveable.OnRenderEnd} - Parameters for the `renderEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"renderEnd\", ({ target }) => {\n *     console.log(\"onRenderEnd\", target);\n * });\n */\n\n/**\n * `renderGroupStart` event occurs at the first start of all events in group.\n * @memberof Moveable\n * @event renderGroupStart\n * @param {Moveable.OnRenderGroupStart} - Parameters for the `renderGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"renderGroupStart\", ({ targets }) => {\n *     console.log(\"onRenderGroupStart\", targets);\n * });\n */\n\n/**\n * `renderGroup` event occurs before the target is drawn on the screen in group.\n * @memberof Moveable\n * @event renderGroup\n * @param {Moveable.OnRenderGroup} - Parameters for the `renderGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"renderGroup\", ({ targets }) => {\n *     console.log(\"onRenderGroup\", targets);\n * });\n */\n\n/**\n * `renderGroupEnd` event occurs at the end of all events in group.\n * @memberof Moveable\n * @event renderGroupEnd\n * @param {Moveable.OnRenderGroupEnd} - Parameters for the `renderGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"renderGroupEnd\", ({ targets }) => {\n *     console.log(\"onRenderGroupEnd\", targets);\n * });\n */\n","import { refs } from \"framework-utils\";\nimport MoveableManager from \"../MoveableManager\";\nimport { Renderer, MoveableGroupInterface, GroupableProps } from \"../types\";\n\nexport default {\n    name: \"groupable\",\n    props: {\n        defaultGroupRotate: Number,\n        defaultGroupOrigin: String,\n        groupable: Boolean,\n        hideChildMoveableDefaultLines: Boolean,\n    } as const,\n    events: {} as const,\n    render(moveable: MoveableGroupInterface<GroupableProps>, React: Renderer): any[] {\n        const targets = moveable.props.targets || [];\n\n        moveable.moveables = [];\n        const { left, top } = moveable.state;\n        const position = { left, top };\n        const props = moveable.props;\n\n        return targets.map((target, i) => {\n            return <MoveableManager<GroupableProps>\n                key={\"moveable\" + i}\n                ref={refs(moveable, \"moveables\", i)}\n                target={target}\n                origin={false}\n                cssStyled={props.cssStyled}\n                customStyledMap={props.customStyledMap}\n                useResizeObserver={props.useResizeObserver}\n                hideChildMoveableDefaultLines={props.hideChildMoveableDefaultLines}\n                parentMoveable={moveable}\n                parentPosition={position}\n            />;\n        });\n    },\n};\n","import {\n    MoveableManagerInterface, MoveableGroupInterface,\n    ClickableProps, OnClick, OnClickGroup,\n} from \"../types\";\nimport { triggerEvent, fillParams } from \"../utils\";\nimport { findIndex } from \"@daybrush/utils\";\nimport { makeAble } from \"./AbleManager\";\n\nexport default makeAble(\"clickable\", {\n    props: {\n        clickable: Boolean,\n    },\n    events: {\n        onClick: \"click\",\n        onClickGroup: \"clickGroup\",\n    } as const,\n    always: true,\n    dragRelation: \"weak\",\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    dragStart() {\n        return;\n    },\n    dragControlStart() {\n        this.dragStart();\n    },\n    dragGroupStart(moveable: MoveableManagerInterface<ClickableProps>, e: any) {\n        e.datas.inputTarget = e.inputEvent && e.inputEvent.target;\n    },\n    dragEnd(moveable: MoveableManagerInterface<ClickableProps>, e: any) {\n        const target = moveable.state.target!;\n        const inputEvent = e.inputEvent;\n        const inputTarget = e.inputTarget;\n        const isMoveableElement = moveable.isMoveableElement(inputTarget);\n        const containsElement = !isMoveableElement && moveable.controlBox.getElement().contains(inputTarget);\n\n        if (\n            !inputEvent || !inputTarget || e.isDrag\n            || moveable.isMoveableElement(inputTarget)\n            || containsElement\n            // External event duplicate target or dragAreaElement\n        ) {\n            return;\n        }\n        const containsTarget = target.contains(inputTarget);\n\n        triggerEvent(moveable, \"onClick\", fillParams<OnClick>(moveable, e, {\n            isDouble: e.isDouble,\n            inputTarget,\n            isTarget: target === inputTarget,\n            containsTarget,\n        }));\n    },\n    dragGroupEnd(moveable: MoveableGroupInterface<ClickableProps>, e: any) {\n        const inputEvent = e.inputEvent;\n        const inputTarget = e.inputTarget;\n\n        if (\n            !inputEvent || !inputTarget || e.isDrag\n            || moveable.isMoveableElement(inputTarget)\n            // External event duplicate target or dragAreaElement\n            || e.datas.inputTarget === inputTarget\n        ) {\n            return;\n        }\n        const targets = moveable.props.targets!;\n        let targetIndex = targets.indexOf(inputTarget);\n        const isTarget = targetIndex > -1;\n        let containsTarget = false;\n\n        if (targetIndex === -1) {\n            targetIndex = findIndex(targets, parentTarget => parentTarget.contains(inputTarget));\n            containsTarget = targetIndex > -1;\n        }\n\n        triggerEvent(moveable, \"onClickGroup\", fillParams<OnClickGroup>(moveable, e, {\n            isDouble: e.isDouble,\n            targets,\n            inputTarget,\n            targetIndex,\n            isTarget,\n            containsTarget,\n        }));\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<ClickableProps>, e: any) {\n        this.dragEnd(moveable, e);\n    },\n    dragGroupControlEnd(moveable: MoveableManagerInterface<ClickableProps>, e: any) {\n        this.dragEnd(moveable, e);\n    },\n});\n\n/**\n * When you click on the element, the `click` event is called.\n * @memberof Moveable\n * @event click\n * @param {Moveable.OnClick} - Parameters for the `click` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"click\", ({ hasTarget, containsTarget, targetIndex }) => {\n *     // If you click on an element other than the target and not included in the target, index is -1.\n *     console.log(\"onClickGroup\", target, hasTarget, containsTarget, targetIndex);\n * });\n */\n\n/**\n * When you click on the element inside the group, the `clickGroup` event is called.\n * @memberof Moveable\n * @event clickGroup\n * @param {Moveable.OnClickGroup} - Parameters for the `clickGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"clickGroup\", ({ inputTarget, isTarget, containsTarget, targetIndex }) => {\n *     // If you click on an element other than the target and not included in the target, index is -1.\n *     console.log(\"onClickGroup\", inputTarget, isTarget, containsTarget, targetIndex);\n * });\n */\n","import { hasClass } from \"@daybrush/utils\";\nimport { DraggableProps, MoveableGroupInterface, MoveableManagerInterface, Renderer } from \"../types\";\nimport { prefix } from \"../utils\";\nimport Draggable from \"./Draggable\";\nimport { makeAble } from \"./AbleManager\";\nimport { renderEdgeLines } from \"../renderDirections\";\n\nfunction getDraggableEvent(e: any) {\n    let datas = e.originalDatas.draggable;\n    if (!datas) {\n        e.originalDatas.draggable = {};\n        datas = e.originalDatas.draggable;\n    }\n    return { ...e, datas };\n}\nexport default makeAble(\"edgeDraggable\", {\n    css: [\n        `.edge.edgeDraggable.line {\n    cursor: move;\n}`,\n    ],\n    render(moveable: MoveableManagerInterface<DraggableProps>, React: Renderer) {\n        const props = moveable.props;\n        const edge = props.edgeDraggable!;\n\n        if (!edge) {\n            return [];\n        }\n        return renderEdgeLines(\n            React,\n            \"edgeDraggable\",\n            edge,\n            moveable.state.renderPoses,\n            props.zoom!,\n        );\n    },\n    dragControlCondition(moveable: MoveableManagerInterface<DraggableProps>, e: any) {\n        if (!moveable.props.edgeDraggable || !e.inputEvent) {\n            return false;\n        }\n        const target = e.inputEvent.target;\n        return hasClass(target, prefix(\"direction\"))\n            && hasClass(target, prefix(\"edge\"))\n            && hasClass(target, prefix(\"edgeDraggable\"));\n    },\n    dragControlStart(moveable: MoveableManagerInterface<DraggableProps>, e: any) {\n        (moveable.state as any).snapRenderInfo = {\n            request: e.isRequest,\n            snap: true,\n            center: true,\n        };\n        return Draggable.dragStart(moveable, getDraggableEvent(e));\n    },\n    dragControl(moveable: MoveableManagerInterface<DraggableProps>, e: any) {\n        return Draggable.drag(moveable, getDraggableEvent(e));\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<DraggableProps, any>, e: any) {\n        return Draggable.dragEnd(moveable, getDraggableEvent(e));\n    },\n    dragGroupControlCondition(moveable: MoveableGroupInterface<DraggableProps>, e: any) {\n        if (!moveable.props.edgeDraggable || !e.inputEvent) {\n            return false;\n        }\n        const target = e.inputEvent.target;\n        return hasClass(target, prefix(\"direction\")) && hasClass(target, prefix(\"line\"));\n    },\n    dragGroupControlStart(moveable: MoveableGroupInterface<DraggableProps>, e: any) {\n        return Draggable.dragGroupStart(moveable, getDraggableEvent(e));\n    },\n    dragGroupControl(moveable: MoveableGroupInterface<DraggableProps>, e: any) {\n        return Draggable.dragGroup(moveable, getDraggableEvent(e));\n    },\n    dragGroupControlEnd(moveable: MoveableGroupInterface<DraggableProps, any>, e: any) {\n        return Draggable.dragGroupEnd(moveable, getDraggableEvent(e));\n    },\n    unset(moveable: any) {\n        return Draggable.unset(moveable);\n    },\n});\n\n/**\n * Whether to move by dragging the edge line (default: false)\n * @name Moveable.Draggable#edgeDraggable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  draggable: true,\n *  edgeDraggable: false,\n * });\n *\n * moveable.edgeDraggable = true;\n */\n","export default {\n    name: \"individualGroupable\",\n    props: {\n        individualGroupable: Boolean,\n    } as const,\n    events: {} as const,\n} as const;\n","import Pinchable from \"./Pinchable\";\nimport Rotatable from \"./Rotatable\";\nimport Draggable from \"./Draggable\";\nimport Resizable from \"./Resizable\";\nimport Scalable from \"./Scalable\";\nimport Warpable from \"./Warpable\";\nimport Snappable from \"./Snappable\";\nimport DragArea from \"./DragArea\";\nimport Origin from \"./Origin\";\nimport Scrollable from \"./Scrollable\";\nimport Default from \"./Default\";\nimport Padding from \"./Padding\";\nimport Clippable from \"./Clippable\";\nimport OriginDraggable from \"./OriginDraggable\";\nimport Roundable from \"./Roundable\";\nimport { UnionToIntersection } from \"../types\";\nimport { invertObject } from \"../utils\";\nimport Groupable from \"./Groupable\";\nimport BeforeRenderable from \"./BeforeRenderable\";\nimport Renderable from \"./Renderable\";\nimport Clickable from \"./Clickable\";\nimport edgeDraggable from \"./edgeDraggable\";\nimport IndividualGroupable from \"./IndividualGroupable\";\n\nexport const MOVEABLE_ABLES = /*#__PURE__*/[\n    BeforeRenderable,\n    Default, Snappable, Pinchable, Draggable, edgeDraggable,\n    Resizable, Scalable, Warpable, Rotatable, Scrollable, Padding, Origin,\n    OriginDraggable,\n    Clippable, Roundable, Groupable, IndividualGroupable,\n    Clickable,\n    DragArea,\n    Renderable,\n] as const;\n\nexport const MOVEABLE_EVENTS_PROPS_MAP = /*#__PURE__*/MOVEABLE_ABLES.reduce((current, able) => {\n    return {...current, ...(\"events\" in able ? able.events : {})};\n}, {}) as UnionToIntersection<typeof MOVEABLE_ABLES[number][\"events\"]>;\nexport const MOVEABLE_PROPS_MAP = /*#__PURE__*/MOVEABLE_ABLES.reduce((current, able) => {\n    return {...current, ...able.props};\n}, {}) as UnionToIntersection<typeof MOVEABLE_ABLES[number][\"props\"]>;\n\nexport const MOVEABLE_EVENTS_MAP = /*#__PURE__*/invertObject(MOVEABLE_EVENTS_PROPS_MAP);\nexport const MOVEABLE_EVENTS: string[] = /*#__PURE__*/Object.keys(MOVEABLE_EVENTS_MAP);\nexport const MOVEABLE_PROPS: string[] = /*#__PURE__*/Object.keys(MOVEABLE_PROPS_MAP);\n","import MoveableManager from \"./MoveableManager\";\nimport { GroupableProps, RectInfo } from \"./types\";\nimport ChildrenDiffer from \"@egjs/children-differ\";\nimport { getAbleGesto, getTargetAbleGesto } from \"./gesto/getAbleGesto\";\nimport Groupable from \"./ables/Groupable\";\nimport { MIN_NUM, MAX_NUM, TINY_NUM } from \"./consts\";\nimport { getAbsolutePosesByState, equals, unset } from \"./utils\";\nimport { minus, plus, rotate } from \"@scena/matrix\";\nimport { getMinMaxs } from \"overlap-area\";\nimport { throttle } from \"@daybrush/utils\";\nimport { getMoveableTargetInfo } from \"./utils/getMoveableTargetInfo\";\n\nfunction getMaxPos(poses: number[][][], index: number) {\n    return Math.max(...poses.map(([pos1, pos2, pos3, pos4]) => {\n        return Math.max(pos1[index], pos2[index], pos3[index], pos4[index]);\n    }));\n}\nfunction getMinPos(poses: number[][][], index: number) {\n    return Math.min(...poses.map(([pos1, pos2, pos3, pos4]) => {\n        return Math.min(pos1[index], pos2[index], pos3[index], pos4[index]);\n    }));\n}\nfunction getGroupRect(moveables: MoveableManager[], rotation: number) {\n    if (!moveables.length) {\n        return [0, 0, 0, 0];\n    }\n\n    const moveablePoses = moveables.map(({ state }) => getAbsolutePosesByState(state));\n    let minX = MAX_NUM;\n    let minY = MAX_NUM;\n    let groupWidth = 0;\n    let groupHeight = 0;\n    const fixedRotation = throttle(rotation, TINY_NUM);\n\n    if (fixedRotation % 90) {\n        const rad = fixedRotation / 180 * Math.PI;\n        const a1 = Math.tan(rad);\n        const a2 = -1 / a1;\n        const b1MinMax = [MIN_NUM, MAX_NUM];\n        const b2MinMax = [MIN_NUM, MAX_NUM];\n\n        moveablePoses.forEach(poses => {\n            poses.forEach(pos => {\n                // ax + b = y\n                // b = y - ax\n                const b1 = pos[1] - a1 * pos[0];\n                const b2 = pos[1] - a2 * pos[0];\n\n                b1MinMax[0] = Math.max(b1MinMax[0], b1);\n                b1MinMax[1] = Math.min(b1MinMax[1], b1);\n                b2MinMax[0] = Math.max(b2MinMax[0], b2);\n                b2MinMax[1] = Math.min(b2MinMax[1], b2);\n            });\n        });\n\n        b1MinMax.forEach(b1 => {\n            // a1x + b1 = a2x + b2\n            b2MinMax.forEach(b2 => {\n                // (a1 - a2)x = b2 - b1\n                const x = (b2 - b1) / (a1 - a2);\n                const y = a1 * x + b1;\n\n                minX = Math.min(minX, x);\n                minY = Math.min(minY, y);\n            });\n        });\n        const rotatePoses = moveablePoses.map(([pos1, pos2, pos3, pos4]) => {\n            return [\n                rotate(pos1, -rad),\n                rotate(pos2, -rad),\n                rotate(pos3, -rad),\n                rotate(pos4, -rad),\n            ];\n        });\n\n        groupWidth = getMaxPos(rotatePoses, 0) - getMinPos(rotatePoses, 0);\n        groupHeight = getMaxPos(rotatePoses, 1) - getMinPos(rotatePoses, 1);\n    } else {\n        minX = getMinPos(moveablePoses, 0);\n        minY = getMinPos(moveablePoses, 1);\n        groupWidth = getMaxPos(moveablePoses, 0) - minX;\n        groupHeight = getMaxPos(moveablePoses, 1) - minY;\n\n        if (fixedRotation % 180) {\n            const changedWidth = groupWidth;\n\n            groupWidth = groupHeight;\n            groupHeight = changedWidth;\n        }\n    }\n    return [minX, minY, groupWidth, groupHeight];\n}\n/**\n * @namespace Moveable.Group\n * @description You can make targets moveable.\n */\nclass MoveableGroup extends MoveableManager<GroupableProps> {\n    public static defaultProps = {\n        ...MoveableManager.defaultProps,\n        transformOrigin: [\"50%\", \"50%\"],\n        groupable: true,\n        dragArea: true,\n        keepRatio: true,\n        targets: [],\n        defaultGroupRotate: 0,\n        defaultGroupOrigin: \"50% 50%\",\n    };\n    public differ: ChildrenDiffer<HTMLElement | SVGElement> = new ChildrenDiffer();\n    public moveables: MoveableManager[] = [];\n    public transformOrigin = \"50% 50%\";\n\n    public checkUpdate() {\n        this.updateAbles();\n    }\n\n    public updateRect(type?: \"Start\" | \"\" | \"End\", isTarget?: boolean, isSetState = true) {\n        if (!this.controlBox) {\n            return;\n        }\n        this.moveables.forEach(moveable => {\n            moveable.updateRect(type, false, false);\n        });\n\n        const state = this.state;\n        const props = this.props;\n        const target = state.target! || props.target!;\n\n        if (!isTarget || (type !== \"\" && props.updateGroup)) {\n            // reset rotataion\n            this.rotation = props.defaultGroupRotate!;\n            this.transformOrigin = props.defaultGroupOrigin || \"50% 50%\";\n            this.scale = [1, 1];\n\n        }\n        const rotation = this.rotation;\n        const scale = this.scale;\n        const [left, top, width, height] = getGroupRect(this.moveables, rotation);\n\n        // tslint:disable-next-line: max-line-length\n        const transform = `rotate(${rotation}deg) scale(${scale[0] >= 0 ? 1 : -1}, ${scale[1] >= 0 ? 1 : -1})`;\n        target.style.cssText += `left:0px;top:0px; transform-origin: ${this.transformOrigin}; width:${width}px; height:${height}px;`\n            + `transform:${transform}`;\n        state.width = width;\n        state.height = height;\n\n        const container = this.getContainer();\n        const info = getMoveableTargetInfo(\n            this.controlBox.getElement(),\n            target,\n            this.controlBox.getElement(),\n            this.getContainer(),\n            this.props.rootContainer || container,\n            // state,\n        );\n        const pos = [info.left!, info.top!];\n        const [\n            pos1,\n            pos2,\n            pos3,\n            pos4,\n        ] = getAbsolutePosesByState(info); // info.left + info.pos(1 ~ 4)\n\n        const minPos = getMinMaxs([pos1, pos2, pos3, pos4]);\n        const delta = [minPos.minX, minPos.minY];\n        info.pos1 = minus(pos1, delta);\n        info.pos2 = minus(pos2, delta);\n        info.pos3 = minus(pos3, delta);\n        info.pos4 = minus(pos4, delta);\n        info.left = left - info.left! + delta[0];\n        info.top = top - info.top! + delta[1];\n        info.origin = minus(plus(pos, info.origin!), delta);\n        info.beforeOrigin = minus(plus(pos, info.beforeOrigin!), delta);\n        info.originalBeforeOrigin = plus(pos, info.originalBeforeOrigin!);\n        // info.transformOrigin = minus(plus(pos, info.transformOrigin!), delta);\n\n        const clientRect = info.targetClientRect!;\n        const direction = scale[0] * scale[1] > 0 ? 1 : -1;\n\n        clientRect.top += info.top - state.top;\n        clientRect.left += info.left - state.left;\n\n        target.style.transform = `translate(${-delta[0]}px, ${-delta[1]}px) ${transform}`;\n\n        this.updateState(\n            {\n                ...info,\n                direction,\n                beforeDirection: direction,\n            },\n            isSetState,\n        );\n    }\n    public getRect(): RectInfo {\n        return {\n            ...super.getRect(),\n            children: this.moveables.map(child => child.getRect()),\n        };\n    }\n    public triggerEvent(name: string, e: any, isManager?: boolean): any {\n        if (isManager || name.indexOf(\"Group\") > -1) {\n            return super.triggerEvent(name as any, e);\n        } else {\n            this._emitter.trigger(name, e);\n        }\n    }\n    protected updateAbles() {\n        super.updateAbles([...this.props.ables!, Groupable], \"Group\");\n    }\n    protected _updateTargets() {\n        super._updateTargets();\n        this._prevTarget = this.props.dragTarget || this.areaElement;\n    }\n    protected _updateEvents() {\n        const state = this.state;\n        const props = this.props;\n\n        const prevTarget = this._prevTarget;\n        const nextTarget = props.dragTarget || this.areaElement;\n\n        if (prevTarget !== nextTarget) {\n            unset(this, \"targetGesto\");\n            unset(this, \"controlGesto\");\n            state.target = null;\n        }\n        if (!state.target) {\n            state.target = this.areaElement;\n            this.controlBox.getElement().style.display = \"block\";\n        }\n        if (state.target) {\n            if (!this.targetGesto) {\n                this.targetGesto = getTargetAbleGesto(this, nextTarget, \"Group\");\n            }\n            if (!this.controlGesto) {\n                this.controlGesto = getAbleGesto(this, this.controlBox.getElement(), \"controlAbles\", \"GroupControl\");\n            }\n        }\n        const isContainerChanged = !equals(state.container, props.container);\n\n        if (isContainerChanged) {\n            state.container = props.container;\n        }\n        const { added, changed, removed } = this.differ.update(props.targets!);\n\n        if (isContainerChanged || added.length || changed.length || removed.length) {\n            this.updateRect();\n        }\n    }\n    protected _updateObserver() {}\n}\n\n/**\n * Sets the initial rotation of the group.\n * @name Moveable.Group#defaultGroupRotate\n * @default 0\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   target: [].slice.call(document.querySelectorAll(\".target\")),\n *   defaultGroupRotate: 0,\n * });\n *\n * moveable.defaultGroupRotate = 40;\n */\n\n/**\n * Sets the initial origin of the group.\n * @name Moveable.Group#defaultGroupOrigin\n * @default 0\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   target: [].slice.call(document.querySelectorAll(\".target\")),\n *   defaultGroupOrigin: \"50% 50%\",\n * });\n *\n * moveable.defaultGroupOrigin = \"20% 40%\";\n */\n\n\n/**\n * Whether to hide the line in child moveable for group corresponding to the rect of the target.\n * @name Moveable.Group#hideChildMoveableDefaultLines\n * @default false\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   target: [].slice.call(document.querySelectorAll(\".target\")),\n *   hideChildMoveableDefaultLines: false,\n * });\n *\n * moveable.hideChildMoveableDefaultLines = true;\n */\nexport default MoveableGroup;\n","import { ref, refs } from \"framework-utils\";\nimport * as React from \"react\";\nimport MoveableManager from \"./MoveableManager\";\nimport { GroupableProps, RectInfo } from \"./types\";\nimport { prefix } from \"./utils\";\n\n/**\n * @namespace Moveable.IndividualGroup\n * @description Create targets individually, not as a group.Create targets individually, not as a group.\n */\nclass MoveableIndividualGroup extends MoveableManager<GroupableProps> {\n    public moveables: MoveableManager[] = [];\n    public render() {\n        const {\n            cspNonce,\n            cssStyled: ControlBoxElement,\n            targets,\n        } = this.props;\n\n        return <ControlBoxElement\n            cspNonce={cspNonce}\n            ref={ref(this, \"controlBox\")}\n            className={prefix(\"control-box\")}>\n            {targets!.map((target, i) => {\n                return <MoveableManager\n                    key={\"moveable\" + i}\n                    ref={refs(this, \"moveables\", i)}\n                    {...this.props}\n                    target={target}\n                    wrapperMoveable={this}\n                />;\n            })}\n        </ControlBoxElement>;\n    }\n    public componentDidUpdate() {}\n    public updateRect(type?: \"Start\" | \"\" | \"End\", isTarget?: boolean, isSetState: boolean = true) {\n        this.moveables.forEach(moveable => {\n            moveable.updateRect(type, isTarget, isSetState);\n        });\n    }\n    public getRect(): RectInfo {\n        return {\n            ...super.getRect(),\n            children: this.moveables.map(child => child.getRect()),\n        };\n    }\n    public request() {\n        return {\n            request() {\n                return this;\n            },\n            requestEnd() {\n                return this;\n            },\n        };\n    }\n    public dragStart() {\n        return this;\n    }\n    public hitTest() {\n        return 0;\n    }\n    public isInside() {\n        return false;\n    }\n    public isDragging() {\n        return false;\n    }\n    public updateRenderPoses() { }\n    public checkUpdate() { }\n    public triggerEvent() { }\n    protected updateAbles() { }\n    protected _updateEvents() { }\n    protected _updateObserver() {}\n}\n\n/**\n * Create targets individually, not as a group.\n * @name Moveable.IndividualGroup#individualGroupable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   target: [].slice.call(document.querySelectorAll(\".target\")),\n *   individualGroupable: true,\n * });\n */\nexport default MoveableIndividualGroup;\n","import * as React from \"react\";\nimport {\n    Able, MoveableInterface, GroupableProps, MoveableDefaultProps,\n    IndividualGroupableProps, MoveableManagerInterface,\n} from \"./types\";\nimport MoveableManager from \"./MoveableManager\";\nimport MoveableGroup from \"./MoveableGroup\";\nimport { ref, withMethods, prefixCSS } from \"framework-utils\";\nimport { getKeys, IObject, isString } from \"@daybrush/utils\";\nimport { MOVEABLE_METHODS, PREFIX, MOVEABLE_CSS } from \"./consts\";\nimport Default from \"./ables/Default\";\nimport Groupable from \"./ables/Groupable\";\nimport DragArea from \"./ables/DragArea\";\nimport styled from \"react-css-styled\";\nimport { getRefTargets, getElementTargets } from \"./utils\";\nimport IndividualGroupable from \"./ables/IndividualGroupable\";\nimport MoveableIndividualGroup from \"./MoveableIndividualGroup\";\n\n\nexport class InitialMoveable<T = {}>\n    extends React.PureComponent<MoveableDefaultProps & GroupableProps & IndividualGroupableProps & T> {\n    public static defaultAbles: Able[] = [];\n    public static customStyledMap: Record<string, any> = {};\n    public static defaultStyled: any = null;\n    public static makeStyled() {\n        const cssMap: IObject<boolean> = {};\n\n        const ables = this.getTotalAbles();\n        ables.forEach(({ css }: Able) => {\n            if (!css) {\n                return;\n            }\n            css.forEach(text => {\n                cssMap[text] = true;\n            });\n        });\n        const style = getKeys(cssMap).join(\"\\n\");\n\n        this.defaultStyled = styled(\"div\", prefixCSS(PREFIX, MOVEABLE_CSS + style));\n    }\n    public static getTotalAbles(): Able[] {\n\n        return [Default, Groupable, IndividualGroupable, DragArea, ...this.defaultAbles];\n    }\n    @withMethods(MOVEABLE_METHODS)\n    public moveable!: MoveableManager | MoveableGroup | MoveableIndividualGroup;\n    public refTargets: Array<HTMLElement | SVGElement | string | undefined | null> = [];\n    public selectorMap: IObject<Array<HTMLElement | SVGElement>> = {};\n    public render() {\n        const moveableContructor = (this.constructor as typeof InitialMoveable);\n\n        if (!moveableContructor.defaultStyled) {\n            moveableContructor.makeStyled();\n        }\n        const {\n            ables: userAbles,\n            props: userProps,\n            ...props\n        } = this.props;\n        const refTargets = this._updateRefs(true);\n        const elementTargets = getElementTargets(refTargets, this.selectorMap);\n\n        const isGroup = elementTargets.length > 1;\n        const totalAbles = moveableContructor.getTotalAbles();\n        const ables = [\n            ...totalAbles,\n            ...(userAbles as any || []),\n        ];\n        const nextProps = {\n            ...props,\n            ...(userProps || {}),\n            ables,\n            cssStyled: moveableContructor.defaultStyled,\n            customStyledMap: moveableContructor.customStyledMap,\n        };\n\n        if (isGroup) {\n            if (props.individualGroupable) {\n                return <MoveableIndividualGroup key=\"individual-group\" ref={ref(this, \"moveable\")}\n                    {...nextProps}\n                    target={null}\n                    targets={elementTargets} />;\n            }\n            return <MoveableGroup key=\"group\" ref={ref(this, \"moveable\")}\n                {...nextProps}\n                target={null}\n                targets={elementTargets}  />;\n        } else {\n            return <MoveableManager<any> key=\"single\" ref={ref(this, \"moveable\")}\n                {...nextProps}\n                target={elementTargets[0]} />;\n        }\n    }\n    public componentDidMount() {\n        this._updateRefs();\n    }\n    public componentDidUpdate() {\n        this._updateRefs();\n    }\n    public componentWillUnmount() {\n        this.selectorMap = {};\n        this.refTargets = [];\n    }\n    public getManager(): MoveableManagerInterface<any, any> {\n        return this.moveable;\n    }\n    private _updateRefs(isRender?: boolean) {\n        const prevRefTargets = this.refTargets;\n        const nextRefTargets = getRefTargets((this.props.target || this.props.targets) as any);\n        const isBrowser = typeof document !== \"undefined\";\n\n        let isUpdate = (prevRefTargets.length !== nextRefTargets.length) || prevRefTargets.some((target, i) => {\n            const nextTarget = nextRefTargets[i];\n\n            if (!target && !nextTarget) {\n                return false;\n            } else if (target !== nextTarget) {\n                return true;\n            }\n            return false;\n        });\n        const selectorMap = this.selectorMap;\n        const nextSelectorMap: IObject<Array<HTMLElement | SVGElement>> = {};\n\n        this.refTargets.forEach(target => {\n            if (isString(target)) {\n                const selectorTarget = selectorMap[target];\n\n                if (selectorTarget) {\n                    nextSelectorMap[target] = selectorMap[target];\n                } else if (isBrowser) {\n                    isUpdate = true;\n                    nextSelectorMap[target] = [].slice.call(document.querySelectorAll(target));\n                }\n            }\n        });\n\n        this.refTargets = nextRefTargets;\n        this.selectorMap = nextSelectorMap;\n\n        if (!isRender && isUpdate) {\n            this.forceUpdate();\n        }\n        return nextRefTargets;\n    }\n}\nexport interface InitialMoveable<T = {}>\n    extends React.PureComponent<MoveableDefaultProps & GroupableProps & IndividualGroupableProps & T>,\n    MoveableInterface {\n    setState(state: any, callback?: () => any): any;\n    forceUpdate(callback?: () => any): any;\n}\n","import { MoveableProps, Able } from \"./types\";\nimport { MOVEABLE_ABLES } from \"./ables/consts\";\nimport { InitialMoveable } from \"./InitialMoveable\";\n\nexport default class Moveable<T = {}> extends InitialMoveable<MoveableProps & T> {\n    public static defaultAbles: Able[] = MOVEABLE_ABLES as any;\n}\n","import { Able } from \"./types\";\nimport { InitialMoveable } from \"./InitialMoveable\";\n\nexport function makeMoveable<T = {}>(\n    ables: Array<Able<T>>): typeof InitialMoveable & (new (...args: any[]) => InitialMoveable<T>) {\n    return class Moveable extends InitialMoveable<T> {\n        public static defaultAbles = ables;\n    };\n}\n","import Moveable, * as others from \"./index.esm\";\n\nfor (const name in others) {\n    (Moveable as any)[name] = (others as any)[name];\n}\nexport default Moveable;\n"],"names":["makeAble","name","able","__assign","events","props","_a","Boolean","getSVGCursor","scale","degree","getCursorCSS","x1","degree45","Math","round","defaultCursor","agent","getAgent","IS_WEBKIT","browser","webkit","IS_WEBKIT605","navi","window","userAgent","navigator","res","exec","toLowerCase","parseFloat","IS_SAFARI_ABOVE15","parseInt","webkitVersion","version","PREFIX","MOVEABLE_CSS","map","join","NEARBY_POS","FLOAT_POINT_NUM","TINY_NUM","MIN_SCALE","MAX_NUM","pow","MIN_NUM","DIRECTIONS4","DIRECTIONS","DIRECTION_REGION_TO_DIRECTION","n","e","s","w","nw","ne","sw","se","DIRECTION_INDEXES","DIRECTION_ROTATIONS","MOVEABLE_METHODS","setCustomDrag","state","delta","isPinch","isConvert","ableName","result","gestos","move","inputEvent","datas","originalDatas","ableDatas","convertDragDist","parentEvent","draggable","client","isDrag","isFlag","type","prevX","prevY","clientX","clientY","startX","startY","distX","distY","deltaX","deltaY","parentGesto","calculatePointerDist","moveable","moveableClientRect","rootMatrix","is3d","pos1","left","top","_b","minus","calculateInversePosition","posX","posY","_c","getDragDist","setDragStart","allMatrix","beforeMatrix","origin","offsetMatrix","targetMatrix","transformOrigin","matrix","inverseMatrix","invert","inverseBeforeMatrix","absoluteOrigin","convertPositionMatrix","plus","startDragBeforeDist","calculate","startDragDist","getTransformDirection","calculateMoveablePosition","beforeTransform","direction","resolveTransformEvent","event","functionName","index","transformIndex","nextTransforms","length","nextTransformAppendedIndexes","nextIndex","find","info","filter","convertTransformInfo","targetFunction","matFunctionName","beforeFunctionTexts","afterFunctionTexts","beforeFunctionMatrix","beforeTransform2","beforeFunctionMatrix2","targetTansform","targetFunctionMatrix","afterTransform","afterFunctionMatrix","afterTransform2","afterFunctionMatrix2","targetAllTransform","allFunctionMatrix","splice","isAppendTransform","isAppend","convertTransformFormat","value","dist","getTransformDist","getBeforeDragDist","bx","by","getTransfromMatrix","fromTranslation","isAfter","nextTargetMatrix","multiply","res1","afterTargetMatrix","isBefore","getInverseDragDist","calculateTransformOrigin","width","height","prevWidth","prevHeight","prevOrigin","pos","i","splitUnit","unit","prevSize","size","isNaN","measureRatio","getPosIndexesByDirection","indexes","push","getPosesByDirection","poses","getPosByDirection","xRatio","yRatio","dot","bottom","getDist","startPos","fixedDirection","calculatePoses","fixedPos","getNextMatrix","getAbsoluteMatrix","getNextTransformMatrix","transform","targetTransform","parseMat","convertDimension","scaleMatrix","createScaleMatrix","fillTransformStartEvent","getBeforeRenderableDatas","setTransform","startTransforms","isArray","splitSpace","setTransformIndex","setDefaultTransformIndex","property","findIndex","func","indexOf","parse","startValue","functionValue","fillOriginalTransform","beforeRenderable","getNextTransforms","getNextTransformText","getNextStyle","nextStyle","fillTransformEvent","nextTransform","drag","Draggable","fillCSSObject","getTranslateDist","fixedPosition","groupable","nextMatrix","groupLeft","groupTop","nextFixedPosition","getDirectionOffset","getScaleDist","scaleDist","getOriginDirection","nextFixedOffset","calculatePosition","getRotateDist","rotateDist","getResizeDist","nextOrigin","getAbsolutePosition","getAbsolutePosesByState","multiply2","pos2","prefix","_i","classNames","prefixNames","defaultSync","fn","getTransformMatrix","isObject","multiplies","createOriginMatrix","a","measureSVGSize","el","isHorizontal","viewBox","getSVGViewBox","ownerSVGElement","getBeforeTransformOrigin","relativeOrigin","getTransformOrigin","getComputedStyle","o","style","split","getElementTransform","target","computedStyle","computedTransform","list","baseVal","matrixes","chr","getOffsetInfo","lastParent","isParent","body","document","assignedSlot","parentElement","isCustomElement","isEnd","position","tagName","willChange","parentNode","nodeType","host","console","log","isStatic","offsetParent","getOffsetPosInfo","offsetLeft","offsetTop","isSVG","isUndefined","hasOffset","targetOrigin","slice","getSVGGraphicsOffset","offset","getBodyOffset","bodyStyle","bodyPosition","marginLeft","marginTop","right","convert3DMatrixes","forEach","getBodyScrollPos","documentElement","scrollLeft","scrollTop","getPositionFixedInfo","fixedContainer","hasTransform","getMatrixStackInfo","container","checkContainer","requestEnd","targetTransformOrigin","hasFixed","offsetContainer","convertCSStoMatrix","isFixed","fixedInfo","offsetPos","getSVGMatrix","createIdentityMatrix","isOffsetEnd","offsetInfo","parentClientLeft","parentClientTop","fixedClientLeft","fixedClientTop","clientLeft","clientTop","margin","makeMatrixCSS","convertMatrixtoCSS","clientWidth","clientHeight","x","y","viewBoxWidth","viewBoxHeight","scaleX","scaleY","preserveAspectRatio","align","meetOrSlice","svgOrigin","translate","xAlign","yAlign","floor","scaleDimension","max","min","getBBox","bbox","getRect","posesX","posesY","rectWidth","rectHeight","calculateRect","getSVGOffset","targetInfo","getSize","containerClientRect","getBoundingClientRect","rect","rectLeft","rectTop","mat","prevLeft","prevTop","posOrigin","rectOrigin","count","mat2","_d","nextLeft","nextTop","distLeft","distTop","abs","p","calculateMoveableClientPositions","rootClientRect","rootPoses","y1","x2","y2","x3","y3","x4","y4","_e","originX","originY","getShapeDirection","pos3","pos4","getDistSize","vec","sqrt","getDiagonalSize","getLineStyle","zoom","rad","getRad","getControlTransform","rotation","reduce","prev","getProps","self","offsetWidth","offsetHeight","cssWidth","cssHeight","contentWidth","contentHeight","minWidth","minHeight","minOffsetWidth","minOffsetHeight","maxWidth","Infinity","maxHeight","maxOffsetWidth","maxOffsetHeight","svg","targetStyle","boxSizing","borderLeft","borderLeftWidth","borderRight","borderRightWidth","borderTop","borderTopWidth","borderBottom","borderBottomWidth","paddingLeft","paddingRight","paddingTop","paddingBottom","horizontalPadding","verticalPadding","horizontalBorder","verticalBorder","horizontalOffset","verticalOffset","convertUnitSize","inlineCSSWidth","inlineCSSHeight","computedWidth","computedHeight","between","getRotationRad","resetClientRect","scrollWidth","scrollHeight","getClientRect","isExtends","innerWidth","innerHeight","scrollPos","clientRect","overflow","getDirection","direciton","getAttribute","dir","getAbsolutePoses","roundSign","num","unset","resolvedEvent","cssText","getKeys","fillAfterTransform","prevEvent","nextEvent","fillParams","params","isBeforeEvent","nextParams","currentTarget","isStartEvent","lastEvent","fillEndParams","isDouble","catchEvent","callback","_emitter","on","triggerEvent","isManager","pseudoElt","filterAbles","ables","methods","triggerAblesSimultaneously","enabledAbles","ableGroups","some","method","ableGroup","equals","a1","a2","selectValue","values","groupBy","arr","groups","groupKeys","groupKey","keyIndex","group","groupByMap","flat","cur","concat","maxOffset","args","sort","b","calculatePadding","convertCSSSize","isRelative","getTinyDist","v","getDirectionCondition","checkAbles","isRequest","requestAble","parentDirection","hasClass","invertObject","obj","nextObj","transforms","undefined","beforeFunctionTexts2","targetFunctionText","afterFunctionTexts2","beforeFunctions","beforeFunctions2","targetFunctions","afterFunctions","afterFunctions2","toMat","isArrayFormat","Element","getRefTarget","isSelector","isString","querySelector","isFunction","current","getRefTargets","targets","userTargets","call","querySelectorAll","getElementTargets","selectorMap","elementTargets","getAbsoluteRotation","deg","PI","getDragDistByState","calculateMatrixDist","getSizeDistByDist","startSize","ratio","keepRatio","startOffsetWidth","startOffsetHeight","distWidth","distHeight","standardRad","signSize","cos","startWidthSize","startHeightSize","distSize","ratioRad","sin","getOffsetSizeDist","sizeDirection","parentDistance","parentDist","parentScale","startFixedDirection","directionsDists","directionRatios","ratioDistance","dist_1","onPinchStart","onPinch","onPinchEnd","onPinchGroupStart","onPinchGroup","onPinchGroupEnd","dragStart","pinchStart","angle","pinchable","eventName","controlEventName","pinchAbles","controlAbles","canPinch","ableEvent","parentRotate","snapRenderInfo","request","pinch","pinchScale","distance","pinchEnd","pinchGroupStart","pinchGroup","pinchGroupEnd","fillChildEvents","groupableDatas","childDatas","moveables","_","triggerChildGesto","isStart","match","childs","ev","childMoveable","childEvent","CustomGesto","childGestos","parentFlag","child","triggerChildAbles","eachEvent","VERTICAL_NAMES","HORIZONTAL_NAMES","VERTICAL_NAMES_MAP","start","end","center","HORIZONTAL_NAMES_MAP","hasGuidelines","snappable","bounds","innerBounds","verticalGuidelines","horizontalGuidelines","snapGridWidth","snapGridHeight","guidelines","enableSnap","getSnapDirections","snapDirections","mapSnapDirectionPoses","snapPoses","nextSnapDirections","nextSnapPoses","splitSnapDirectionPoses","horizontalNames","verticalNames","horizontal","vertical","calculateContainerPos","containerRect","clientPos","solveLineConstants","point1","point2","dx","dy","c","throttle","checkMoveableSnapPoses","customSnapThreshold","snapThreshold","checkSnapPoses","checkSnap","checkSnapKeepRatio","endPos","endX","endY","isBottom","isRight","verticalInfo","isSnap","horizontalInfo","verticalSnapInfo","horizontalSnapInfo","posInfos","getNearestSnapGuidelineInfo","isVerticalSnap","verticalGuideline","isHorizontalSnap","horizontalGuideline","horizontalPos","verticalPos","checkSnaps","snapInfo","guideline","posInfo","guidelineInfo","guidelineInfos","targetType","targetPoses","isVertical","posType","snapPosInfos","targetPos","snapPosInfo","getSnapInfosByDirection","snapDirection","nextPoses","alignPoses","checkSnapBoundPriority","aDist","bDist","isBound","getNearOffsetInfo","offsets","aSign","sign","bSign","aOffset","bOffset","getCheckSnapDirections","directions","endDirection_1","signX","signY","nextDirection","signs","isStartLine","line","cx","average","cy","hitTestLine","test1","test2","isSameStartLine","dots","centerSign","error","every","checkInnerBoundDot","threshold","checkInnerBound","verticalSign","horizontalSign","lineConstants","isAllBound","isVerticalBound","isHorizontalBound","leftLine","topLine","rightLine","bottomLine","topBoundInfo","checkLineBoundCollision","bottomBoundInfo","leftBoundInfo","rightBoundInfo","isAllVerticalBound","isAllHorizontalBound","boundLine","isRender","dot1","boundDot1","boundDot2","dy2","dx2","hasDx","hasDy","slope","getInnerBoundInfo","lineInfos","multiple","sizeOffset","getInnerBoundDragInfo","lines","getCheckInnerBoundLineInfos","innerBoundInfo","widthOffsetInfo","heightOffsetInfo","getCheckSnapLineDirections","lineDirections","virtualPoses","dir1","dir2","virtualLine","isBoundRotate","relativePoses","boundDots","rotate","getDistPointLine","solveReverseLine","checkRotateInnerBounds","prevPoses","relativeLeft","relativeRight","relativeTop","relativeBottom","dotInfos","lineRad","lineDist","dotDist","dotRad","distRad","acos","nextRad1","nextRad2","nextRad","checkInnerBoundPoses","horizontalPoses","verticalPoses","boundMap","lineInfo","isHorizontalStart","isVerticalStart","checkBoundPoses","_f","nextBounds","checkBounds","getBounds","externalBounds","containerHeight","containerWidth","snapOffsetLeft","snapOffsetTop","snapOffsetRight","snapOffsetBottom","isCSS","_g","checkBoundKeepRatio","startBoundPos","endBoundPos","minPos","maxPos","boundInfos","boundRect","boundRotate","boundPos","r","nextPos","checkRotateBounds","relativeRad1","relativeRad2","renderGuideline","React","key","scaleType","createElement","className","renderInnerGuideline","__spreadArray","sizeValue","posValue","renderSnapPoses","renderPos","renderGuidelines","targetRect","isDisplayInnerSnapDigit","mainNames","targetStart","targetEnd","hide","elementRect","element","renderDigitLine","lineType","gap","snapDigit","isDisplaySnapDigit","snapDistFormat","sizeName","absGap","snapSize","toFixed","groupByElementGuidelines","otherIndex","names","nextGuidelines","inner","elementRect1","elementRect2","nextPos1","nextPos2","total","renderDashedGuidelines","rendered","sideNames","sidePos","prevRect","nextRect","size1","size2","renderPos1","renderPos2","renderGapGuidelines","targetSideStart","targetSideEnd","gapRects","sideStartPos","sideEndPos","sideCenterPos","solveEquation","snapOffset","solveNextOffset","isOutside","dist1","dist2","widthOffset","heightOffset","getSnapBound","boundInfo","checkThrottleDragRotate","throttleDragRotate","offsetX","offsetY","adjustPoses","adjustPos","prevDistY","checkSnapBoundsDrag","absolutePoses","boundPoses","middle","checkMoveableSnapBounds","verticalSnapBoundInfo","horizontalSnapBoundInfo","verticalInnerBoundInfo","horizontalInnerBoundInfo","horizontalBoundInfos","verticalBoundInfos","horizontalDist","verticalDist","snapIndex","snap","checkSnapBounds","guideines","checkSnapRightLine","snapBoundInfo","rad180","isHorizontalLine","isVerticalLine","getSnapBoundInfo","startDirection","endDirection","otherStartPos","otherEndPos","checkSnapBoundsKeepRatio","otherHorizontalOffset","isOtherHorizontalBound","isOtherHorizontalSnap","otherVerticalOffset","isOtherVerticalBound","isOtherVerticalSnap","snapLine","getSnapBoundOffset","horizontalBoundInfo","verticalBoundInfo","checkMaxBounds","left_1","top_1","right_1","bottom_1","otherDirection","isCheckVertical","isCheckHorizontal","otherPos","nextOtherPos","isHeightOutside","isWidthOutside","getTotalGuidelines","containerClientHeight","containerClientWidth","snapGap","_h","maxSnapElementGuidelineDistance","_j","elementGuidelines","getElementGuidelines","totalGuidelines","getGapGuidelines","getGridGuidelines","getDefaultGuidelines","checkBetweenRects","elementRects","gapGuidelines","targetCenter","targetStart2","targetEnd2","nextElementRects","snapRect1","snapRect2","rect1","rect2","rect1Start","rect1End","rect2Start","rect2End","isCenter","prevValues","snapRect","refresh","nextElementGuidelines","diff","maintained","added","nextValues","prevIndex","getSnapElementRects","elementSnapDirections","topValue","leftValue","rightValue","bottomValue","centerValue","middleValue","sizes","snapWidth","snapHeight","nextPosInfo","containerLeft","containerTop","getMinMaxs","targetLeft","targetTop","elementLeft","elementTop","elementRight","elementBottom","snapStart","snapContainer","snapContainerTarget","snapContainerRect","offset1","offset2","getNextFixedPoses","nextFixedPos","getSizeOffsetInfo","innerBoundLineInfos","recheckSizeByTwoDirection","snapPos","nextWidthOffset","nextHeightOffset","nextWidth","nextHeight","checkSizeDist","getNextPoses","isWidthBound","isHeightBound","widthDist","heightDist","isGetWidthOffset","checkSnapRotate","checkSnapResize","nextAllMatrix","checkSnapScale","sizeDist","startCheckSnapDrag","getSnapGuidelines","addBoundGuidelines","verticalSnapPoses","horizontalSnapPoses","verticalInnerBoundPoses","horizontalInnerBoundPoses","innerPos","directionCondition","dragRelation","Array","Object","Number","Function","onSnap","css","render","minLeft","minTop","externalPoses","snapInfos","hasExternalPoses","externalRect","verticalPosInfos","horizontalPosInfos","allGuidelines","elements","gaps","dragEnd","dragControlCondition","rotatableDragControlCondtion","dragControlStart","dragControl","dragControlEnd","dragGroupStart","dragGroup","dragGroupEnd","dragGroupControlStart","dragGroupControl","dragGroupControlEnd","renderDirectionControlsByInfos","renderDirections","renderPoses","rotationRad","degRotation","directionMap","renderState","renderDirectionMap","data","directionRotation","dataAttrs","renderDirectionControls","defaultDirections","renderAroundControls","renderLine","renderEdgeLines","edge","index1","index2","getRenderDirections","renderDiagonalDirections","renderAllDirections","throttleDrag","startDragRotate","edgeDraggable","onDragStart","onDrag","onDragEnd","onDragGroupStart","onDragGroup","onDragGroupEnd","dragInfo","beforeOrigin","targetGesto","prevDist","prevBeforeDist","deltaOffset","set","startRect","parentMoveable","dragRotateRad","ry","rx","beforeTranslate","throttleArray","beforeDist","beforeDelta","passDelta","passDist","dragAfter","param","isControl","requestStart","resizable","throttleResize","resizeFormat","keepRatioFinally","onResizeStart","onBeforeResize","onResize","onResizeEnd","onResizeGroupStart","onBeforeResizeGroup","onResizeGroup","onResizeGroupEnd","isGroup","parentFixedDirection","controlGesto","minSize","startWidth","startHeight","maxSize","startOffsetMatrix","startTransformOrigin","isWidth","parentIsWidth","setRatio","isFinite","startPositions","setFixedDirection","setMin","setMax","nextMaxSize","isNumber","startRatio","setOrigin","isResize","parentKeepRatio","dragClient","resolveMatrix","targetN","getNextBoundingSize","nextSize","boundingWidth","boundingHeight","nextFixedDirection","setSize","snapDist","computeSize","isNoSnap","calculateBoundSize","inverseDelta","dragControlAfter","errorWidth","errorHeight","isErrorWidth","isErrorHeight","dragGroupControlCondition","originalEvents","setDist","createRotateMatrix","originalX","originalY","parentStartOffsetWidth","parentStartOffsetHeight","updateGroupMin","originalMinSize","childMinSize","childStartOffsetWidth","childStartOffsetHeight","parentMinWidth","parentMinHeight","updateGroupMax","originalMaxSize","childMaxSize","parentMaxWidth","parentMaxHeight","deltaWidth","deltaHeight","setRotateStartInfo","startAbsoluteOrigin","prevDeg","defaultDeg","prevSnapDeg","loop","startDist","getAbsoluteDist","normalizedPrevDeg","getAbsoluteDistByClient","getRotateInfo","moveableRect","throttleRotate","nextDist","snapRotation","snapDeg","getRotationPositions","rotationPosition","radPoses","isReverse","rotationTarget","contains","directionCSS","rotatable","String","rotateAroundControls","resolveAblesWithRotatable","onRotateStart","onBeforeRotate","onRotate","onRotateEnd","onRotateGroupStart","onBeforeRotateGroup","onRotateGroup","onRotateGroupEnd","positions","jsxs","resolveMap_1","directionControlInfos","resolve","beforeDirection","resizeStart","startClientX","startClientY","externalRotate","beforeInfo","afterInfo","absoluteInfo","inputTarget","regionDirection","controlDirection","isAroundControl","resolveAble","clientPoses","originalFixedDirection_1","originalPosition","getOrigin","fixedBeforeOrigin","fixedAfterOrigin","Resizable","rotatation","isRotate","groupDelta","targetDirection","beforeRotation","absoluteDelta","absoluteDist","absoluteRotation","startRotation","absoluteStartRotation","nextClientX","nextClientY","setRotation","nextRotation","inverseDist","prevInverseDist","requestValue","dragEvent","transformEvent","resize","resizeEvent","beforeRotate","absoluteRotate","parentLeft","parentTop","parentBeforeOrigin","childClient","groupClient","rotateMatrix","setGroupRotation","distRotate","getRotation","deltaRotate","scalable","throttleScale","onScaleStart","onBeforeScale","onScale","onScaleEnd","onScaleGroupStart","onBeforeScaleGroup","onScaleGroup","onScaleGroupEnd","scaleWidth","scaleHeight","scaleXRatio","scaleYRatio","isScale","getNextScale","stateDirection","setScale","nextScale","moveableScale","getMiddleLinePos","getTriangleRad","rad1","rad2","isValidPos","poses1","poses2","pi","warpable","onWarpStart","onWarp","onWarpEnd","linePosFrom1","linePosFrom2","linePosFrom3","linePosFrom4","linePosTo1","linePosTo2","linePosTo3","linePosTo4","warpTargetMatrix","targetInverseMatrix","ignoreDimension","prevMatrix","posIndexes","isWarp","selectedPoses","nearByPoses","h","createWarpMatrix","afterMatrix","totalMatrix","AREA_PIECES","AREA_PIECE","AVOID","restoreStyle","areaElement","removeClass","renderPieces","dragArea","passDragArea","onClick","onClickGroup","ref","isDragArea","rects","children","nextElementSibling","addClass","disableNativeEvent","enableNativeEvent","requestAnimationFrame","getDefaultScrollPosition","scrollContainer","scrollable","scrollThreshold","getScrollPosition","onScroll","onScrollGroup","getContainer","dragScroll","DragScroll","scrollContainerElement","gestoName","scrollBy","checkScroll","dragGroupContro","dragGroupControEnd","dragTarget","portalContainer","rootContainer","useResizeObserver","pinchThreshold","pinchOutside","checkInput","cspNonce","translateZ","hideDefaultLines","flushSync","stopPropagation","preventClickEventOnDrag","preventClickDefault","padding","paddingDirections","paddingPos1","paddingPos2","paddingPos3","paddingPos4","RADIUS_DIRECTIONS","calculateRatio","sumSize","sumRatio","HORIZONTAL_RADIUS_ORDER","VERTICAL_RADIUS_ORDER","HORIZONTAL_RADIUS_DIRECTIONS","VERTICAL_RADIUS_DIRECTIONS","getRadiusStyles","controlPoses","clipStyles","raws","rawPos","styles","getRadiusRange","horizontalRange","verticalRange","clipPose","sub","getRadiusValues","minCounts","splitIndex","splitLength","horizontalValues","verticalValues","nwValue","neValue","seValue","swValue","wnValue","_k","enValue","_l","esValue","_m","wsValue","horizontalRawPoses","verticalRawPoses","nextHorizontalPoses","nextVerticalPoses","raw","removeRadiusPos","startIndex","radiuslIndex","deleteCount","addRadiusPos","horizontalIndex","verticalIndex","radiusX","radiusY","startVerticalIndex","splitRadiusPoses","horizontals","verticals","CLIP_DIRECTIONS","CLIP_RECT_DIRECTIONS","getClipStyles","clipPath","clipRelative","clipType","clipPoses","isRect","isCircle","subWidth","subHeight","getRectPoses","xs","ys","dirx","diry","getControlSize","xRange","yRange","moveControlPos","dists","verticalDirections","horizontalDirections","verticalDirection_1","horizontalDirection_1","fixedIndex","nextControlPoses_1","controlPose","controlDir","dirDir","dirHorizontal","dirVertical","getClipPath","defaultClip","customClip","clipText","clip","splitBracket","clipPrefix","splitter","splitComma","xPos","yPos","radiusX_1","radiusY_1","radius","xRadius","yRadius","centerPos_1","roundIndex","rectLength","radiusValues","_o","_p","_q","_r","nextRight","nextBottom","radiusPoses","_s","addClipPath","clipIndex","clipEventType","clipStyle","removeClipPath","clippable","defaultClipPath","customClipPath","clipArea","dragWithClip","clipTargetBounds","clipVerticalGuidelines","clipHorizontalGuidelines","clipSnapThreshold","onClipStart","onClip","onClipEnd","clipPathState","snapBoundInfos","calculatedPos","controls","isInset","isPolygon","linePoses_1","to","from","clipLeft","clipTop","ellipseClipPath","piece","areaPoses","allWidth","allHeight","allLeft_1","allTop_1","directionType","snapPos1","snapPos2","isDragTarget","isClipStart","isLine","isArea","originalDraggable","originalDist","firstDist","isDragWithTarget","isAll","guidePoses","isEllipse","guideRect","guideXPoses","guideYPoses","rectPoses","rectDists_1","boundDelta","snapOffsetY","snapOffsetX","distSnapX","distSnapY","width_1","height_1","nextControlPoses_2","j","nextClipStyles","dragDist","originDraggable","originRelative","onDragOriginStart","onDragOrigin","onDragOriginEnd","startOrigin","startTargetOrigin","isDragOrigin","distOrigin","dragDelta","deltaOrigin","addBorderRadius","lineIndex","horizontalsLength","verticalsLength","getBorderRadius","borderRadius","triggerRoundEvent","roundRelative","borderRadiusState","roundable","minRoundControls","maxRoundControls","roundClickable","onRoundStart","onRound","onRoundEnd","verticalCount","horizontalCount","isDisplay","display","controlIndex","isRound","selectedControlPose","selectedVertical","selectedHorizontal","pose","poseDist","isIdentityMatrix","identityMatrix","onBeforeRenderStart","onBeforeRender","onBeforeRenderEnd","onBeforeRenderGroupStart","onBeforeRenderGroup","onBeforeRenderGroupEnd","cssMatrix","startTransform","resetStyle","fillDragStartParams","fillDragParams","_this","onRenderStart","onRender","onRenderEnd","onRenderGroupStart","onRenderGroup","onRenderGroupEnd","resultCount","fillDragEndParams","triggerAble","ableType","eventOperation","eventAffix","eventType","requestInstant","conditionName","isFirstStart","updateRect","requestAble_1","eventAbles","BeforeRenderable","Renderable","elementFromPoint","results","nextDatas","isEventStart","off","isUpdate","isForceEnd","preventDefault","isUnmounted","forceUpdate","getTargetAbleGesto","moveableTarget","controlBox","getElement","startFunc","eventTarget","isMoveableElement","getAbleGesto","conditionFunctions","isTargetAbles","options","preventRightClick","preventWheelClick","preventClickEventOnDragStart","gesto","Gesto","stop","addEventListener","_onEvent","removeEventListener","calculateMatrixStack","isAbsolute3d","prevTargetMatrix","rootMatrixes","isRoot3d","offsetRootContainer","isNext3d","isSVGGraphicElement","reverse","originalRootContainer","endContainer","rootMatrixBeforeOffset","nextInfo","isMatrix3d","calculateElementInfo","allResult","getElementInfo","getMoveableTargetInfo","moveableElement","parentContainer","targetClientRect","rootContainerClientRect","beforePosition","originalBeforeOrigin","__extends","EventEmitter","isDragging","checkUpdateRect","cancelAnimationFrame","_observerId","parentPosition","propsTarget","ControlBoxElement","checkUpdate","updateRenderPoses","stateTarget","groupTargets","ableAttributes","getEnabledAbles","onPreventClick","renderAbles","_renderLines","wrapperMoveable","_updateTargets","_updateNativeEvents","_updateEvents","updateCheckInput","_updateObserver","prevProps","manager","destroy","triggerDragStart","points","fitPoints","getOverlapSize","totalSize","getAreaSize","isInside","isTarget","isSetState","updateState","statePos","isInstant","requsetAble","ableRequester","requester","ableParam","componentWillUnmount","stateLeft","stateTop","stateContainer","updateAbles","isChanged","moveableContainer","unsetAbles","trigger","tag","customStyleMap","customStyledMap","styled","targetAbles","always","nextState","setState","Renderer","ResizeObserver","_observer","disconnect","observer","observe","box","controlBoxElement","hasTargetAble","hasControlAble","isUnset","_isTargetChanged","_prevTarget","_prevDragArea","hideChildMoveableDefaultLines","useDragArea","prevTarget","prevDragArea","isTargetChanged","isDragAreaChanged","eventKeys","hasAbles","EventManager","setAbles","MoveableManager","cssStyled","defaultGroupRotate","defaultGroupOrigin","refs","clickable","containsElement","containsTarget","targetIndex","parentTarget","getDraggableEvent","individualGroupable","MOVEABLE_ABLES","Default","Snappable","Pinchable","Scalable","Warpable","Rotatable","Scrollable","Padding","Origin","OriginDraggable","Clippable","Roundable","Groupable","IndividualGroupable","Clickable","DragArea","MOVEABLE_EVENTS_PROPS_MAP","MOVEABLE_PROPS_MAP","MOVEABLE_EVENTS_MAP","MOVEABLE_EVENTS","keys","MOVEABLE_PROPS","getMaxPos","getMinPos","getGroupRect","moveablePoses","minX","minY","groupWidth","groupHeight","fixedRotation","rad_1","a1_1","tan","a2_1","b1MinMax_1","b2MinMax_1","b1","b2","rotatePoses","changedWidth","ChildrenDiffer","updateGroup","_super","nextTarget","isContainerChanged","differ","update","changed","removed","MoveableGroup","defaultProps","InitialMoveable","cssMap","getTotalAbles","text","defaultStyled","prefixCSS","defaultAbles","moveableContructor","constructor","makeStyled","userAbles","userProps","refTargets","_updateRefs","totalAbles","nextProps","MoveableIndividualGroup","prevRefTargets","nextRefTargets","isBrowser","nextSelectorMap","selectorTarget","__decorate","withMethods","Moveable","makeMoveable","others"],"mappings":"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"}