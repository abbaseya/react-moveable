{"version":3,"file":"moveable.esm.js","sources":["../src/react-moveable/ables/AbleManager.ts","../src/react-moveable/consts.ts","../src/react-moveable/gesto/CustomGesto.ts","../src/react-moveable/gesto/GestoUtils.ts","../src/react-moveable/utils.tsx","../src/react-moveable/ables/Pinchable.ts","../src/react-moveable/groupUtils.ts","../src/react-moveable/ables/snappable/utils.ts","../src/react-moveable/ables/snappable/snap.ts","../src/react-moveable/ables/snappable/innerBounds.ts","../src/react-moveable/ables/snappable/bounds.ts","../src/react-moveable/ables/snappable/render.tsx","../src/react-moveable/ables/snappable/snapBounds.ts","../src/react-moveable/ables/snappable/getTotalGuidelines.ts","../src/react-moveable/ables/Snappable.tsx","../src/react-moveable/renderDirections.tsx","../src/react-moveable/ables/Draggable.tsx","../src/react-moveable/ables/Resizable.ts","../src/react-moveable/ables/Rotatable.tsx","../src/react-moveable/ables/Scalable.ts","../src/react-moveable/ables/Warpable.tsx","../src/react-moveable/classNames.ts","../src/react-moveable/ables/DragArea.tsx","../src/react-moveable/ables/Origin.tsx","../src/react-moveable/ables/Scrollable.ts","../src/react-moveable/ables/Default.ts","../src/react-moveable/ables/Padding.tsx","../src/react-moveable/ables/roundable/borderRadius.tsx","../src/react-moveable/ables/Clippable.tsx","../src/react-moveable/ables/OriginDraggable.tsx","../src/react-moveable/ables/Roundable.tsx","../src/react-moveable/ables/BeforeRenderable.ts","../src/react-moveable/ables/Renderable.ts","../src/react-moveable/gesto/getAbleGesto.ts","../src/react-moveable/EventManager.ts","../src/react-moveable/utils/calculateMatrixStack.ts","../src/react-moveable/utils/getElementInfo.ts","../src/react-moveable/utils/getMoveableTargetInfo.ts","../src/react-moveable/MoveableManager.tsx","../src/react-moveable/ables/Groupable.tsx","../src/react-moveable/ables/Clickable.ts","../src/react-moveable/ables/edgeDraggable.tsx","../src/react-moveable/ables/IndividualGroupable.tsx","../src/react-moveable/ables/consts.ts","../src/react-moveable/MoveableGroup.tsx","../src/react-moveable/MoveableIndividualGroup.tsx","../src/react-moveable/InitialMoveable.tsx","../src/react-moveable/Moveable.tsx","../src/react-moveable/makeMoveable.ts"],"sourcesContent":["import { Able, DefaultProps } from \"../types\";\n\nexport function makeAble<\n    Name extends string,\n    AbleObject extends Partial<Able<any, any>>,\n    Props extends DefaultProps<Name, AbleObject>,\n>(name: Name, able: AbleObject) {\n    return {\n        events: {} as const,\n        props: {\n            [name]: Boolean,\n        } as Props,\n        name,\n        ...able,\n    } as const;\n}\n","import getAgent from \"@egjs/agent\";\nimport { IObject } from \"@daybrush/utils\";\nimport { MoveableInterface } from \"./types\";\n\nfunction getSVGCursor(scale: number, degree: number) {\n    return `data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${32 * scale}px\" height=\"${32 * scale}px\" viewBox=\"0 0 32 32\" ><path d=\"M 16,5 L 12,10 L 14.5,10 L 14.5,22 L 12,22 L 16,27 L 20,22 L 17.5,22 L 17.5,10 L 20, 10 L 16,5 Z\" stroke-linejoin=\"round\" stroke-width=\"1.2\" fill=\"black\" stroke=\"white\" style=\"transform:rotate(${degree}deg);transform-origin: 16px 16px\"></path></svg>`;\n}\nfunction getCursorCSS(degree: number) {\n    const x1 = getSVGCursor(1, degree);\n    // const x2 = getSVGCursor(2, degree);\n    const degree45 = (Math.round(degree / 45) * 45) % 180;\n    let defaultCursor = \"ns-resize\";\n\n    if (degree45 === 135) {\n        defaultCursor = \"nwse-resize\";\n    } else if (degree45 === 45) {\n        defaultCursor = \"nesw-resize\";\n    } else if (degree45 === 90) {\n        defaultCursor = \"ew-resize\";\n    }\n\n    // tslint:disable-next-line: max-line-length\n    return `cursor:${defaultCursor};cursor: url('${x1}') 16 16, ${defaultCursor};`;\n}\n\nexport const agent = getAgent();\nexport const IS_WEBKIT = agent.browser.webkit;\nexport const IS_WEBKIT605 = IS_WEBKIT && (() => {\n    const navi = typeof window === \"undefined\" ? { userAgent: \"\" } : window.navigator;\n    const res = /applewebkit\\/([^\\s]+)/g.exec(navi.userAgent.toLowerCase());\n\n    return res ? parseFloat(res[1]) < 605 : false;\n})();\nexport const IS_SAFARI_ABOVE15\n    = parseInt(agent.browser.webkitVersion, 10) >= 612\n    || parseInt(agent.browser.version, 10) >= 15;\n\nexport const PREFIX = \"moveable-\";\nexport const MOVEABLE_CSS = `\n{\n\tposition: absolute;\n\twidth: 1px;\n\theight: 1px;\n\tleft: 0;\n\ttop: 0;\n    z-index: 3000;\n    --moveable-color: #4af;\n    --zoom: 1;\n    --zoompx: 1px;\n    will-change: transform;\n}\n.control-box {\n    z-index: 0;\n}\n.line, .control {\n    position: absolute;\n\tleft: 0;\n    top: 0;\n    will-change: transform;\n}\n.control {\n\twidth: 14px;\n\theight: 14px;\n\tborder-radius: 50%;\n\tborder: 2px solid #fff;\n\tbox-sizing: border-box;\n    background: #4af;\n    background: var(--moveable-color);\n\tmargin-top: -7px;\n    margin-left: -7px;\n    border: 2px solid #fff;\n    z-index: 10;\n}\n.padding {\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    width: 100px;\n    height: 100px;\n    transform-origin: 0 0;\n}\n.line {\n\twidth: 1px;\n    height: 1px;\n    background: #4af;\n    background: var(--moveable-color);\n\ttransform-origin: 0px 50%;\n}\n.line.edge {\n    z-index: 1;\n    background: transparent;\n}\n.line.dashed {\n    box-sizing: border-box;\n    background: transparent;\n}\n.line.dashed.horizontal {\n    border-top: 1px dashed #4af;\n    border-top-color: #4af;\n    border-top-color: var(--moveable-color);\n}\n.line.dashed.vertical {\n    border-left: 1px dashed #4af;\n    border-left-color: #4af;\n    border-left-color: var(--moveable-color);\n}\n.line.vertical {\n    transform: translateX(-50%);\n}\n.line.horizontal {\n    transform: translateY(-50%);\n}\n.line.vertical.bold {\n    width: 2px;\n}\n.line.horizontal.bold {\n    height: 2px;\n}\n\n.control.origin {\n\tborder-color: #f55;\n\tbackground: #fff;\n\twidth: 12px;\n\theight: 12px;\n\tmargin-top: -6px;\n    margin-left: -6px;\n\tpointer-events: none;\n}\n${[0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165].map(degree => `\n.direction[data-rotation=\"${degree}\"] {\n\t${getCursorCSS(degree)}\n}\n`).join(\"\\n\")}\n.group {\n    z-index: -1;\n}\n.area {\n    position: absolute;\n}\n.area-pieces {\n    position: absolute;\n    top: 0;\n    left: 0;\n    display: none;\n}\n.area.avoid, .area.pass {\n    pointer-events: none;\n}\n.area.avoid+.area-pieces {\n    display: block;\n}\n.area-piece {\n    position: absolute;\n}\n\n${IS_WEBKIT605 ? `:global svg *:before {\n\tcontent:\"\";\n\ttransform-origin: inherit;\n}` : \"\"}\n`;\nexport const DRAGGER_EVENTS = [\"dragstart\", \"drag\", \"dragend\", \"pinchstart\", \"pinch\", \"pinchend\"];\n\nexport const NEARBY_POS = [\n    [0, 1, 2],\n    [1, 0, 3],\n    [2, 0, 3],\n    [3, 1, 2],\n];\n\nexport const FLOAT_POINT_NUM = 0.0001;\nexport const TINY_NUM = 0.0000001;\nexport const MIN_SCALE = 0.000000001;\nexport const MAX_NUM = Math.pow(10, 10);\nexport const MIN_NUM = -MAX_NUM;\n\n\nexport const DIRECTIONS4 = [\"n\", \"w\", \"s\", \"e\"];\nexport const DIRECTIONS = [\"n\", \"w\", \"s\", \"e\", \"nw\", \"ne\", \"sw\", \"se\"];\n\nexport const DIRECTION_REGION_TO_DIRECTION: Record<string, number[]> = {\n    n: [0, -1],\n    e: [1, 0],\n    s: [0, 1],\n    w: [-1, 0],\n    nw: [-1, -1],\n    ne: [1, -1],\n    sw: [-1, 1],\n    se: [1, 1],\n};\n\nexport const DIRECTION_INDEXES: IObject<number[]> = {\n    n: [0, 1],\n    e: [1, 3],\n    s: [3, 2],\n    w: [2, 0],\n    nw: [0],\n    ne: [1],\n    sw: [2],\n    se: [3],\n};\nexport const DIRECTION_ROTATIONS: IObject<number> = {\n    n: 0,\n    s: 180,\n    w: 270,\n    e: 90,\n    nw: 315,\n    ne: 45,\n    sw: 225,\n    se: 135,\n};\n\nexport const MOVEABLE_METHODS: Array<keyof MoveableInterface> = [\n    \"isMoveableElement\",\n    \"updateRect\",\n    \"updateTarget\",\n    \"destroy\",\n    \"dragStart\",\n    \"isInside\",\n    \"hitTest\",\n    \"setState\",\n    \"getRect\",\n    \"request\",\n    \"isDragging\",\n    \"getManager\",\n    \"forceUpdate\",\n];\n","import { MoveableManagerState, OnCustomDrag } from \"../types\";\nimport { convertDragDist } from \"../utils\";\n\nexport function setCustomDrag(\n    e: any,\n    state: MoveableManagerState<any>,\n    delta: number[],\n    isPinch: boolean,\n    isConvert: boolean,\n    ableName = \"draggable\",\n) {\n    const result = state.gestos[ableName].move(delta, e.inputEvent);\n    const datas = result.originalDatas || result.datas;\n    const ableDatas = datas[ableName] || (datas[ableName] = {});\n\n    return {\n        ...(isConvert ? convertDragDist(state, result) : result),\n        isPinch: !!isPinch,\n        parentEvent: true,\n        datas: ableDatas,\n        originalDatas: e.originalDatas,\n    };\n}\n\nexport default class CustomGesto {\n    private prevX = 0;\n    private prevY = 0;\n    private startX = 0;\n    private startY = 0;\n    private isDrag = false;\n    private isFlag = false;\n    private datas: any = {\n        draggable: {},\n    };\n    constructor(private ableName = \"draggable\") {\n        this.datas = {\n            [ableName]: {},\n        };\n    }\n\n    public dragStart(client: number[], e: any) {\n        this.isDrag = false;\n        this.isFlag = false;\n        const originalDatas = e.originalDatas;\n\n        this.datas = originalDatas;\n        if (!originalDatas[this.ableName]) {\n            originalDatas[this.ableName] = {};\n        }\n        return {\n            ...this.move(client, e.inputEvent),\n            type: \"dragstart\",\n        };\n    }\n    public drag(client: number[], inputEvent: any) {\n        return this.move([\n            client[0] - this.prevX,\n            client[1] - this.prevY,\n        ], inputEvent);\n    }\n    public move(delta: number[], inputEvent: any): OnCustomDrag {\n        let clientX!: number;\n        let clientY!: number;\n        if (!this.isFlag) {\n            this.prevX = delta[0];\n            this.prevY = delta[1];\n            this.startX = delta[0];\n            this.startY = delta[1];\n\n            clientX = delta[0];\n            clientY = delta[1];\n\n            this.isFlag = true;\n        } else {\n            clientX = this.prevX + delta[0];\n            clientY = this.prevY + delta[1];\n\n            if (delta[0] || delta[1]) {\n                this.isDrag = true;\n            }\n        }\n\n        this.prevX = clientX;\n        this.prevY = clientY;\n\n        return {\n            type: \"drag\",\n            clientX,\n            clientY,\n            inputEvent,\n            isDrag: this.isDrag,\n            distX: clientX - this.startX,\n            distY: clientY - this.startY,\n            deltaX: delta[0],\n            deltaY: delta[1],\n            datas: this.datas[this.ableName],\n            originalDatas: this.datas,\n            parentEvent: true,\n            parentGesto: this,\n        };\n    }\n}\n","\nimport {\n    invert, calculate, minus, plus,\n    convertPositionMatrix,\n    createScaleMatrix, multiply, fromTranslation, convertDimension,\n} from \"@scena/matrix\";\nimport {\n    calculatePoses, getAbsoluteMatrix, getAbsolutePosesByState,\n    calculatePosition, calculateInversePosition, calculateMoveablePosition, convertTransformInfo, fillCSSObject,\n} from \"../utils\";\nimport { splitUnit, isArray, splitSpace, findIndex, dot, find } from \"@daybrush/utils\";\nimport {\n    MoveableManagerState, ResizableProps, MoveableManagerInterface,\n    OnTransformEvent, OnTransformStartEvent, DraggableProps, OnDrag,\n} from \"../types\";\nimport { setCustomDrag } from \"./CustomGesto\";\nimport { parse, parseMat } from \"css-to-mat\";\nimport { Draggable } from \"../index.esm\";\n\nexport function calculatePointerDist(moveable: MoveableManagerInterface, e: any) {\n    const { clientX, clientY, datas } = e;\n    const {\n        moveableClientRect,\n        rootMatrix,\n        is3d,\n        pos1,\n    } = moveable.state;\n    const { left, top } = moveableClientRect;\n    const n = is3d ? 4 : 3;\n    const [posX, posY] = minus(calculateInversePosition(rootMatrix, [clientX - left, clientY - top], n), pos1);\n    const [distX, distY] = getDragDist({ datas, distX: posX, distY: posY });\n\n    return [distX, distY];\n}\n\nexport function setDragStart(moveable: MoveableManagerInterface<any>, { datas }: any) {\n    const {\n        allMatrix,\n        beforeMatrix,\n        is3d,\n        left,\n        top,\n        origin,\n        offsetMatrix,\n        targetMatrix,\n        transformOrigin,\n    } = moveable.state;\n    const n = is3d ? 4 : 3;\n\n    datas.is3d = is3d;\n    datas.matrix = allMatrix;\n    datas.targetMatrix = targetMatrix;\n    datas.beforeMatrix = beforeMatrix;\n    datas.offsetMatrix = offsetMatrix;\n    datas.transformOrigin = transformOrigin;\n    datas.inverseMatrix = invert(allMatrix, n);\n    datas.inverseBeforeMatrix = invert(beforeMatrix, n);\n    datas.absoluteOrigin = convertPositionMatrix(plus([left, top], origin), n);\n    datas.startDragBeforeDist = calculate(datas.inverseBeforeMatrix, datas.absoluteOrigin, n);\n    datas.startDragDist = calculate(datas.inverseMatrix, datas.absoluteOrigin, n);\n}\nexport function getTransformDirection(e: any) {\n    return calculateMoveablePosition(e.datas.beforeTransform, [50, 50], 100, 100).direction;\n}\nexport function resolveTransformEvent(event: any, functionName: string) {\n    const {\n        datas,\n        originalDatas: {\n            beforeRenderable: originalDatas,\n        },\n    } = event;\n\n    const index = datas.transformIndex;\n\n\n    const nextTransforms = originalDatas.nextTransforms;\n    const length = nextTransforms.length;\n    const nextTransformAppendedIndexes: any[] = originalDatas.nextTransformAppendedIndexes;\n    let nextIndex = 0;\n\n    if (index === -1) {\n        nextIndex = nextTransforms.length;\n        datas.transformIndex = nextIndex;\n    } else if (find(nextTransformAppendedIndexes, info => info.index === index && info.functionName === functionName)) {\n        nextIndex = index;\n    } else {\n        nextIndex = index + nextTransformAppendedIndexes.filter(info => info.index < index).length;\n    }\n\n    const result = convertTransformInfo(nextTransforms, nextIndex);\n    const targetFunction = result.targetFunction;\n    const matFunctionName = functionName === \"rotate\" ? \"rotateZ\" : functionName;\n\n    datas.beforeFunctionTexts = result.beforeFunctionTexts;\n    datas.afterFunctionTexts = result.afterFunctionTexts;\n    datas.beforeTransform = result.beforeFunctionMatrix;\n    datas.beforeTransform2 = result.beforeFunctionMatrix2;\n    datas.targetTansform = result.targetFunctionMatrix;\n    datas.afterTransform = result.afterFunctionMatrix;\n    datas.afterTransform2 = result.afterFunctionMatrix2;\n    datas.targetAllTransform = result.allFunctionMatrix;\n\n    if (targetFunction.functionName === matFunctionName) {\n        datas.afterFunctionTexts.splice(0, 1);\n        datas.isAppendTransform = false;\n    } else if (length > nextIndex) {\n        datas.isAppendTransform = true;\n\n        originalDatas.nextTransformAppendedIndexes = [...nextTransformAppendedIndexes, {\n            functionName,\n            index: nextIndex,\n            isAppend: true,\n        }];\n    }\n}\n\nexport function convertTransformFormat(datas: any, value: any, dist: any) {\n    return `${datas.beforeFunctionTexts.join(\" \")} ${datas.isAppendTransform ? dist : value} ${datas.afterFunctionTexts.join(\" \")}`;\n}\nexport function getTransformDist({ datas, distX, distY }: any) {\n    const [bx, by] = getBeforeDragDist({ datas, distX, distY });\n    // B * [tx, ty] * A = [bx, by] * targetMatrix;\n    // [tx, ty] = B-1 * [bx, by] * targetMatrix * A-1 * [0, 0];\n\n    const res = getTransfromMatrix(datas, fromTranslation([bx, by], 4));\n\n    return calculate(res, convertPositionMatrix([0, 0, 0], 4), 4);\n}\nexport function getTransfromMatrix(datas: any, targetMatrix: number[], isAfter?: boolean) {\n    const {\n        beforeTransform,\n        afterTransform,\n        beforeTransform2,\n        afterTransform2,\n        targetAllTransform,\n    } = datas;\n\n    // B * afterTargetMatrix * A = (targetMatrix * targetAllTransform)\n    // afterTargetMatrix = B-1 * targetMatrix * targetAllTransform * A-1\n    // nextTargetMatrix = (targetMatrix * targetAllTransform)\n    const nextTargetMatrix\n        = isAfter\n            ? multiply(targetAllTransform, targetMatrix, 4)\n            : multiply(targetMatrix, targetAllTransform, 4);\n\n    // res1 = B-1 * nextTargetMatrix\n    const res1 = multiply(invert(isAfter ? beforeTransform2 : beforeTransform, 4), nextTargetMatrix, 4);\n\n    // res3 = res2 * A-1\n    const afterTargetMatrix = multiply(res1, invert(isAfter ? afterTransform2 : afterTransform, 4), 4);\n\n    return afterTargetMatrix;\n}\nexport function getBeforeDragDist({ datas, distX, distY }: any) {\n    // TT = BT\n    const {\n        inverseBeforeMatrix,\n        is3d,\n        startDragBeforeDist,\n        absoluteOrigin,\n    } = datas;\n    const n = is3d ? 4 : 3;\n\n    // ABS_ORIGIN * [distX, distY] = BM * (ORIGIN + [tx, ty])\n    // BM -1 * ABS_ORIGIN * [distX, distY] - ORIGIN = [tx, ty]\n    return minus(\n        calculate(\n            inverseBeforeMatrix,\n            plus(absoluteOrigin, [distX, distY]),\n            n,\n        ),\n        startDragBeforeDist,\n    );\n}\nexport function getDragDist({ datas, distX, distY }: any, isBefore?: boolean) {\n    const {\n        inverseBeforeMatrix,\n        inverseMatrix,\n        is3d,\n        startDragBeforeDist,\n        startDragDist,\n        absoluteOrigin,\n    } = datas;\n    const n = is3d ? 4 : 3;\n\n    return minus(\n        calculate(\n            isBefore ? inverseBeforeMatrix : inverseMatrix,\n            plus(absoluteOrigin, [distX, distY]),\n            n,\n        ),\n        isBefore ? startDragBeforeDist : startDragDist,\n    );\n}\nexport function getInverseDragDist({ datas, distX, distY }: any, isBefore?: boolean) {\n    const {\n        beforeMatrix,\n        matrix,\n        is3d,\n        startDragBeforeDist,\n        startDragDist,\n        absoluteOrigin,\n    } = datas;\n    const n = is3d ? 4 : 3;\n\n    return minus(\n        calculate(\n            isBefore ? beforeMatrix : matrix,\n            plus(isBefore ? startDragBeforeDist : startDragDist, [distX, distY]),\n            n,\n        ),\n        absoluteOrigin,\n    );\n}\n\nexport function calculateTransformOrigin(\n    transformOrigin: string[],\n    width: number,\n    height: number,\n    prevWidth: number = width,\n    prevHeight: number = height,\n    prevOrigin: number[] = [0, 0],\n) {\n\n    if (!transformOrigin) {\n        return prevOrigin;\n    }\n    return transformOrigin.map((pos, i) => {\n        const { value, unit } = splitUnit(pos);\n\n        const prevSize = (i ? prevHeight : prevWidth);\n        const size = (i ? height : width);\n        if (pos === \"%\" || isNaN(value)) {\n            // no value but %\n\n            const measureRatio = prevSize ? prevOrigin[i] / prevSize : 0;\n\n            return size * measureRatio;\n        } else if (unit !== \"%\") {\n            return value;\n        }\n        return size * value / 100;\n    });\n}\nexport function getPosIndexesByDirection(direction: number[]) {\n    const indexes: number[] = [];\n\n    if (direction[1] >= 0) {\n        if (direction[0] >= 0) {\n            indexes.push(3);\n        }\n        if (direction[0] <= 0) {\n            indexes.push(2);\n        }\n    }\n    if (direction[1] <= 0) {\n        if (direction[0] >= 0) {\n            indexes.push(1);\n        }\n        if (direction[0] <= 0) {\n            indexes.push(0);\n        }\n    }\n    return indexes;\n}\nexport function getPosesByDirection(\n    poses: number[][],\n    direction: number[],\n) {\n    /*\n    [-1, -1](pos1)       [0, -1](pos1,pos2)       [1, -1](pos2)\n    [-1, 0](pos1, pos3)                           [1, 0](pos2, pos4)\n    [-1, 1](pos3)        [0, 1](pos3, pos4)       [1, 1](pos4)\n    */\n    return getPosIndexesByDirection(direction).map(index => poses[index]);\n}\nexport function getPosByDirection(\n    poses: number[][],\n    direction: number[],\n) {\n    const xRatio = (direction[0] + 1) / 2;\n    const yRatio = (direction[1] + 1) / 2;\n\n    const top = [\n        dot(poses[0][0], poses[1][0], xRatio, 1 - xRatio),\n        dot(poses[0][1], poses[1][1], xRatio, 1 - xRatio),\n    ];\n    const bottom = [\n        dot(poses[2][0], poses[3][0], xRatio, 1 - xRatio),\n        dot(poses[2][1], poses[3][1], xRatio, 1 - xRatio),\n    ];\n    return [\n        dot(top[0], bottom[0], yRatio, 1 - yRatio),\n        dot(top[1], bottom[1], yRatio, 1 - yRatio),\n    ];\n}\n\nfunction getDist(\n    startPos: number[],\n    matrix: number[],\n    width: number,\n    height: number,\n    n: number,\n    fixedDirection: number[],\n) {\n    const poses = calculatePoses(matrix, width, height, n);\n    const fixedPos = getPosByDirection(poses, fixedDirection);\n    const distX = startPos[0] - fixedPos[0];\n    const distY = startPos[1] - fixedPos[1];\n\n    return [distX, distY];\n}\nexport function getNextMatrix(\n    offsetMatrix: number[],\n    targetMatrix: number[],\n    origin: number[],\n    n: number,\n) {\n    return multiply(\n        offsetMatrix,\n        getAbsoluteMatrix(targetMatrix, n, origin),\n        n,\n    );\n}\nexport function getNextTransformMatrix(\n    state: MoveableManagerState<any>,\n    datas: any,\n    transform: string,\n) {\n    const {\n        transformOrigin,\n        offsetMatrix,\n        is3d,\n    } = state;\n    const {\n        beforeTransform,\n        afterTransform,\n    } = datas;\n    const n = is3d ? 4 : 3;\n    const targetTransform = parseMat([transform]);\n\n    return getNextMatrix(\n        offsetMatrix,\n        convertDimension(multiply(multiply(beforeTransform, targetTransform as any, 4), afterTransform, 4), 4, n),\n        transformOrigin,\n        n,\n    );\n}\nexport function scaleMatrix(\n    state: MoveableManagerState<any>,\n    scale: number[],\n) {\n    const {\n        transformOrigin,\n        offsetMatrix,\n        is3d,\n        targetMatrix,\n    } = state;\n    const n = is3d ? 4 : 3;\n\n    return getNextMatrix(\n        offsetMatrix,\n        multiply(targetMatrix, createScaleMatrix(scale, n), n),\n        transformOrigin,\n        n,\n    );\n}\n\nexport function fillTransformStartEvent(e: any): OnTransformStartEvent {\n    const originalDatas = getBeforeRenderableDatas(e);\n    return {\n        setTransform: (transform: string | string[], index = -1) => {\n            originalDatas.startTransforms = isArray(transform) ? transform : splitSpace(transform);\n            setTransformIndex(e, index);\n        },\n        setTransformIndex: (index: number) => {\n            setTransformIndex(e, index);\n        },\n    };\n}\nexport function setDefaultTransformIndex(e: any, property: string) {\n    const originalDatas = getBeforeRenderableDatas(e);\n    const startTransforms = originalDatas.startTransforms;\n\n    setTransformIndex(e, findIndex<string>(startTransforms, func => func.indexOf(`${property}(`) === 0));\n}\nexport function setTransformIndex(e: any, index: number) {\n    const originalDatas = getBeforeRenderableDatas(e);\n    const datas = e.datas;\n\n    datas.transformIndex = index;\n    if (index === -1) {\n        return;\n    }\n    const transform = originalDatas.startTransforms[index];\n\n    if (!transform) {\n        return;\n    }\n    const info = parse([transform]);\n\n    datas.startValue = info[0].functionValue;\n}\nexport function fillOriginalTransform(\n    e: any,\n    transform: string,\n) {\n    const originalDatas = getBeforeRenderableDatas(e);\n\n    originalDatas.nextTransforms = splitSpace(transform);\n    // originalDatas.nextTargetMatrix = parseMat(transform);\n}\nexport function getBeforeRenderableDatas(e: any) {\n    return e.originalDatas.beforeRenderable;\n}\nexport function getNextTransforms(e: any) {\n    const {\n        originalDatas: {\n            beforeRenderable: originalDatas,\n        },\n    } = e;\n\n    return originalDatas.nextTransforms;\n}\nexport function getNextTransformText(e: any) {\n    return getNextTransforms(e).join(\" \");\n}\n\nexport function getNextStyle(e: any) {\n    return getBeforeRenderableDatas(e).nextStyle;\n}\n\nexport function fillTransformEvent(\n    moveable: MoveableManagerInterface<DraggableProps>,\n    nextTransform: string,\n    delta: number[],\n    isPinch: boolean,\n    e: any,\n): OnTransformEvent {\n    fillOriginalTransform(e, nextTransform);\n\n    const drag = Draggable.drag!(\n        moveable,\n        setCustomDrag(e, moveable.state, delta, isPinch, false),\n    ) as OnDrag;\n    const afterTransform = drag ? drag.transform : nextTransform;\n    return {\n        transform: nextTransform,\n        drag: drag as OnDrag,\n        ...fillCSSObject({\n            transform: afterTransform,\n        }, e),\n        afterTransform,\n    };\n}\nexport function getTranslateDist(\n    moveable: MoveableManagerInterface<any>,\n    transform: string,\n    fixedDirection: number[],\n    fixedPosition: number[],\n    datas: any,\n) {\n    const state = moveable.state;\n    const {\n        left,\n        top,\n    } = state;\n\n    const groupable = moveable.props.groupable;\n    const nextMatrix = getNextTransformMatrix(moveable.state, datas, transform);\n    const groupLeft = groupable ? left : 0;\n    const groupTop = groupable ? top : 0;\n    const nextFixedPosition = getDirectionOffset(moveable, fixedDirection, nextMatrix);\n    const dist = minus(fixedPosition, nextFixedPosition);\n    return minus(dist, [groupLeft, groupTop]);\n}\nexport function getScaleDist(\n    moveable: MoveableManagerInterface<any>,\n    scaleDist: number[],\n    fixedDirection: number[],\n    fixedPosition: number[],\n    datas: any,\n) {\n    const dist = getTranslateDist(\n        moveable,\n        `scale(${scaleDist.join(\", \")})`,\n        fixedDirection,\n        fixedPosition,\n        datas,\n    );\n\n    return dist;\n}\nexport function getOriginDirection(moveable: MoveableManagerInterface<any>) {\n    const {\n        width,\n        height,\n        transformOrigin,\n    } = moveable.state;\n    return [\n        -1 + transformOrigin[0] / (width / 2),\n        -1 + transformOrigin[1] / (height / 2),\n    ];\n}\nexport function getDirectionOffset(\n    moveable: MoveableManagerInterface, direction: number[],\n    nextMatrix: number[] = moveable.state.allMatrix,\n) {\n    const {\n        width,\n        height,\n        is3d,\n    } = moveable.state;\n    const n = is3d ? 4 : 3;\n    const nextFixedOffset = [\n        width / 2 * (1 + direction[0]),\n        height / 2 * (1 + direction[1]),\n    ];\n    return calculatePosition(nextMatrix, nextFixedOffset, n);\n}\nexport function getRotateDist(\n    moveable: MoveableManagerInterface<any>,\n    rotateDist: number,\n    datas: any,\n) {\n    const fixedDirection = datas.fixedDirection;\n    const fixedPosition = datas.fixedPosition;\n\n    return getTranslateDist(\n        moveable,\n        `rotate(${rotateDist}deg)`,\n        fixedDirection,\n        fixedPosition,\n        datas,\n    );\n}\nexport function getResizeDist(\n    moveable: MoveableManagerInterface<any>,\n    width: number,\n    height: number,\n    fixedPosition: number[],\n    transformOrigin: string[],\n    datas: any,\n) {\n    const {\n        groupable,\n    } = moveable.props;\n    const state = moveable.state;\n    const {\n        transformOrigin: prevOrigin,\n        offsetMatrix,\n        is3d,\n        width: prevWidth,\n        height: prevHeight,\n        left,\n        top,\n    } = state;\n    const fixedDirection = datas.fixedDirection;\n    const targetMatrix = datas.nextTargetMatrix || state.targetMatrix;\n    const n = is3d ? 4 : 3;\n    const nextOrigin = calculateTransformOrigin(\n        transformOrigin!,\n        width,\n        height,\n        prevWidth,\n        prevHeight,\n        prevOrigin,\n    );\n    const groupLeft = groupable ? left : 0;\n    const groupTop = groupable ? top : 0;\n    const nextMatrix = getNextMatrix(offsetMatrix, targetMatrix, nextOrigin, n);\n    const dist = getDist(fixedPosition, nextMatrix, width, height, n, fixedDirection);\n\n    return minus(dist, [groupLeft, groupTop]);\n}\nexport function getAbsolutePosition(\n    moveable: MoveableManagerInterface<ResizableProps>,\n    direction: number[],\n) {\n    return getPosByDirection(getAbsolutePosesByState(moveable.state), direction);\n}\n","import { PREFIX, IS_WEBKIT605, TINY_NUM, IS_WEBKIT, IS_SAFARI_ABOVE15 } from \"./consts\";\nimport { prefixNames, InvertObject } from \"framework-utils\";\nimport {\n    isUndefined, isObject, splitUnit,\n    IObject, hasClass, isArray, isString, getRad,\n    getShapeDirection, isFunction, convertUnitSize, between, getKeys,\n} from \"@daybrush/utils\";\nimport {\n    multiply, invert,\n    convertDimension, createIdentityMatrix,\n    createOriginMatrix, convertPositionMatrix, calculate,\n    multiplies,\n    minus,\n    createScaleMatrix,\n    plus,\n    convertCSStoMatrix,\n    convertMatrixtoCSS,\n} from \"@scena/matrix\";\nimport {\n    MoveableManagerState, Able, MoveableClientRect,\n    MoveableProps, ArrayFormat, MoveableRefType,\n    MatrixInfo, ExcludeEndParams, ExcludeParams,\n    ElementSizes, MoveablePosition, TransformObject,\n} from \"./types\";\nimport { parse, toMat, calculateMatrixDist, parseMat } from \"css-to-mat\";\nimport { getBeforeRenderableDatas, getDragDist } from \"./gesto/GestoUtils\";\n\nexport function round(num: number) {\n    return Math.round(num);\n}\nexport function multiply2(pos1: number[], pos2: number[]) {\n    return [\n        pos1[0] * pos2[0],\n        pos1[1] * pos2[1],\n    ];\n}\nexport function prefix(...classNames: string[]) {\n    return prefixNames(PREFIX, ...classNames);\n}\n\nexport function defaultSync(fn: () => void) {\n    fn();\n}\n\nexport function createIdentityMatrix3() {\n    return createIdentityMatrix(3);\n}\n\nexport function getTransformMatrix(transform: string | number[]) {\n    if (!transform || transform === \"none\") {\n        return [1, 0, 0, 1, 0, 0];\n\n    }\n    if (isObject(transform)) {\n        return transform;\n    }\n    return parseMat(transform);\n}\nexport function getAbsoluteMatrix(matrix: number[], n: number, origin: number[]) {\n    return multiplies(\n        n,\n        createOriginMatrix(origin, n),\n        matrix,\n        createOriginMatrix(origin.map(a => -a), n),\n    );\n}\nexport function measureSVGSize(el: SVGElement, unit: string, isHorizontal: boolean) {\n    if (unit === \"%\") {\n        const viewBox = getSVGViewBox(el.ownerSVGElement!);\n\n        return viewBox[isHorizontal ? \"width\" : \"height\"] / 100;\n    }\n    return 1;\n}\nexport function getBeforeTransformOrigin(el: SVGElement) {\n    const relativeOrigin = getTransformOrigin(getComputedStyle(el, \":before\"));\n\n    return relativeOrigin.map((o, i) => {\n        const { value, unit } = splitUnit(o);\n\n        return value * measureSVGSize(el, unit, i === 0);\n    });\n}\nexport function getTransformOrigin(style: CSSStyleDeclaration) {\n    const transformOrigin = style.transformOrigin;\n\n    return transformOrigin ? transformOrigin.split(\" \") : [\"0\", \"0\"];\n}\nexport function getElementTransform(\n    target: HTMLElement | SVGElement,\n    computedStyle = getComputedStyle(target),\n) {\n    const computedTransform = computedStyle.transform;\n\n    if (computedTransform && computedTransform !== \"none\") {\n        return computedStyle.transform;\n    }\n    if (\"transform\" in target) {\n        const list = (target as any).transform as SVGAnimatedTransformList;\n        const baseVal = list.baseVal;\n\n        if (!baseVal) {\n            return \"\";\n        }\n        const length = baseVal.length;\n\n        if (!length) {\n            return \"\";\n        }\n\n        const matrixes: string[] = [];\n\n        for (let i = 0; i < length; ++i) {\n            const matrix = baseVal[i].matrix;\n\n            matrixes.push(`matrix(${([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"] as const).map(chr => matrix[chr]).join(\", \")})`);\n        }\n        return matrixes.join(\" \");\n\n    }\n    return \"\";\n}\nexport function getOffsetInfo(\n    el: SVGElement | HTMLElement | null | undefined,\n    lastParent: SVGElement | HTMLElement | null | undefined,\n    isParent?: boolean,\n) {\n    const body = document.body;\n    let target = !el || isParent\n        ? el\n        : el?.assignedSlot?.parentElement || el.parentElement;\n\n    let isCustomElement = false;\n    let isEnd = el === lastParent || target === lastParent;\n    let position = \"relative\";\n\n\n\n    while (target && target !== body) {\n        if (lastParent === target) {\n            isEnd = true;\n        }\n        const style = getComputedStyle(target);\n        const tagName = target.tagName.toLowerCase();\n        const transform = getElementTransform(target as SVGElement, style);\n        const willChange = style.willChange;\n        position = style.position!;\n\n        if (\n            tagName === \"svg\"\n            || position !== \"static\"\n            || (transform && transform !== \"none\")\n            || willChange === \"transform\"\n        ) {\n            break;\n        }\n        const parentNode = target.parentNode;\n\n        if (parentNode && parentNode.nodeType === 11) {\n            // Shadow Root\n            target = (parentNode as ShadowRoot).host as HTMLElement;\n            isCustomElement = true;\n            break;\n        }\n        \n        target = parentNode as HTMLElement | SVGElement;\n        position = \"relative\";\n    }\n    return {\n        isCustomElement,\n        isStatic: position === \"static\",\n        isEnd: isEnd || !target || target === body,\n        offsetParent: target as HTMLElement || body,\n    };\n\n}\nexport function getOffsetPosInfo(\n    el: HTMLElement | SVGElement,\n    style: CSSStyleDeclaration,\n) {\n    const tagName = el.tagName.toLowerCase();\n    let offsetLeft = (el as HTMLElement).offsetLeft;\n    let offsetTop = (el as HTMLElement).offsetTop;\n\n    // svg\n    const isSVG = isUndefined(offsetLeft);\n    let hasOffset = !isSVG;\n    let origin: number[];\n    let targetOrigin: number[];\n    // inner svg element\n    if (!hasOffset && tagName !== \"svg\") {\n        origin = IS_WEBKIT605\n            ? getBeforeTransformOrigin(el as SVGElement)\n            : getTransformOrigin(style).map(pos => parseFloat(pos));\n\n        targetOrigin = origin.slice();\n        hasOffset = true;\n\n        [\n            offsetLeft, offsetTop, origin[0], origin[1],\n        ] = getSVGGraphicsOffset(el as SVGGraphicsElement, origin);\n    } else {\n        origin = getTransformOrigin(style).map(pos => parseFloat(pos));\n        targetOrigin = origin.slice();\n    }\n    return {\n        tagName,\n        isSVG,\n        hasOffset,\n        offset: [offsetLeft || 0, offsetTop || 0],\n        origin,\n        targetOrigin,\n    };\n}\nexport function getBodyOffset(\n    el: HTMLElement | SVGElement,\n    isSVG: boolean,\n    style: CSSStyleDeclaration = getComputedStyle(el),\n) {\n    const bodyStyle = getComputedStyle(document.body);\n    const bodyPosition = bodyStyle.position;\n    if (!isSVG && (!bodyPosition || bodyPosition === \"static\")) {\n        return [0, 0];\n    }\n\n    let marginLeft = parseInt(bodyStyle.marginLeft, 10);\n    let marginTop = parseInt(bodyStyle.marginTop, 10);\n\n    if (style.position === \"absolute\") {\n        if (style.top !== \"auto\" || style.bottom !== \"auto\") {\n            marginTop = 0;\n        }\n        if (style.left !== \"auto\" || style.right !== \"auto\") {\n            marginLeft = 0;\n        }\n    }\n\n    return [marginLeft, marginTop];\n}\nexport function convert3DMatrixes(matrixes: MatrixInfo[]) {\n    matrixes.forEach(info => {\n        const matrix = info.matrix;\n\n        if (matrix) {\n            info.matrix = convertDimension(matrix, 3, 4);\n        }\n    });\n}\n\nexport function getBodyScrollPos() {\n    return [\n        document.documentElement.scrollLeft || document.body.scrollLeft,\n        document.documentElement.scrollTop || document.body.scrollTop,\n    ];\n}\n\nexport function getPositionFixedInfo(el: HTMLElement | SVGElement) {\n    let fixedContainer = el.parentElement;\n    let hasTransform = false;\n\n    while (fixedContainer) {\n        const transform = getComputedStyle(fixedContainer).transform;\n\n\n        if (transform && transform !== \"none\") {\n            hasTransform = true;\n            break;\n        }\n        if (fixedContainer === document.body) {\n            break;\n        }\n        fixedContainer = fixedContainer.parentElement;\n    }\n\n    return {\n        fixedContainer: fixedContainer || document.body,\n        hasTransform,\n    };\n}\n\nexport function getMatrixStackInfo(\n    target: SVGElement | HTMLElement,\n    container?: SVGElement | HTMLElement | null,\n    checkContainer?: boolean,\n) {\n    let el: SVGElement | HTMLElement | null = target;\n    const matrixes: MatrixInfo[] = [];\n    let requestEnd = !checkContainer && target === container || target === document.body;\n    let isEnd = requestEnd;\n    let is3d = false;\n    let n = 3;\n    let transformOrigin!: number[];\n    let targetTransformOrigin!: number[];\n    let targetMatrix!: number[];\n\n    let hasFixed = false;\n    let offsetContainer = getOffsetInfo(container, container, true).offsetParent;\n\n    while (el && !isEnd) {\n        isEnd = requestEnd;\n        const style: CSSStyleDeclaration = getComputedStyle(el);\n        const position = style.position;\n        const transform = getElementTransform(el, style);\n        let matrix: number[] = convertCSStoMatrix(getTransformMatrix(transform));\n        const isFixed = position === \"fixed\";\n        let fixedInfo: {\n            hasTransform: boolean;\n            fixedContainer: HTMLElement | null;\n        } = {\n            hasTransform: false,\n            fixedContainer: null,\n        };\n        if (isFixed) {\n            hasFixed = true;\n            fixedInfo = getPositionFixedInfo(el);\n\n            offsetContainer = fixedInfo.fixedContainer!;\n        }\n\n        // convert 3 to 4\n        const length = matrix.length;\n\n        if (!is3d && length === 16) {\n            is3d = true;\n            n = 4;\n\n            convert3DMatrixes(matrixes);\n            if (targetMatrix) {\n                targetMatrix = convertDimension(targetMatrix, 3, 4);\n            }\n        }\n        if (is3d && length === 9) {\n            matrix = convertDimension(matrix, 3, 4);\n        }\n        const {\n            tagName,\n            hasOffset,\n            isSVG,\n            origin,\n            targetOrigin,\n            offset: offsetPos,\n        } = getOffsetPosInfo(el, style);\n        let [\n            offsetLeft,\n            offsetTop,\n        ] = offsetPos;\n        if (tagName === \"svg\" && targetMatrix) {\n            // scale matrix for svg's SVGElements.\n            matrixes.push({\n                type: \"target\",\n                target: el,\n                matrix: getSVGMatrix(el as SVGSVGElement, n),\n            });\n            matrixes.push({\n                type: \"offset\",\n                target: el,\n                matrix: createIdentityMatrix(n),\n            });\n        } else if (tagName === \"g\" && target !== el) {\n            offsetLeft = 0;\n            offsetTop = 0;\n        }\n\n        let offsetParent: HTMLElement;\n        let isOffsetEnd = false;\n        let isStatic = false;\n\n        if (isFixed) {\n            offsetParent = fixedInfo.fixedContainer!;\n            isOffsetEnd = true;\n        } else {\n            const offsetInfo = getOffsetInfo(el, container);\n\n            offsetParent = offsetInfo.offsetParent;\n            isOffsetEnd = offsetInfo.isEnd;\n            isStatic = offsetInfo.isStatic;\n        }\n\n        if (\n            IS_WEBKIT && !IS_SAFARI_ABOVE15\n            && hasOffset && !isSVG && isStatic\n            && (position === \"relative\" || position === \"static\")\n        ) {\n            offsetLeft -= offsetParent.offsetLeft;\n            offsetTop -= offsetParent.offsetTop;\n            requestEnd = requestEnd || isOffsetEnd;\n        }\n        let parentClientLeft = 0;\n        let parentClientTop = 0;\n        let fixedClientLeft = 0;\n        let fixedClientTop = 0;\n\n        if (isFixed) {\n            if (hasOffset && fixedInfo.hasTransform) {\n                // border\n                fixedClientLeft = offsetParent.clientLeft;\n                fixedClientTop = offsetParent.clientTop;\n            }\n        } else {\n            if (hasOffset && offsetContainer !== offsetParent) {\n                // border\n                parentClientLeft = offsetParent.clientLeft;\n                parentClientTop = offsetParent.clientTop;\n            }\n            if (hasOffset && offsetParent === document.body) {\n                const margin = getBodyOffset(el, false, style);\n\n                offsetLeft += margin[0];\n                offsetTop += margin[1];\n            }\n        }\n\n        matrixes.push({\n            type: \"target\",\n            target: el,\n            matrix: getAbsoluteMatrix(matrix, n, origin),\n        });\n        if (hasOffset) {\n            matrixes.push({\n                type: \"offset\",\n                target: el,\n                matrix: createOriginMatrix([\n                    offsetLeft - el.scrollLeft + parentClientLeft - fixedClientLeft,\n                    offsetTop - el.scrollTop + parentClientTop - fixedClientTop,\n                ], n),\n            });\n        } else {\n            // svg\n            matrixes.push({\n                type: \"offset\",\n                target: el,\n                origin,\n            });\n        }\n        if (!targetMatrix) {\n            targetMatrix = matrix;\n        }\n        if (!transformOrigin) {\n            transformOrigin = origin;\n        }\n        if (!targetTransformOrigin) {\n            targetTransformOrigin = targetOrigin;\n        }\n\n        if (isEnd || isFixed) {\n            break;\n        } else {\n            el = offsetParent;\n            requestEnd = isOffsetEnd;\n        }\n        if (!checkContainer || el === document.body) {\n            isEnd = requestEnd;\n        }\n    }\n    if (!targetMatrix) {\n        targetMatrix = createIdentityMatrix(n);\n    }\n    if (!transformOrigin) {\n        transformOrigin = [0, 0];\n    }\n    if (!targetTransformOrigin) {\n        targetTransformOrigin = [0, 0];\n    }\n\n    return {\n        offsetContainer,\n        matrixes,\n        targetMatrix,\n        transformOrigin,\n        targetOrigin: targetTransformOrigin,\n        is3d,\n        hasFixed,\n    };\n}\n\nexport function makeMatrixCSS(matrix: number[], is3d: boolean = matrix.length > 9) {\n    return `${is3d ? \"matrix3d\" : \"matrix\"}(${convertMatrixtoCSS(matrix, !is3d).join(\",\")})`;\n}\nexport function getSVGViewBox(el: SVGSVGElement) {\n    const clientWidth = el.clientWidth;\n    const clientHeight = el.clientHeight;\n\n    if (!el) {\n        return { x: 0, y: 0, width: 0, height: 0, clientWidth, clientHeight };\n    }\n    const viewBox = el.viewBox;\n    const baseVal = (viewBox && viewBox.baseVal) || { x: 0, y: 0, width: 0, height: 0 };\n\n    return {\n        x: baseVal.x,\n        y: baseVal.y,\n        width: baseVal.width || clientWidth,\n        height: baseVal.height || clientHeight,\n        clientWidth,\n        clientHeight,\n    };\n}\nexport function getSVGMatrix(\n    el: SVGSVGElement,\n    n: number,\n) {\n    const {\n        width: viewBoxWidth,\n        height: viewBoxHeight,\n        clientWidth,\n        clientHeight,\n    } = getSVGViewBox(el);\n    const scaleX = clientWidth / viewBoxWidth;\n    const scaleY = clientHeight / viewBoxHeight;\n\n    const preserveAspectRatio = el.preserveAspectRatio.baseVal;\n    // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/preserveAspectRatio\n    const align = preserveAspectRatio.align;\n    // 1 : meet 2: slice\n    const meetOrSlice = preserveAspectRatio.meetOrSlice;\n    const svgOrigin = [0, 0];\n    const scale = [scaleX, scaleY];\n    const translate = [0, 0];\n\n    if (align !== 1) {\n        const xAlign = (align - 2) % 3;\n        const yAlign = Math.floor((align - 2) / 3);\n\n        svgOrigin[0] = viewBoxWidth * xAlign / 2;\n        svgOrigin[1] = viewBoxHeight * yAlign / 2;\n\n        const scaleDimension = meetOrSlice === 2 ? Math.max(scaleY, scaleX) : Math.min(scaleX, scaleY);\n\n        scale[0] = scaleDimension;\n        scale[1] = scaleDimension;\n\n        translate[0] = (clientWidth - viewBoxWidth) / 2 * xAlign;\n        translate[1] = (clientHeight - viewBoxHeight) / 2 * yAlign;\n    }\n    const scaleMatrix = createScaleMatrix(scale, n);\n    [\n        scaleMatrix[n * (n - 1)],\n        scaleMatrix[n * (n - 1) + 1],\n    ] = translate;\n\n    return getAbsoluteMatrix(\n        scaleMatrix,\n        n,\n        svgOrigin,\n    );\n}\nexport function getSVGGraphicsOffset(\n    el: SVGGraphicsElement,\n    origin: number[],\n) {\n    if (!el.getBBox || el.tagName.toLowerCase() === \"g\") {\n        return [0, 0, 0, 0];\n    }\n    const bbox = el.getBBox();\n    const viewBox = getSVGViewBox(el.ownerSVGElement!);\n    const left = bbox.x - viewBox.x;\n    const top = bbox.y - viewBox.y;\n\n    return [\n        left,\n        top,\n        origin[0] - left,\n        origin[1] - top,\n    ];\n}\nexport function calculatePosition(matrix: number[], pos: number[], n: number) {\n    return calculate(matrix, convertPositionMatrix(pos, n), n);\n}\nexport function calculatePoses(matrix: number[], width: number, height: number, n: number) {\n    return [[0, 0], [width, 0], [0, height], [width, height]].map(pos => calculatePosition(matrix, pos, n));\n}\nexport function getRect(poses: number[][]) {\n    const posesX = poses.map(pos => pos[0]);\n    const posesY = poses.map(pos => pos[1]);\n    const left = Math.min(...posesX);\n    const top = Math.min(...posesY);\n    const right = Math.max(...posesX);\n    const bottom = Math.max(...posesY);\n    const rectWidth = right - left;\n    const rectHeight = bottom - top;\n\n    return {\n        left, top,\n        right, bottom,\n        width: rectWidth,\n        height: rectHeight,\n    };\n}\nexport function calculateRect(matrix: number[], width: number, height: number, n: number) {\n    const poses = calculatePoses(matrix, width, height, n);\n\n    return getRect(poses);\n}\nexport function getSVGOffset(\n    offsetInfo: MatrixInfo,\n    targetInfo: MatrixInfo,\n    container: HTMLElement | SVGElement,\n    n: number,\n    beforeMatrix: number[],\n) {\n    const target = offsetInfo.target;\n    const origin = offsetInfo.origin!;\n    const targetMatrix = targetInfo.matrix!;\n    const {\n        offsetWidth: width,\n        offsetHeight: height,\n    } = getSize(target);\n    const containerClientRect = container.getBoundingClientRect();\n    let margin = [0, 0];\n\n    if (container === document.body) {\n        margin = getBodyOffset(target, true);\n    }\n\n    const rect = target.getBoundingClientRect();\n    const rectLeft\n        = rect.left - containerClientRect.left + container.scrollLeft\n        - (container.clientLeft || 0) + margin[0];\n    const rectTop\n        = rect.top - containerClientRect.top + container.scrollTop\n        - (container.clientTop || 0) + margin[1];\n    const rectWidth = rect.width;\n    const rectHeight = rect.height;\n\n    const mat = multiplies(\n        n,\n        beforeMatrix,\n        targetMatrix,\n    );\n    const {\n        left: prevLeft,\n        top: prevTop,\n        width: prevWidth,\n        height: prevHeight,\n    } = calculateRect(mat, width, height, n);\n    const posOrigin = calculatePosition(mat, origin, n);\n    const prevOrigin = minus(posOrigin, [prevLeft, prevTop]);\n    const rectOrigin = [\n        rectLeft + prevOrigin[0] * rectWidth / prevWidth,\n        rectTop + prevOrigin[1] * rectHeight / prevHeight,\n    ];\n    const offset = [0, 0];\n    let count = 0;\n\n    while (++count < 10) {\n        const inverseBeforeMatrix = invert(beforeMatrix, n);\n        [offset[0], offset[1]] = minus(\n            calculatePosition(inverseBeforeMatrix, rectOrigin, n),\n            calculatePosition(inverseBeforeMatrix, posOrigin, n),\n        );\n        const mat2 = multiplies(\n            n,\n            beforeMatrix,\n            createOriginMatrix(offset, n),\n            targetMatrix,\n        );\n        const {\n            left: nextLeft,\n            top: nextTop,\n        } = calculateRect(mat2, width, height, n);\n        const distLeft = nextLeft - rectLeft;\n        const distTop = nextTop - rectTop;\n\n        if (Math.abs(distLeft) < 2 && Math.abs(distTop) < 2) {\n            break;\n        }\n        rectOrigin[0] -= distLeft;\n        rectOrigin[1] -= distTop;\n    }\n    return offset.map(p => Math.round(p));\n}\n\nexport function calculateMoveableClientPositions(\n    rootMatrix: number[],\n    poses: number[][],\n    rootClientRect: MoveableClientRect,\n) {\n    const is3d = rootMatrix.length === 16;\n    const n = is3d ? 4 : 3;\n    const rootPoses = poses.map(pos => calculatePosition(rootMatrix, pos, n));\n    const { left, top } = rootClientRect;\n\n    return rootPoses.map(pos => {\n        return [pos[0] + left, pos[1] + top];\n    });\n\n}\nexport function calculateMoveablePosition(\n    matrix: number[],\n    origin: number[],\n    width: number,\n    height: number,\n): MoveablePosition {\n    const is3d = matrix.length === 16;\n    const n = is3d ? 4 : 3;\n    const poses = calculatePoses(matrix, width, height, n);\n    let [\n        [x1, y1],\n        [x2, y2],\n        [x3, y3],\n        [x4, y4],\n    ] = poses;\n    let [originX, originY] = calculatePosition(matrix, origin, n);\n\n    const left = Math.min(x1, x2, x3, x4);\n    const top = Math.min(y1, y2, y3, y4);\n    const right = Math.max(x1, x2, x3, x4);\n    const bottom = Math.max(y1, y2, y3, y4);\n\n    x1 = (x1 - left) || 0;\n    x2 = (x2 - left) || 0;\n    x3 = (x3 - left) || 0;\n    x4 = (x4 - left) || 0;\n\n    y1 = (y1 - top) || 0;\n    y2 = (y2 - top) || 0;\n    y3 = (y3 - top) || 0;\n    y4 = (y4 - top) || 0;\n\n    originX = (originX - left) || 0;\n    originY = (originY - top) || 0;\n\n    const direction = getShapeDirection(poses);\n\n    return {\n        left,\n        top,\n        right,\n        bottom,\n        origin: [originX, originY],\n        pos1: [x1, y1],\n        pos2: [x2, y2],\n        pos3: [x3, y3],\n        pos4: [x4, y4],\n        direction,\n    };\n}\nexport function getDistSize(vec: number[]) {\n    return Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1]);\n}\nexport function getDiagonalSize(pos1: number[], pos2: number[]) {\n    return getDistSize([\n        pos2[0] - pos1[0],\n        pos2[1] - pos1[1],\n    ]);\n}\nexport function getLineStyle(pos1: number[], pos2: number[], zoom = 1, rad: number = getRad(pos1, pos2)) {\n    const width = getDiagonalSize(pos1, pos2);\n\n    return {\n        transform: `translateY(-50%) translate(${pos1[0]}px, ${pos1[1]}px) rotate(${rad}rad) scaleY(${zoom})`,\n        width: `${width}px`,\n    };\n}\nexport function getControlTransform(rotation: number, zoom: number, ...poses: number[][]) {\n    const length = poses.length;\n\n    const x = poses.reduce((prev, pos) => prev + pos[0], 0) / length;\n    const y = poses.reduce((prev, pos) => prev + pos[1], 0) / length;\n    return {\n        transform: `translateZ(0px) translate(${x}px, ${y}px) rotate(${rotation}rad) scale(${zoom})`,\n    };\n}\nexport function getCSSSize(target: SVGElement | HTMLElement) {\n    const style = getComputedStyle(target);\n\n    return [\n        parseFloat(style.width!),\n        parseFloat(style.height!),\n    ];\n}\n\nexport function getProps<Props>(props: Props, ableName: keyof Props): Props {\n    const self = props[ableName];\n\n    if (isObject(self)) {\n        return {\n            ...props,\n            ...self,\n        };\n    }\n    return props;\n}\n\nexport function getSize(\n    target?: SVGElement | HTMLElement | null,\n    style: CSSStyleDeclaration | null = target ? getComputedStyle(target) : null,\n): ElementSizes {\n    const hasOffset = target && !isUndefined((target as any).offsetWidth);\n\n    let offsetWidth = 0;\n    let offsetHeight = 0;\n    let clientWidth = 0;\n    let clientHeight = 0;\n    let cssWidth = 0;\n    let cssHeight = 0;\n    let contentWidth = 0;\n    let contentHeight = 0;\n\n    let minWidth = 0;\n    let minHeight = 0;\n    let minOffsetWidth = 0;\n    let minOffsetHeight = 0;\n\n    let maxWidth = Infinity;\n    let maxHeight = Infinity;\n    let maxOffsetWidth = Infinity;\n    let maxOffsetHeight = Infinity;\n    let svg = false;\n\n    if (target) {\n        if (!hasOffset && target!.tagName.toLowerCase() !== \"svg\") {\n            const bbox = (target as SVGGraphicsElement).getBBox();\n\n            svg = true;\n            offsetWidth = bbox.width;\n            offsetHeight = bbox.height;\n            cssWidth = offsetWidth;\n            cssHeight = offsetHeight;\n            contentWidth = offsetWidth;\n            contentHeight = offsetHeight;\n            clientWidth = offsetWidth;\n            clientHeight = offsetHeight;\n        } else {\n            const targetStyle = target.style;\n            const boxSizing = style!.boxSizing === \"border-box\";\n            const borderLeft = parseFloat(style!.borderLeftWidth!) || 0;\n            const borderRight = parseFloat(style!.borderRightWidth!) || 0;\n            const borderTop = parseFloat(style!.borderTopWidth!) || 0;\n            const borderBottom = parseFloat(style!.borderBottomWidth!) || 0;\n            const paddingLeft = parseFloat(style!.paddingLeft!) || 0;\n            const paddingRight = parseFloat(style!.paddingRight!) || 0;\n            const paddingTop = parseFloat(style!.paddingTop!) || 0;\n            const paddingBottom = parseFloat(style!.paddingBottom!) || 0;\n\n            const horizontalPadding = paddingLeft + paddingRight;\n            const verticalPadding = paddingTop + paddingBottom;\n            const horizontalBorder = borderLeft + borderRight;\n            const verticalBorder = borderTop + borderBottom;\n            const horizontalOffset = horizontalPadding + horizontalBorder;\n            const verticalOffset = verticalPadding + verticalBorder;\n\n            minWidth = Math.max(horizontalPadding, convertUnitSize(style!.minWidth, 0) || 0);\n            minHeight = Math.max(verticalPadding, convertUnitSize(style!.minHeight, 0) || 0);\n            maxWidth = convertUnitSize(style!.maxWidth, 0);\n            maxHeight = convertUnitSize(style!.maxHeight, 0);\n\n            if (isNaN(maxWidth)) {\n                maxWidth = Infinity;\n                maxHeight = Infinity;\n            }\n            const inlineCSSWidth = convertUnitSize(targetStyle.width, 0) || 0;\n            const inlineCSSHeight = convertUnitSize(targetStyle.height, 0) || 0;\n            const computedWidth = parseFloat(style!.width) || 0;\n            const computedHeight = parseFloat(style!.height) || 0;\n\n            cssWidth = parseFloat(style!.width);\n            cssHeight = parseFloat(style!.height);\n\n            contentWidth = Math.abs(computedWidth - inlineCSSWidth) < 1\n                ? between(minWidth, inlineCSSWidth || cssWidth, maxWidth)\n                : computedWidth;\n            contentHeight = Math.abs(computedHeight - inlineCSSHeight) < 1\n                ? between(minHeight, inlineCSSHeight || cssHeight, maxHeight)\n                : computedHeight;\n\n            offsetWidth = contentWidth;\n            offsetHeight = contentHeight;\n            clientWidth = contentWidth;\n            clientHeight = contentHeight;\n\n            if (boxSizing) {\n                maxOffsetWidth = maxWidth;\n                maxOffsetHeight = maxHeight;\n                minOffsetWidth = minWidth;\n                minOffsetHeight = minHeight;\n                contentWidth = offsetWidth - horizontalOffset;\n                contentHeight = offsetHeight - verticalOffset;\n            } else {\n                maxOffsetWidth = maxWidth + horizontalOffset;\n                maxOffsetHeight = maxHeight + verticalOffset;\n                minOffsetWidth = minWidth + horizontalOffset;\n                minOffsetHeight = minHeight + verticalOffset;\n                offsetWidth = contentWidth + horizontalOffset;\n                offsetHeight = contentHeight + verticalOffset;\n            }\n            clientWidth = contentWidth + horizontalPadding;\n            clientHeight = contentHeight + verticalPadding;\n        }\n    }\n\n    return {\n        svg,\n        offsetWidth,\n        offsetHeight,\n        clientWidth,\n        clientHeight,\n        contentWidth,\n        contentHeight,\n        cssWidth,\n        cssHeight,\n        minWidth,\n        minHeight,\n        maxWidth,\n        maxHeight,\n        minOffsetWidth,\n        minOffsetHeight,\n        maxOffsetWidth,\n        maxOffsetHeight,\n    };\n}\nexport function getRotationRad(\n    poses: number[][],\n    direction: number,\n) {\n    return getRad(direction > 0 ? poses[0] : poses[1], direction > 0 ? poses[1] : poses[0]);\n}\n\nexport function resetClientRect(): MoveableClientRect {\n    return {\n        left: 0, top: 0,\n        width: 0, height: 0,\n        right: 0,\n        bottom: 0,\n        clientLeft: 0, clientTop: 0,\n        clientWidth: 0, clientHeight: 0,\n        scrollWidth: 0, scrollHeight: 0,\n    };\n}\nexport function getClientRect(el: HTMLElement | SVGElement, isExtends?: boolean) {\n    let left = 0;\n    let top = 0;\n    let width = 0;\n    let height = 0;\n\n    if (el) {\n        if (el === document.body || el === document.documentElement) {\n            width = window.innerWidth;\n            height = window.innerHeight;\n            const scrollPos = getBodyScrollPos();\n\n            [left, top] = [-scrollPos[0], -scrollPos[1]];\n        } else {\n            const clientRect = el.getBoundingClientRect();\n\n            left = clientRect.left;\n            top = clientRect.top;\n            width = clientRect.width;\n            height = clientRect.height;\n        }\n    }\n\n    const rect: MoveableClientRect = {\n        left,\n        top,\n        width,\n        height,\n        right: left + width,\n        bottom: top + height,\n    };\n\n    if (el && isExtends) {\n        rect.clientLeft = el.clientLeft;\n        rect.clientTop = el.clientTop;\n        rect.clientWidth = el.clientWidth;\n        rect.clientHeight = el.clientHeight;\n        rect.scrollWidth = el.scrollWidth;\n        rect.scrollHeight = el.scrollHeight;\n        rect.overflow = getComputedStyle(el).overflow !== \"visible\";\n    }\n    return rect;\n}\nexport function getDirection(target: SVGElement | HTMLElement) {\n    if (!target) {\n        return;\n    }\n    const direciton = target.getAttribute(\"data-direction\")!;\n\n    if (!direciton) {\n        return;\n    }\n    const dir = [0, 0];\n\n    (direciton.indexOf(\"w\") > -1) && (dir[0] = -1);\n    (direciton.indexOf(\"e\") > -1) && (dir[0] = 1);\n    (direciton.indexOf(\"n\") > -1) && (dir[1] = -1);\n    (direciton.indexOf(\"s\") > -1) && (dir[1] = 1);\n\n    return dir;\n}\nexport function getAbsolutePoses(poses: number[][], dist: number[]) {\n    return [\n        plus(dist, poses[0]),\n        plus(dist, poses[1]),\n        plus(dist, poses[2]),\n        plus(dist, poses[3]),\n    ];\n}\nexport function getAbsolutePosesByState({\n    left,\n    top,\n    pos1,\n    pos2,\n    pos3,\n    pos4,\n}: {\n    left: number,\n    top: number,\n    pos1: number[],\n    pos2: number[],\n    pos3: number[],\n    pos4: number[],\n}) {\n    return getAbsolutePoses([pos1, pos2, pos3, pos4], [left, top]);\n}\n\nexport function roundSign(num: number) {\n    return Math.round(num % 1 === -0.5 ? num - 1 : num);\n}\n\nexport function unset(self: any, name: string) {\n    self[name]?.unset();\n    self[name] = null;\n}\n\nexport function fillCSSObject(style: Record<string, any>, resolvedEvent?: any) {\n    if (resolvedEvent) {\n        const originalDatas = getBeforeRenderableDatas(resolvedEvent);\n\n        originalDatas.nextStyle = {\n            ...originalDatas.nextStyle,\n            ...style,\n        };\n    }\n    return {\n        style,\n        cssText: getKeys(style).map(name => `${name}: ${style[name]};`).join(\"\"),\n    };\n}\n\nexport function fillAfterTransform(\n    prevEvent: { style: Record<string, string>, transform: string },\n    nextEvent: { style: Record<string, string>, transform: string, afterTransform?: string },\n    resolvedEvent?: any\n): TransformObject {\n    const afterTransform = nextEvent.afterTransform || nextEvent.transform;\n\n    return {\n        ...fillCSSObject({\n            ...prevEvent.style,\n            ...nextEvent.style,\n            transform: afterTransform,\n        }, resolvedEvent),\n        afterTransform,\n        transform: prevEvent.transform,\n    };\n}\n\nexport function fillParams<T extends IObject<any>>(\n    moveable: any,\n    e: any,\n    params: ExcludeParams<T>,\n    isBeforeEvent?: boolean,\n): T {\n    const datas = e.datas;\n\n    if (!datas.datas) {\n        datas.datas = {};\n    }\n    const nextParams = {\n        ...params,\n        target: moveable.state.target,\n        clientX: e.clientX,\n        clientY: e.clientY,\n        inputEvent: e.inputEvent,\n        currentTarget: moveable,\n        moveable,\n        datas: datas.datas,\n    } as any;\n\n    if (!datas.isStartEvent) {\n        datas.isStartEvent = true;\n    } else if (!isBeforeEvent) {\n        datas.lastEvent = nextParams;\n    }\n    return nextParams;\n}\nexport function fillEndParams<T extends IObject<any>>(\n    moveable: any,\n    e: any,\n    params: ExcludeEndParams<T> & { isDrag?: boolean },\n): T {\n    const datas = e.datas;\n    const isDrag = \"isDrag\" in params ? params.isDrag : e.isDrag;\n\n    if (!datas.datas) {\n        datas.datas = {};\n    }\n\n    return {\n        isDrag,\n        ...params,\n        moveable,\n        target: moveable.state.target,\n        clientX: e.clientX,\n        clientY: e.clientY,\n        inputEvent: e.inputEvent,\n        currentTarget: moveable,\n        lastEvent: datas.lastEvent,\n        isDouble: e.isDouble,\n        datas: datas.datas,\n    } as any;\n}\nexport function catchEvent<EventName extends keyof Props, Props extends IObject<any> = MoveableProps>(\n    moveable: any,\n    name: EventName,\n    callback: (e: Props[EventName] extends ((e: infer P) => any) | undefined ? P : IObject<any>) => void,\n): any {\n    moveable._emitter.on(name, callback);\n}\n\nexport function triggerEvent<EventName extends keyof Props, Props extends IObject<any> = MoveableProps>(\n    moveable: any,\n    name: EventName,\n    params: Props[EventName] extends ((e: infer P) => any) | undefined ? P : IObject<any>,\n    isManager?: boolean,\n): any {\n    return moveable.triggerEvent(name, params, isManager);\n}\n\nexport function getComputedStyle(el: Element, pseudoElt?: string | null) {\n    return window.getComputedStyle(el, pseudoElt);\n}\n\nexport function filterAbles(\n    ables: Able[], methods: Array<keyof Able>,\n    triggerAblesSimultaneously?: boolean,\n) {\n    const enabledAbles: IObject<boolean> = {};\n    const ableGroups: IObject<boolean> = {};\n\n    return ables.filter(able => {\n        const name = able.name;\n\n        if (enabledAbles[name] || !methods.some(method => able[method])) {\n            return false;\n        }\n        if (!triggerAblesSimultaneously && able.ableGroup) {\n            if (ableGroups[able.ableGroup]) {\n                return false;\n            }\n            ableGroups[able.ableGroup] = true;\n        }\n        enabledAbles[name] = true;\n        return true;\n    });\n}\n\nexport function equals(a1: any, a2: any) {\n    return a1 === a2 || (a1 == null && a2 == null);\n}\n\nexport function selectValue<T = any>(...values: any[]): T {\n    const length = values.length - 1;\n    for (let i = 0; i < length; ++i) {\n        const value = values[i];\n\n        if (!isUndefined(value)) {\n            return value;\n        }\n    }\n\n    return values[length];\n}\n\nexport function groupBy<T>(arr: T[], func: (el: T, index: number, arr: T[]) => any) {\n    const groups: T[][] = [];\n    const groupKeys: any[] = [];\n\n    arr.forEach((el, index) => {\n        const groupKey = func(el, index, arr);\n        const keyIndex = groupKeys.indexOf(groupKey);\n        const group = groups[keyIndex] || [];\n\n        if (keyIndex === -1) {\n            groupKeys.push(groupKey);\n            groups.push(group);\n        }\n        group.push(el);\n    });\n    return groups;\n}\nexport function groupByMap<T>(arr: T[], func: (el: T, index: number, arr: T[]) => string | number) {\n    const groups: T[][] = [];\n    const groupKeys: IObject<T[]> = {};\n\n    arr.forEach((el, index) => {\n        const groupKey = func(el, index, arr);\n        let group = groupKeys[groupKey];\n\n        if (!group) {\n            group = [];\n            groupKeys[groupKey] = group;\n            groups.push(group);\n        }\n        group.push(el);\n    });\n    return groups;\n}\nexport function flat<T>(arr: T[][]): T[] {\n    return arr.reduce((prev, cur) => {\n        return prev.concat(cur);\n    }, []);\n}\n\nexport function equalSign(a: number, b: number) {\n    return (a >= 0 && b >= 0) || (a < 0 && b < 0);\n}\n\nexport function maxOffset(...args: number[]) {\n    args.sort((a, b) => Math.abs(b) - Math.abs(a));\n\n    return args[0];\n}\nexport function minOffset(...args: number[]) {\n    args.sort((a, b) => Math.abs(a) - Math.abs(b));\n\n    return args[0];\n}\n\nexport function calculateInversePosition(matrix: number[], pos: number[], n: number) {\n    return calculate(\n        invert(matrix, n),\n        convertPositionMatrix(pos, n),\n        n,\n    );\n}\nexport function convertDragDist(state: MoveableManagerState, e: any) {\n    const {\n        is3d,\n        rootMatrix,\n    } = state;\n    const n = is3d ? 4 : 3;\n    [\n        e.distX, e.distY,\n    ] = calculateInversePosition(rootMatrix, [e.distX, e.distY], n);\n\n    return e;\n}\n\nexport function calculatePadding(\n    matrix: number[], pos: number[],\n    transformOrigin: number[], origin: number[], n: number,\n) {\n    return minus(calculatePosition(matrix, plus(transformOrigin, pos), n), origin);\n}\n\nexport function convertCSSSize(value: number, size: number, isRelative?: boolean) {\n    return isRelative ? `${value / size * 100}%` : `${value}px`;\n}\n\nexport function getTinyDist(v: number) {\n    return Math.abs(v) <= TINY_NUM ? 0 : v;\n}\n\nexport function getDirectionCondition(ableName: string, checkAbles: string[] = [ableName]) {\n    return (moveable: any, e: any) => {\n        if (e.isRequest) {\n            if (checkAbles.some(name => e.requestAble === name)) {\n                return e.parentDirection!;\n            } else {\n                return false;\n            }\n        }\n        const target = e.inputEvent.target;\n\n        return hasClass(target, prefix(\"direction\")) && (!ableName || hasClass(target, prefix(ableName)));\n    };\n}\n\nexport function invertObject<T extends IObject<any>>(obj: T): InvertObject<T> {\n    const nextObj: IObject<any> = {};\n\n    for (const name in obj) {\n        nextObj[obj[name]] = name;\n    }\n    return nextObj as any;\n}\n\nexport function convertTransformInfo(transforms: string[], index: number) {\n    const beforeFunctionTexts = transforms.slice(0, index < 0 ? undefined : index);\n    const beforeFunctionTexts2 = transforms.slice(0, index < 0 ? undefined : index + 1);\n    const targetFunctionText = transforms[index] || \"\";\n    const afterFunctionTexts = index < 0 ? [] : transforms.slice(index);\n    const afterFunctionTexts2 = index < 0 ? [] : transforms.slice(index + 1);\n\n    const beforeFunctions = parse(beforeFunctionTexts);\n    const beforeFunctions2 = parse(beforeFunctionTexts2);\n    const targetFunctions = parse([targetFunctionText]);\n    const afterFunctions = parse(afterFunctionTexts);\n    const afterFunctions2 = parse(afterFunctionTexts2);\n\n\n    const beforeFunctionMatrix = toMat(beforeFunctions);\n    const beforeFunctionMatrix2 = toMat(beforeFunctions2);\n    const afterFunctionMatrix = toMat(afterFunctions);\n    const afterFunctionMatrix2 = toMat(afterFunctions2);\n    const allFunctionMatrix = multiply(\n        beforeFunctionMatrix,\n        afterFunctionMatrix,\n        4,\n    );\n    return {\n        transforms,\n        beforeFunctionMatrix,\n        beforeFunctionMatrix2,\n        targetFunctionMatrix: toMat(targetFunctions),\n        afterFunctionMatrix,\n        afterFunctionMatrix2,\n        allFunctionMatrix,\n        beforeFunctions,\n        beforeFunctions2,\n        targetFunction: targetFunctions[0],\n        afterFunctions,\n        afterFunctions2,\n        beforeFunctionTexts,\n        beforeFunctionTexts2,\n        targetFunctionText,\n        afterFunctionTexts,\n        afterFunctionTexts2,\n    };\n}\n\nexport function isArrayFormat<T = any>(arr: any): arr is ArrayFormat<T> {\n    if (!arr || !isObject(arr)) {\n        return false;\n    }\n    if (arr instanceof Element) {\n        return false;\n    }\n    return isArray(arr) || \"length\" in arr;\n}\n\nexport function getRefTarget<T extends Element = HTMLElement | SVGElement>(\n    target: MoveableRefType<T>, isSelector: true): T | null;\nexport function getRefTarget<T extends Element = HTMLElement | SVGElement>(\n    target: MoveableRefType<T>, isSelector?: boolean): T | string | null;\nexport function getRefTarget<T extends Element = HTMLElement | SVGElement>(\n    target: MoveableRefType<T>,\n    isSelector?: boolean,\n): any {\n    if (!target) {\n        return null;\n    }\n    if (target instanceof Element) {\n        return target;\n    }\n    if (isString(target)) {\n        if (isSelector) {\n            return document.querySelector(target);\n        }\n        return target;\n    }\n    if (isFunction(target)) {\n        return target();\n    }\n    if (\"current\" in target) {\n        return target.current;\n    }\n    return target;\n}\n\nexport function getRefTargets(\n    targets: MoveableRefType | ArrayFormat<MoveableRefType>,\n    isSelector: true): Array<HTMLElement | SVGElement | null>;\nexport function getRefTargets(\n    targets: MoveableRefType | ArrayFormat<MoveableRefType>,\n    isSelector?: boolean): Array<HTMLElement | SVGElement | string | null>;\nexport function getRefTargets(targets: MoveableRefType | ArrayFormat<MoveableRefType>, isSelector?: boolean) {\n    if (!targets) {\n        return [];\n    }\n    const userTargets = isArrayFormat(targets) ? [].slice.call(targets) : [targets];\n\n    return userTargets.reduce((prev, target) => {\n        if (isString(target) && isSelector) {\n            return [...prev, ...[].slice.call(document.querySelectorAll<HTMLElement>(target))];\n        }\n        prev.push(getRefTarget(target, isSelector));\n        return prev;\n    }, [] as Array<SVGElement | HTMLElement | string | null | undefined>);\n}\n\nexport function getElementTargets(\n    targets: Array<SVGElement | HTMLElement | string | null | undefined>,\n    selectorMap: IObject<Array<HTMLElement | SVGElement>>,\n) {\n    const elementTargets: Array<SVGElement | HTMLElement> = [];\n    targets.forEach(target => {\n        if (!target) {\n            return;\n        }\n        if (isString(target)) {\n            if (selectorMap[target]) {\n                elementTargets.push(...selectorMap[target]);\n            }\n            return;\n        }\n        elementTargets.push(target);\n    });\n\n    return elementTargets;\n}\n\nexport function minmax(...values: number[]) {\n    return [Math.min(...values), Math.max(...values)];\n}\n\n\nexport function getAbsoluteRotation(pos1: number[], pos2: number[], direction: number) {\n    let deg = getRad(pos1, pos2) / Math.PI * 180;\n\n    deg = direction >= 0 ? deg : 180 - deg;\n    deg = deg >= 0 ? deg : 360 + deg;\n\n    return deg;\n}\n\n\nexport function getDragDistByState(state: MoveableManagerState, dist: number[]) {\n    const {\n        rootMatrix,\n        is3d,\n    } = state;\n    const n = is3d ? 4 : 3;\n\n    let inverseMatrix = invert(rootMatrix, n);\n\n    if (!is3d) {\n        inverseMatrix = convertDimension(inverseMatrix, 3, 4);\n    }\n    inverseMatrix[12] = 0;\n    inverseMatrix[13] = 0;\n    inverseMatrix[14] = 0;\n\n    return calculateMatrixDist(inverseMatrix, dist);\n}\n\nexport function getSizeDistByDist(\n    startSize: number[],\n    dist: number[],\n    ratio: number,\n    direction: number[],\n    keepRatio?: boolean,\n) {\n    const [startOffsetWidth, startOffsetHeight] = startSize;\n    let distWidth = 0;\n    let distHeight = 0;\n\n    if (keepRatio && startOffsetWidth && startOffsetHeight) {\n        const rad = getRad([0, 0], dist);\n        const standardRad = getRad([0, 0], direction);\n        const size = getDistSize(dist);\n        const signSize = Math.cos(rad - standardRad) * size;\n\n        if (!direction[0]) {\n            // top, bottom\n            distHeight = signSize;\n            distWidth = distHeight * ratio;\n        } else if (!direction[1]) {\n            // left, right\n            distWidth = signSize;\n            distHeight = distWidth / ratio;\n        } else {\n            // two-way\n            const startWidthSize = direction[0] * 2 * startOffsetWidth;\n            const startHeightSize = direction[1] * 2 * startOffsetHeight;\n            const distSize = getDistSize([startWidthSize + dist[0], startHeightSize + dist[1]])\n                - getDistSize([startWidthSize, startHeightSize]);\n            const ratioRad = getRad([0, 0], [ratio, 1]);\n\n            distWidth = Math.cos(ratioRad) * distSize;\n            distHeight = Math.sin(ratioRad) * distSize;\n        }\n    } else {\n        distWidth = direction[0] * dist[0];\n        distHeight = direction[1] * dist[1];\n    }\n\n    return [distWidth, distHeight];\n}\nexport function getOffsetSizeDist(\n    sizeDirection: number[],\n    keepRatio: boolean,\n    datas: any,\n    e: any,\n) {\n    const {\n        ratio,\n        startOffsetWidth,\n        startOffsetHeight,\n    } = datas;\n    let distWidth = 0;\n    let distHeight = 0;\n    const {\n        distX,\n        distY,\n        parentDistance,\n        parentDist,\n        parentScale,\n    } = e;\n    const startFixedDirection = datas.fixedDirection;\n    const directionsDists = [0, 1].map(index => {\n        return Math.abs(sizeDirection[index] - startFixedDirection[index]);\n    });\n    const directionRatios = [0, 1].map(index => {\n        let dist = directionsDists[index];\n\n        if (dist !== 0) {\n            dist = 2 / dist;\n        }\n        return dist;\n    });\n    if (parentDist) {\n        distWidth = parentDist[0];\n        distHeight = parentDist[1];\n\n        if (keepRatio) {\n            if (!distWidth) {\n                distWidth = distHeight * ratio;\n            } else if (!distHeight) {\n                distHeight = distWidth / ratio;\n            }\n        }\n    } else if (parentScale) {\n        distWidth = (parentScale[0] - 1) * startOffsetWidth;\n        distHeight = (parentScale[1] - 1) * startOffsetHeight;\n    } else if (parentDistance) {\n        const scaleX = startOffsetWidth * directionsDists[0];\n        const scaleY = startOffsetHeight * directionsDists[1];\n        const ratioDistance = getDistSize([scaleX, scaleY]);\n\n        distWidth = parentDistance / ratioDistance * scaleX * directionRatios[0];\n        distHeight = parentDistance / ratioDistance * scaleY * directionRatios[1];\n    } else {\n        let dist = getDragDist({ datas, distX, distY });\n\n        dist = directionRatios.map((ratio, i) => {\n            return dist[i] * ratio;\n        });\n\n        [distWidth, distHeight] = getSizeDistByDist(\n            [startOffsetWidth, startOffsetHeight],\n            dist,\n            ratio,\n            sizeDirection,\n            keepRatio,\n        );\n    }\n    return {\n        // direction,\n        // sizeDirection,\n        distWidth,\n        distHeight,\n    };\n}\n","import { makeAble } from \"./AbleManager\";\nimport { triggerEvent, fillParams, fillEndParams } from \"../utils\";\nimport {\n    PinchableProps, Able, SnappableState,\n    OnPinchStart, OnPinch, OnPinchEnd, MoveableManagerInterface, MoveableGroupInterface,\n} from \"../types\";\n\n/**\n * @namespace Moveable.Pinchable\n * @description Whether or not target can be pinched with draggable, resizable, scalable, rotatable (default: false)\n */\nexport default makeAble(\"pinchable\", {\n    events: {\n        onPinchStart: \"pinchStart\",\n        onPinch: \"pinch\",\n        onPinchEnd: \"pinchEnd\",\n        onPinchGroupStart: \"pinchGroupStart\",\n        onPinchGroup: \"pinchGroup\",\n        onPinchGroupEnd: \"pinchGroupEnd\",\n    } as const,\n    dragStart() {\n        return true;\n    },\n    pinchStart(\n        moveable: MoveableManagerInterface<PinchableProps, SnappableState>,\n        e: any,\n    ) {\n        const { datas, targets, angle, originalDatas } = e;\n        const { pinchable, ables } = moveable.props;\n\n        if (!pinchable) {\n            return false;\n        }\n        const eventName = `onPinch${targets ? \"Group\" : \"\"}Start` as \"onPinchStart\";\n        const controlEventName = `drag${targets ? \"Group\" : \"\"}ControlStart` as \"dragControlStart\";\n\n        const pinchAbles = (pinchable === true ? moveable.controlAbles : ables!.filter(able => {\n            return pinchable.indexOf(able.name as any) > -1;\n        })).filter(able => able.canPinch && able[controlEventName]);\n\n        const params = fillParams<OnPinchStart>(moveable, e, {}) as any;\n\n        if (targets) {\n            params.targets = targets;\n        }\n        const result = triggerEvent(moveable, eventName, params);\n\n        datas.isPinch = result !== false;\n        datas.ables = pinchAbles;\n\n        const isPinch = datas.isPinch;\n\n        if (!isPinch) {\n            return false;\n        }\n        pinchAbles.forEach(able => {\n            originalDatas[able.name] = originalDatas[able.name] || {};\n\n            if (!able[controlEventName]) {\n                return;\n            }\n            const ableEvent: any = {\n                ...e,\n                datas: originalDatas[able.name],\n                parentRotate: angle,\n                isPinch: true,\n            };\n            able[controlEventName]!(moveable, ableEvent);\n        });\n\n        moveable.state.snapRenderInfo = {\n            request: e.isRequest,\n            direction: [0, 0],\n        };\n        return isPinch;\n    },\n    pinch(\n        moveable: MoveableManagerInterface<PinchableProps>,\n        e: any,\n    ) {\n        const {\n            datas, scale: pinchScale, distance,\n            originalDatas,\n            inputEvent, targets,\n            angle,\n        } = e;\n        if (!datas.isPinch) {\n            return;\n        }\n        const parentDistance = distance * (1 - 1 / pinchScale);\n        const params = fillParams<OnPinch>(moveable, e, {}) as any;\n\n        if (targets) {\n            params.targets = targets;\n        }\n        const eventName = `onPinch${targets ? \"Group\" : \"\"}` as \"onPinch\";\n        triggerEvent(moveable, eventName, params);\n\n        const ables: Able[] = datas.ables;\n        const controlEventName = `drag${targets ? \"Group\" : \"\"}Control` as \"dragControl\";\n\n        ables.forEach(able => {\n            if (!able[controlEventName]) {\n                return;\n            }\n            able[controlEventName]!(moveable, {\n                ...e,\n                datas: originalDatas[able.name],\n                inputEvent,\n                parentDistance,\n                parentRotate: angle,\n                isPinch: true,\n            } as any);\n        });\n        return params;\n    },\n    pinchEnd(\n        moveable: MoveableManagerInterface<PinchableProps>,\n        e: any,\n    ) {\n        const { datas, isPinch, inputEvent, targets, originalDatas } = e;\n        if (!datas.isPinch) {\n            return;\n        }\n        const eventName = `onPinch${targets ? \"Group\" : \"\"}End` as \"onPinchEnd\";\n\n        const params = fillEndParams<OnPinchEnd>(moveable, e, { isDrag: isPinch }) as any;\n\n        if (targets) {\n            params.targets = targets;\n        }\n        triggerEvent(moveable, eventName, params);\n        const ables: Able[] = datas.ables;\n        const controlEventName = `drag${targets ? \"Group\" : \"\"}ControlEnd` as \"dragControlEnd\";\n\n        ables.forEach(able => {\n            if (!able[controlEventName]) {\n                return;\n            }\n            able[controlEventName]!(moveable, {\n                ...e,\n                isDrag: isPinch,\n                datas: originalDatas[able.name],\n                inputEvent,\n                isPinch: true,\n            } as any);\n        });\n        return isPinch;\n    },\n    pinchGroupStart(moveable: MoveableGroupInterface<any, any>, e: any) {\n        return this.pinchStart!(moveable, { ...e, targets: moveable.props.targets });\n    },\n    pinchGroup(moveable: MoveableGroupInterface, e: any) {\n        return this.pinch!(moveable, { ...e, targets: moveable.props.targets });\n    },\n    pinchGroupEnd(moveable: MoveableGroupInterface, e: any) {\n        return this.pinchEnd!(moveable, { ...e, targets: moveable.props.targets });\n    },\n});\n\n/**\n * Whether or not target can be pinched with draggable, resizable, scalable, rotatable (default: false)\n * @name Moveable.Pinchable#pinchable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.pinchable = true;\n */\n\n/**\n * When the pinch starts, the pinchStart event is called with part of scaleStart, rotateStart, resizeStart\n * @memberof Moveable.Pinchable\n * @event pinchStart\n * @param {Moveable.Pinchable.OnPinchStart} - Parameters for the pinchStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     rotatable: true,\n *     scalable: true,\n *     pinchable: true, // [\"rotatable\", \"scalable\"]\n * });\n * moveable.on(\"pinchStart\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"rotateStart\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"scaleStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When pinching, the pinch event is called with part of scale, rotate, resize\n * @memberof Moveable.Pinchable\n * @event pinch\n * @param {Moveable.Pinchable.OnPinch} - Parameters for the pinch event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     rotatable: true,\n *     scalable: true,\n *     pinchable: true, // [\"rotatable\", \"scalable\"]\n * });\n * moveable.on(\"pinch\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"rotate\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"scale\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When the pinch finishes, the pinchEnd event is called.\n * @memberof Moveable.Pinchable\n * @event pinchEnd\n * @param {Moveable.Pinchable.OnPinchEnd} - Parameters for the pinchEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     rotatable: true,\n *     scalable: true,\n *     pinchable: true, // [\"rotatable\", \"scalable\"]\n * });\n * moveable.on(\"pinchEnd\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"rotateEnd\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"scaleEnd\", ({ target }) => {\n *     console.log(target);\n * });\n */\n\n/**\n * When the group pinch starts, the `pinchGroupStart` event is called.\n * @memberof Moveable.Pinchable\n * @event pinchGroupStart\n * @param {Moveable.Pinchable.OnPinchGroupStart} - Parameters for the `pinchGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     pinchable: true\n * });\n * moveable.on(\"pinchGroupStart\", ({ targets }) => {\n *     console.log(\"onPinchGroupStart\", targets);\n * });\n */\n\n/**\n * When the group pinch, the `pinchGroup` event is called.\n * @memberof Moveable.Pinchable\n * @event pinchGroup\n * @param {Moveable.Pinchable.OnPinchGroup} - Parameters for the `pinchGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     pinchable: true\n * });\n * moveable.on(\"pinchGroup\", ({ targets, events }) => {\n *     console.log(\"onPinchGroup\", targets);\n * });\n */\n\n/**\n * When the group pinch finishes, the `pinchGroupEnd` event is called.\n * @memberof Moveable.Pinchable\n * @event pinchGroupEnd\n * @param {Moveable.Pinchable.OnPinchGroupEnd} - Parameters for the `pinchGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     pinchable: true\n * });\n * moveable.on(\"pinchGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onPinchGroupEnd\", targets, isDrag);\n * });\n */\n","import { Able, MoveableGroupInterface, MoveableManagerInterface, MoveableManagerState } from \"./types\";\nimport CustomGesto, { setCustomDrag } from \"./gesto/CustomGesto\";\n\nexport function fillChildEvents(\n    moveable: MoveableGroupInterface<any, any>,\n    name: string,\n    e: any,\n): any[] {\n    const datas = e.originalDatas;\n\n    datas.groupable = datas.groupable || {};\n\n    const groupableDatas = datas.groupable;\n\n    groupableDatas.childDatas = groupableDatas.childDatas || [];\n\n    const childDatas = groupableDatas.childDatas;\n\n    return moveable.moveables.map((_, i) => {\n        childDatas[i] = childDatas[i] || {};\n        childDatas[i][name] = childDatas[i][name] || {};\n\n        return {\n            ...e,\n            datas: childDatas[i][name],\n            originalDatas: childDatas[i],\n        };\n    });\n}\nexport function triggerChildGesto(\n    moveable: MoveableGroupInterface<any, any>,\n    able: Able,\n    type: string,\n    delta: number[],\n    e: any,\n    isConvert: boolean,\n    ableName: string,\n) {\n    const isStart = !!type.match(/Start$/g);\n    const isEnd = !!type.match(/End$/g);\n    const isPinch = e.isPinch;\n    const datas = e.datas;\n    const events = fillChildEvents(moveable, able.name, e);\n    const moveables = moveable.moveables;\n    const childs = events.map((ev, i) => {\n        const childMoveable = moveables[i];\n        const state = childMoveable.state as MoveableManagerState<any>;\n        const gestos = state.gestos;\n        let childEvent: any = ev;\n\n        if (isStart) {\n            childEvent = new CustomGesto(ableName).dragStart(delta, ev);\n        } else {\n\n\n            if (!gestos[ableName]) {\n                gestos[ableName] = datas.childGestos[i];\n            }\n            if (!gestos[ableName]) {\n                return;\n            }\n            childEvent = setCustomDrag(ev, state, delta, isPinch, isConvert, ableName);\n        }\n        const result = (able as any)[type]!(childMoveable,  { ...childEvent, parentFlag: true });\n\n        if (isEnd) {\n            gestos[ableName] = null;\n        }\n        return result;\n    });\n    if (isStart) {\n        datas.childGestos = moveables.map(child => child.state.gestos[ableName]);\n    }\n    return childs;\n}\nexport function triggerChildAbles<T extends Able>(\n    moveable: MoveableGroupInterface<any, any>,\n    able: T,\n    type: keyof T & string,\n    e: any,\n    eachEvent: (movebale: MoveableManagerInterface<any, any>, ev: any) => any = (_, ev) => ev,\n    callback?: (moveable: MoveableManagerInterface<any, any>, ev: any, result: any, index: number) => any,\n) {\n    const isEnd = !!type.match(/End$/g);\n    const events = fillChildEvents(moveable, able.name, e);\n    const moveables = moveable.moveables;\n    const childs = events.map((ev, i) => {\n        const childMoveable = moveables[i];\n        let childEvent = ev;\n\n        childEvent = eachEvent(childMoveable, ev);\n\n        const result = (able as any)[type]!(childMoveable,  { ...childEvent, parentFlag: true });\n\n        result && callback && callback(childMoveable, ev, result, i);\n\n        if (isEnd) {\n            childMoveable.state.gestos = {};\n        }\n        return result;\n    });\n\n    return childs;\n}\n","import { TINY_NUM } from \"@daybrush/utils\";\nimport { throttle } from \"@daybrush/utils\";\nimport {\n    MoveableClientRect, MoveableManagerInterface,\n    SnapDirectionPoses,\n    SnapDirections, SnappableProps,\n    SnappableState,\n} from \"../../types\";\nimport {\n    calculatePosition,\n} from \"../../utils\";\nexport const VERTICAL_NAMES = [\"left\", \"right\", \"center\"] as const;\nexport const HORIZONTAL_NAMES = [\"top\", \"bottom\", \"middle\"] as const;\nexport const VERTICAL_NAMES_MAP = {\n    start: \"left\",\n    end: \"right\",\n    center: \"center\",\n} as const;\nexport const HORIZONTAL_NAMES_MAP = {\n    start: \"top\",\n    end: \"bottom\",\n    center: \"middle\",\n} as const;\n\n\nexport function hasGuidelines(\n    moveable: MoveableManagerInterface<any, any>,\n    ableName: string\n): moveable is MoveableManagerInterface<SnappableProps, SnappableState> {\n    const {\n        props: {\n            snappable,\n            bounds,\n            innerBounds,\n            verticalGuidelines,\n            horizontalGuidelines,\n            snapGridWidth,\n            snapGridHeight,\n        },\n        state: { guidelines, enableSnap },\n    } = moveable;\n\n    if (\n        !snappable ||\n        !enableSnap ||\n        (ableName && snappable !== true && snappable.indexOf(ableName) < 0)\n    ) {\n        return false;\n    }\n    if (\n        snapGridWidth ||\n        snapGridHeight ||\n        bounds ||\n        innerBounds ||\n        (guidelines && guidelines.length) ||\n        (verticalGuidelines && verticalGuidelines.length) ||\n        (horizontalGuidelines && horizontalGuidelines.length)\n    ) {\n        return true;\n    }\n    return false;\n}\n\nexport function getSnapDirections(snapDirections: SnapDirections | boolean | undefined): SnapDirections {\n    if (snapDirections === false) {\n        return {};\n    } else if (snapDirections === true || !snapDirections) {\n        return { left: true, right: true, top: true, bottom: true };\n    }\n    return snapDirections;\n}\n\nexport function mapSnapDirectionPoses(\n    snapDirections: SnapDirections | boolean | undefined,\n    snapPoses: SnapDirectionPoses,\n) {\n    const nextSnapDirections = getSnapDirections(snapDirections);\n    const nextSnapPoses: SnapDirectionPoses = {};\n\n    for (const name in nextSnapDirections) {\n        if (name in snapPoses && (nextSnapDirections as any)[name]) {\n            (nextSnapPoses as any)[name] = (snapPoses as any)[name];\n        }\n    }\n    return nextSnapPoses;\n}\n\nexport function splitSnapDirectionPoses(\n    snapDirections: SnapDirections | boolean | undefined,\n    snapPoses: SnapDirectionPoses,\n) {\n    const nextSnapPoses = mapSnapDirectionPoses(snapDirections, snapPoses);\n    const horizontalNames = HORIZONTAL_NAMES.filter(name => name in nextSnapPoses);\n    const verticalNames = VERTICAL_NAMES.filter(name => name in nextSnapPoses);\n\n    return {\n        horizontal: horizontalNames.map(name => nextSnapPoses[name]!),\n        vertical: verticalNames.map(name => nextSnapPoses[name]!),\n    };\n}\n\nexport function calculateContainerPos(\n    rootMatrix: number[],\n    containerRect: MoveableClientRect,\n    n: number,\n) {\n    const clientPos = calculatePosition(\n        rootMatrix, [containerRect.clientLeft!, containerRect.clientTop!], n);\n\n    return [\n        containerRect.left + clientPos[0],\n        containerRect.top + clientPos[1],\n    ];\n}\n\nexport function solveLineConstants([point1, point2]: number[][]): [number, number, number] {\n    let dx = point2[0] - point1[0];\n    let dy = point2[1] - point1[1];\n\n    if (Math.abs(dx) < TINY_NUM) {\n        dx = 0;\n    }\n    if (Math.abs(dy) < TINY_NUM) {\n        dy = 0;\n    }\n\n    // b > 0\n    // ax + by + c = 0\n    let a = 0;\n    let b = 0;\n    let c = 0;\n\n    if (!dx) {\n        // -x + 1 = 0\n        a = -1;\n        c = point1[0];\n    } else if (!dy) {\n        // y - 1 = 0\n        b = 1;\n        c = -point1[1];\n    } else {\n        // y = -a(x - x1) + y1\n        // ax + y + a * x1 - y1 = 0\n        a = -dy / dx;\n        b = 1;\n        c = a * point1[0] - point1[1];\n    }\n\n    return [a, b, c].map(v => throttle(v, TINY_NUM)) as [number, number, number];\n}\n","import {\n    SnapInfo, SnappableProps, SnappableState,\n    SnapGuideline, ResizableProps, ScalableProps,\n    SnapOffsetInfo, MoveableManagerInterface, SnapDirectionPoses,\n} from \"../../types\";\nimport {\n    selectValue, getTinyDist,\n} from \"../../utils\";\nimport { getPosByDirection, getPosesByDirection } from \"../../gesto/GestoUtils\";\nimport { TINY_NUM } from \"../../consts\";\nimport { minus } from \"@scena/matrix\";\nimport { splitSnapDirectionPoses } from \"./utils\";\n\n\n\nexport function checkMoveableSnapPoses(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    posesX: number[],\n    posesY: number[],\n    customSnapThreshold?: number,\n) {\n    const props = moveable.props;\n    const snapThreshold = selectValue<number>(customSnapThreshold, props.snapThreshold, 5);\n\n    return checkSnapPoses(\n        moveable.state.guidelines,\n        posesX,\n        posesY,\n        snapThreshold,\n    );\n}\n\nexport function checkSnapPoses(\n    guidelines: SnapGuideline[],\n    posesX: number[],\n    posesY: number[],\n    snapThreshold: number,\n) {\n    return {\n        vertical: checkSnap(guidelines, \"vertical\", posesX, snapThreshold),\n        horizontal: checkSnap(guidelines, \"horizontal\", posesY, snapThreshold),\n    };\n}\nexport function checkSnapKeepRatio(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    startPos: number[],\n    endPos: number[],\n): { vertical: SnapOffsetInfo, horizontal: SnapOffsetInfo } {\n    const [endX, endY] = endPos;\n    const [startX, startY] = startPos;\n    let [dx, dy] = minus(endPos, startPos);\n    const isBottom = dy > 0;\n    const isRight = dx > 0;\n\n    dx = getTinyDist(dx);\n    dy = getTinyDist(dy);\n\n    const verticalInfo: SnapOffsetInfo = {\n        isSnap: false,\n        offset: 0,\n        pos: 0,\n    };\n    const horizontalInfo: SnapOffsetInfo = {\n        isSnap: false,\n        offset: 0,\n        pos: 0,\n    };\n\n    if (dx === 0 && dy === 0) {\n        return {\n            vertical: verticalInfo,\n            horizontal: horizontalInfo,\n        };\n    }\n    const {\n        vertical: verticalSnapInfo,\n        horizontal: horizontalSnapInfo,\n    } = checkMoveableSnapPoses(moveable, dx ? [endX] : [], dy ? [endY] : []);\n\n    verticalSnapInfo.posInfos.filter(({ pos }) => {\n        return isRight ? pos >= startX : pos <= startX;\n    });\n    horizontalSnapInfo.posInfos.filter(({ pos }) => {\n        return isBottom ? pos >= startY : pos <= startY;\n    });\n    verticalSnapInfo.isSnap = verticalSnapInfo.posInfos.length > 0;\n    horizontalSnapInfo.isSnap = horizontalSnapInfo.posInfos.length > 0;\n\n    const {\n        isSnap: isVerticalSnap,\n        guideline: verticalGuideline,\n    } = getNearestSnapGuidelineInfo(verticalSnapInfo);\n    const {\n        isSnap: isHorizontalSnap,\n        guideline: horizontalGuideline,\n    } = getNearestSnapGuidelineInfo(horizontalSnapInfo);\n    const horizontalPos = isHorizontalSnap ? horizontalGuideline!.pos[1] : 0;\n    const verticalPos = isVerticalSnap ? verticalGuideline!.pos[0] : 0;\n\n    if (dx === 0) {\n        if (isHorizontalSnap) {\n            horizontalInfo.isSnap = true;\n            horizontalInfo.pos = horizontalGuideline!.pos[1];\n            horizontalInfo.offset = endY - horizontalInfo.pos;\n        }\n    } else if (dy === 0) {\n        if (isVerticalSnap) {\n            verticalInfo.isSnap = true;\n            verticalInfo.pos = verticalPos;\n            verticalInfo.offset = endX - verticalPos;\n        }\n    } else {\n        // y - y1 = a * (x - x1)\n        const a = dy / dx;\n        const b = endPos[1] - a * endX;\n        let y = 0;\n        let x = 0;\n        let isSnap = false;\n\n        if (isVerticalSnap) {\n            x = verticalPos;\n            y = a * x + b;\n            isSnap = true;\n        } else if (isHorizontalSnap) {\n            y = horizontalPos;\n            x = (y - b) / a;\n            isSnap = true;\n        }\n        if (isSnap) {\n            verticalInfo.isSnap = true;\n            verticalInfo.pos = x;\n            verticalInfo.offset = endX - x;\n\n            horizontalInfo.isSnap = true;\n            horizontalInfo.pos = y;\n            horizontalInfo.offset = endY - y;\n        }\n    }\n    return {\n        vertical: verticalInfo,\n        horizontal: horizontalInfo,\n    };\n}\n\nexport function checkSnaps(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    rect: SnapDirectionPoses,\n    customSnapThreshold?: number,\n) {\n    const poses = splitSnapDirectionPoses(moveable.props.snapDirections, rect);\n\n    return checkMoveableSnapPoses(\n        moveable,\n        poses.vertical,\n        poses.horizontal,\n        customSnapThreshold,\n    );\n}\n\nexport function getNearestSnapGuidelineInfo(\n    snapInfo: SnapInfo,\n) {\n    const isSnap = snapInfo.isSnap;\n\n    if (!isSnap) {\n        return {\n            isSnap: false,\n            offset: 0,\n            dist: -1,\n            pos: 0,\n            guideline: null,\n        };\n    }\n    const posInfo = snapInfo.posInfos[0];\n    const guidelineInfo = posInfo!.guidelineInfos[0];\n    const offset = guidelineInfo!.offset;\n    const dist = guidelineInfo!.dist;\n    const guideline = guidelineInfo!.guideline;\n\n    return {\n        isSnap,\n        offset,\n        dist,\n        pos: posInfo!.pos,\n        guideline,\n    };\n}\n\nfunction checkSnap(\n    guidelines: SnapGuideline[],\n    targetType: \"horizontal\" | \"vertical\",\n    targetPoses: number[],\n    snapThreshold: number,\n): SnapInfo {\n    if (!guidelines || !guidelines.length) {\n        return {\n            isSnap: false,\n            index: -1,\n            posInfos: [],\n        };\n    }\n    const isVertical = targetType === \"vertical\";\n    const posType = isVertical ? 0 : 1;\n\n    const snapPosInfos = targetPoses.map((targetPos, index) => {\n        const guidelineInfos = guidelines.map(guideline => {\n            const { pos } = guideline;\n            const offset = targetPos - pos[posType];\n\n            return {\n                offset,\n                dist: Math.abs(offset),\n                guideline,\n            };\n        }).filter(({ guideline, dist }) => {\n            const { type } = guideline;\n            if (\n                type !== targetType\n                || dist > snapThreshold\n            ) {\n                return false;\n            }\n            return true;\n        }).sort(\n            (a, b) => a.dist - b.dist,\n        );\n\n\n        return {\n            pos: targetPos,\n            index,\n            guidelineInfos,\n        };\n    }).filter(snapPosInfo => {\n        return snapPosInfo.guidelineInfos.length > 0;\n    }).sort((a, b) => {\n        return a.guidelineInfos[0].dist - b.guidelineInfos[0].dist;\n    });\n\n    const isSnap = snapPosInfos.length > 0;\n    return {\n        isSnap,\n        index: isSnap ? snapPosInfos[0].index : -1,\n        posInfos: snapPosInfos,\n    };\n}\n\nexport function getSnapInfosByDirection(\n    moveable: MoveableManagerInterface<SnappableProps & (ResizableProps | ScalableProps), SnappableState>,\n    poses: number[][],\n    snapDirection: number[],\n) {\n    let nextPoses: number[][] = [];\n    if (snapDirection[0] && snapDirection[1]) {\n        nextPoses = [\n            snapDirection,\n            [-snapDirection[0], snapDirection[1]],\n            [snapDirection[0], -snapDirection[1]],\n        ].map(direction => getPosByDirection(poses, direction));\n    } else if (!snapDirection[0] && !snapDirection[1]) {\n        const alignPoses = [poses[0], poses[1], poses[3], poses[2], poses[0]];\n\n        for (let i = 0; i < 4; ++i) {\n            nextPoses.push(alignPoses[i]);\n            nextPoses.push([\n                (alignPoses[i][0] + alignPoses[i + 1][0]) / 2,\n                (alignPoses[i][1] + alignPoses[i + 1][1]) / 2,\n            ]);\n        }\n    } else {\n        if (moveable.props.keepRatio) {\n            nextPoses = [\n                [-1, -1],\n                [-1, 1],\n                [1, -1],\n                [1, 1],\n                snapDirection,\n            ].map(dir => getPosByDirection(poses, dir));\n        } else {\n            nextPoses = getPosesByDirection(poses, snapDirection);\n\n            if (nextPoses.length > 1) {\n                nextPoses.push([\n                    (nextPoses[0][0] + nextPoses[1][0]) / 2,\n                    (nextPoses[0][1] + nextPoses[1][1]) / 2,\n                ]);\n            }\n        }\n    }\n    return checkMoveableSnapPoses(moveable, nextPoses.map(pos => pos[0]), nextPoses.map(pos => pos[1]), 1);\n}\n\nexport function checkSnapBoundPriority(\n    a: { isBound: boolean, isSnap: boolean, offset: number },\n    b: { isBound: boolean, isSnap: boolean, offset: number },\n) {\n    const aDist = Math.abs(a.offset);\n    const bDist = Math.abs(b.offset);\n\n    if (a.isBound && b.isBound) {\n        return bDist - aDist;\n    } else if (a.isBound) {\n        return -1;\n    } else if (b.isBound) {\n        return 1;\n    } else if (a.isSnap && b.isSnap) {\n        return bDist - aDist;\n    } else if (a.isSnap) {\n        return -1;\n    } else if (b.isSnap) {\n        return 1;\n    } else if (aDist < TINY_NUM) {\n        return 1;\n    } else if (bDist < TINY_NUM) {\n        return -1;\n    }\n    return aDist - bDist;\n}\nexport function getNearOffsetInfo<T extends { offset: number[], isBound: boolean, isSnap: boolean, sign: number[] }>(\n    offsets: T[],\n    index: number,\n) {\n    return offsets.slice().sort((a, b) => {\n        const aSign = a.sign[index];\n        const bSign = b.sign[index];\n        const aOffset = a.offset[index];\n        const bOffset = b.offset[index];\n        // -1 The positions of a and b do not change.\n        // 1 The positions of a and b are reversed.\n        if (!aSign) {\n            return 1;\n        } else if (!bSign) {\n            return -1;\n        }\n        return checkSnapBoundPriority(\n            { isBound: a.isBound, isSnap: a.isSnap, offset: aOffset },\n            { isBound: b.isBound, isSnap: b.isSnap, offset: bOffset },\n        );\n    })[0];\n}\n\n\nexport function getCheckSnapDirections(\n    direction: number[],\n    fixedDirection: number[],\n    keepRatio: boolean\n) {\n    const directions: number[][][] = [];\n    // const fixedDirection = [-direction[0], -direction[1]];\n\n    if (keepRatio) {\n        if (Math.abs(fixedDirection[0]) !== 1 || Math.abs(fixedDirection[1]) !== 1) {\n            directions.push(\n                [fixedDirection, [-1, -1]],\n                [fixedDirection, [-1, 1]],\n                [fixedDirection, [1, -1]],\n                [fixedDirection, [1, 1]],\n            );\n        } else {\n            directions.push(\n                [fixedDirection, [direction[0], -direction[1]]],\n                [fixedDirection, [-direction[0], direction[1]]],\n            );\n        }\n        directions.push([fixedDirection, direction]);\n    } else {\n        if ((direction[0] && direction[1]) || (!direction[0] && !direction[1])) {\n            const endDirection = direction[0] ? direction : [1, 1];\n\n            [1, -1].forEach(signX => {\n                [1, -1].forEach(signY => {\n                    const nextDirection = [signX * endDirection[0], signY * endDirection[1]];\n\n                    if (\n                        fixedDirection[0] === nextDirection[0]\n                        && fixedDirection[1] === nextDirection[1]\n                    ) {\n                        return;\n                    }\n                    directions.push([fixedDirection, nextDirection]);\n                });\n            });\n        } else if (direction[0]) {\n            const signs = Math.abs(fixedDirection[0]) === 1 ? [1] : [1, -1];\n\n            signs.forEach(sign => {\n                directions.push(\n                    [\n                        [fixedDirection[0], -1],\n                        [sign * direction[0], -1],\n                    ],\n                    [\n                        [fixedDirection[0], 0],\n                        [sign * direction[0], 0],\n                    ],\n                    [\n                        [fixedDirection[0], 1],\n                        [sign * direction[0], 1],\n                    ]\n                );\n            });\n        } else if (direction[1]) {\n            const signs = Math.abs(fixedDirection[1]) === 1 ? [1] : [1, -1];\n\n            signs.forEach(sign => {\n                directions.push(\n                    [\n                        [-1, fixedDirection[1]],\n                        [-1, sign * direction[1]],\n                    ],\n                    [\n                        [0, fixedDirection[1]],\n                        [0, sign * direction[1]],\n                    ],\n                    [\n                        [1, fixedDirection[1]],\n                        [1, sign * direction[1]],\n                    ]\n                );\n            });\n        }\n    }\n    return directions;\n}\n","import { average, getRad, throttle } from \"@daybrush/utils\";\nimport { rotate } from \"@scena/matrix\";\nimport { maxOffset, getDistSize, getTinyDist, calculatePoses } from \"../../utils\";\n\nimport { SnappableProps, DraggableProps, RotatableProps, MoveableManagerInterface } from \"../../types\";\nimport { getDragDist, getPosByDirection, getInverseDragDist } from \"../../gesto/GestoUtils\";\nimport { getNearOffsetInfo } from \"./snap\";\nimport { TINY_NUM } from \"../../consts\";\nimport { solveLineConstants } from \"./utils\";\n\nfunction isStartLine(dot: number[], line: number[][]) {\n    // l    o     => true\n    // o    l    => false\n    const cx = average([line[0][0], line[1][0]]);\n    const cy = average([line[0][1], line[1][1]]);\n\n    return {\n        vertical: cx <= dot[0],\n        horizontal: cy <= dot[1],\n    };\n}\nfunction hitTestLine(\n    dot: number[],\n    [pos1, pos2]: number[][],\n) {\n    let dx = pos2[0] - pos1[0];\n    let dy = pos2[1] - pos1[1];\n\n    if (Math.abs(dx) < TINY_NUM) {\n        dx = 0;\n    }\n    if (Math.abs(dy) < TINY_NUM) {\n        dy = 0;\n    }\n    let test1: number;\n    let test2: number;\n    if (!dx) {\n        test1 = pos1[0];\n        test2 = dot[0];\n    } else if (!dy) {\n        test1 = pos1[1];\n        test2 = dot[1];\n    } else {\n        const a = dy / dx;\n\n        // y = a * (x - pos1) + pos1\n        test1 = a * (dot[0] - pos1[0]) + pos1[1];\n        test2 = dot[1];\n    }\n    return test1 - test2;\n}\nfunction isSameStartLine(dots: number[][], line: number[][], centerSign: boolean, error: number = TINY_NUM) {\n    return dots.every(dot => {\n        const value = hitTestLine(dot, line);\n        const sign = value <= 0;\n        return sign === centerSign || Math.abs(value) <= error;\n    });\n}\nfunction checkInnerBoundDot(\n    pos: number,\n    start: number,\n    end: number,\n    isStart: boolean,\n    threshold = 0,\n) {\n    if (\n        (isStart && start - threshold <= pos)\n        || (!isStart && pos <= end + threshold)\n    ) {\n        // false 402 565 602 => 37 ([0, 37])\n        // true 400 524.9712603540036 600 => 124 ([124, 0])\n        // true 400 410 600 => 10 ([10, 0])\n        return {\n            isBound: true,\n            offset: isStart ? start - pos : end - pos,\n        };\n    }\n    return {\n        isBound: false,\n        offset: 0,\n    };\n}\n\nfunction checkInnerBound(\n    moveable: MoveableManagerInterface<SnappableProps>,\n    { line, centerSign, verticalSign, horizontalSign, lineConstants }: InnerBoundLineInfo,\n) {\n    const bounds = moveable.props.innerBounds;\n\n    if (!bounds) {\n        return {\n            isAllBound: false,\n            isBound: false,\n            isVerticalBound: false,\n            isHorizontalBound: false,\n            offset: [0, 0],\n        };\n    }\n    const { left, top, width, height } = bounds;\n    const leftLine = [[left, top], [left, top + height]];\n    const topLine = [[left, top], [left + width, top]];\n    const rightLine = [[left + width, top], [left + width, top + height]];\n    const bottomLine = [[left, top + height], [left + width, top + height]];\n\n    if (isSameStartLine([\n        [left, top],\n        [left + width, top],\n        [left, top + height],\n        [left + width, top + height],\n    ], line, centerSign)) {\n        return {\n            isAllBound: false,\n            isBound: false,\n            isVerticalBound: false,\n            isHorizontalBound: false,\n            offset: [0, 0],\n        };\n    }\n    // test vertical\n\n    const topBoundInfo = checkLineBoundCollision(line, lineConstants, topLine, verticalSign);\n    const bottomBoundInfo = checkLineBoundCollision(line, lineConstants, bottomLine, verticalSign);\n\n    // test horizontal\n    const leftBoundInfo = checkLineBoundCollision(line, lineConstants, leftLine, horizontalSign);\n    const rightBoundInfo = checkLineBoundCollision(line, lineConstants, rightLine, horizontalSign);\n\n    const isAllVerticalBound = topBoundInfo.isBound && bottomBoundInfo.isBound;\n    const isVerticalBound = topBoundInfo.isBound || bottomBoundInfo.isBound;\n    const isAllHorizontalBound = leftBoundInfo.isBound && rightBoundInfo.isBound;\n    const isHorizontalBound = leftBoundInfo.isBound || rightBoundInfo.isBound;\n    const verticalOffset = maxOffset(topBoundInfo.offset, bottomBoundInfo.offset);\n    const horizontalOffset = maxOffset(leftBoundInfo.offset, rightBoundInfo.offset);\n    let offset = [0, 0];\n    let isBound = false;\n    let isAllBound = false;\n\n    if (Math.abs(horizontalOffset) < Math.abs(verticalOffset)) {\n        offset = [verticalOffset, 0];\n        isBound = isVerticalBound;\n        isAllBound = isAllVerticalBound;\n    } else {\n        offset = [0, horizontalOffset];\n        isBound = isHorizontalBound;\n        isAllBound = isAllHorizontalBound;\n    }\n    return {\n        isAllBound,\n        isVerticalBound,\n        isHorizontalBound,\n        isBound,\n        offset,\n    };\n}\n\nfunction checkLineBoundCollision(\n    line: number[][],\n    [a, b]: [number, number, number],\n    boundLine: number[][],\n    isStart: boolean,\n    threshold?: number,\n    isRender?: boolean,\n) {\n    const dot1 = line[0];\n    // const dot2 = line[1];\n    const boundDot1 = boundLine[0];\n    const boundDot2 = boundLine[1];\n\n    // const dy1 = getTinyDist(dot2[1] - dot1[1]);\n    // const dx1 = getTinyDist(dot2[0] - dot1[0]);\n    const dy2 = getTinyDist(boundDot2[1] - boundDot1[1]);\n    const dx2 = getTinyDist(boundDot2[0] - boundDot1[0]);\n\n    const hasDx = b;\n    const hasDy = a;\n    const slope = - a / b;\n    // lineConstants\n    // ax + by + c = 0\n    // dx2 or dy2 is zero\n    if (!dx2) {\n        // vertical\n        // by + c = 0\n        if (isRender && !hasDy) {\n            // 90deg\n            return {\n                isBound: false,\n                offset: 0,\n            };\n        } else if (hasDx) {\n            // ax + by + c = 0\n            // const y = dy1 ? dy1 / dx1 * (boundDot1[0] - dot1[0]) + dot1[1] : dot1[1];\n            const y = slope * (boundDot1[0] - dot1[0]) + dot1[1];\n\n            // boundDot1[1] <= y  <= boundDot2[1]\n            return checkInnerBoundDot(y, boundDot1[1], boundDot2[1], isStart, threshold);\n        } else {\n            // ax + c = 0\n            const offset = boundDot1[0] - dot1[0];\n\n            const isBound = Math.abs(offset) <= (threshold || 0);\n\n            return {\n                isBound,\n                offset: isBound ? offset : 0,\n            };\n        }\n    } else if (!dy2) {\n        // horizontal\n        if (isRender && !hasDx) {\n            // 90deg\n            return {\n                isBound: false,\n                offset: 0,\n            };\n        } else if (hasDy) {\n            // y = a * (x - x1) + y1\n            // x = (y - y1) / a + x1\n            // const a = dy1 / dx1;\n            // const x = dx1 ? (boundDot1[1] - dot1[1]) / a + dot1[0] : dot1[0];\n            const x = (boundDot1[1] - dot1[1]) / slope + dot1[0];\n\n            // boundDot1[0] <= x && x <= boundDot2[0]\n            return checkInnerBoundDot(x, boundDot1[0], boundDot2[0], isStart, threshold);\n        } else {\n            const offset = boundDot1[1] - dot1[1];\n\n            const isBound = Math.abs(offset) <= (threshold || 0);\n\n            return {\n                isBound,\n                offset: isBound ? offset : 0,\n            };\n        }\n    }\n    return {\n        isBound: false,\n        offset: 0,\n    };\n}\nexport function getInnerBoundInfo(\n    moveable: MoveableManagerInterface<SnappableProps>,\n    lineInfos: InnerBoundLineInfo[],\n    datas: any,\n) {\n    return lineInfos.map(info => {\n        const {\n            isBound,\n            offset,\n            isVerticalBound,\n            isHorizontalBound,\n        } = checkInnerBound(moveable, info);\n\n        const multiple = info.multiple;\n\n        const sizeOffset = getDragDist({\n            datas,\n            distX: offset[0],\n            distY: offset[1],\n        }).map((size, i) => size * (multiple[i] ? 2 / multiple[i] : 0));\n\n        return {\n            sign: multiple,\n            isBound,\n            isVerticalBound,\n            isHorizontalBound,\n            isSnap: false,\n            offset: sizeOffset,\n        };\n    });\n}\n\nexport function getInnerBoundDragInfo(\n    moveable: MoveableManagerInterface<SnappableProps & DraggableProps, any>,\n    poses: number[][],\n    datas: any,\n) {\n    const lines = getCheckInnerBoundLineInfos(moveable, poses, [0, 0], false).map(info => {\n        return {\n            ...info,\n            multiple: info.multiple.map(dir => Math.abs(dir) * 2),\n        };\n    });\n    const innerBoundInfo = getInnerBoundInfo(moveable, lines, datas);\n    const widthOffsetInfo = getNearOffsetInfo(innerBoundInfo, 0);\n    const heightOffsetInfo = getNearOffsetInfo(innerBoundInfo, 1);\n    let verticalOffset = 0;\n    let horizontalOffset = 0;\n    const isVerticalBound = widthOffsetInfo.isVerticalBound || heightOffsetInfo.isVerticalBound;\n    const isHorizontalBound = widthOffsetInfo.isHorizontalBound || heightOffsetInfo.isHorizontalBound;\n\n    if (isVerticalBound || isHorizontalBound) {\n        [verticalOffset, horizontalOffset] = getInverseDragDist({\n            datas,\n            distX: -widthOffsetInfo.offset[0],\n            distY: -heightOffsetInfo.offset[1],\n        });\n    }\n\n    return {\n        vertical: {\n            isBound: isVerticalBound,\n            offset: verticalOffset,\n        },\n        horizontal: {\n            isBound: isHorizontalBound,\n            offset: horizontalOffset,\n        },\n    };\n}\nexport function getCheckSnapLineDirections(\n    direction: number[],\n    keepRatio: boolean,\n) {\n    const lineDirections: number[][][] = [];\n    const x = direction[0];\n    const y = direction[1];\n    if (x && y) {\n        lineDirections.push(\n            [[0, y * 2], direction, [-x, y]],\n            [[x * 2, 0], direction, [x, -y]],\n        );\n    } else if (x) {\n        // vertcal\n        lineDirections.push(\n            [[x * 2, 0], [x, 1], [x, -1]],\n        );\n        if (keepRatio) {\n            lineDirections.push(\n                [[0, -1], [x, -1], [-x, -1]],\n                [[0, 1], [x, 1], [-x, 1]],\n            );\n        }\n    } else if (y) {\n        // horizontal\n        lineDirections.push(\n            [[0, y * 2], [1, y], [-1, y]],\n        );\n        if (keepRatio) {\n            lineDirections.push(\n                [[-1, 0], [-1, y], [-1, -y]],\n                [[1, 0], [1, y], [1, -y]],\n            );\n        }\n    } else {\n        // [0, 0] to all direction\n        lineDirections.push(\n            [[-1, 0], [-1, -1], [-1, 1]],\n            [[1, 0], [1, -1], [1, 1]],\n            [[0, -1], [-1, -1], [1, -1]],\n            [[0, 1], [-1, 1], [1, 1]],\n        );\n    }\n\n    return lineDirections;\n}\nexport interface InnerBoundLineInfo {\n    line: number[][];\n    multiple: number[];\n    horizontalSign: boolean;\n    verticalSign: boolean;\n    centerSign: boolean;\n    lineConstants: [number, number, number];\n}\nexport function getCheckInnerBoundLineInfos(\n    moveable: MoveableManagerInterface<SnappableProps>,\n    poses: number[][],\n    direction: number[],\n    keepRatio: boolean,\n): InnerBoundLineInfo[] {\n    const {\n        allMatrix,\n        is3d,\n    } = moveable.state;\n    const virtualPoses = calculatePoses(allMatrix, 100, 100, is3d ? 4 : 3);\n    const center = getPosByDirection(virtualPoses, [0, 0]);\n\n    return getCheckSnapLineDirections(direction, keepRatio).map(([multiple, dir1, dir2]) => {\n        const virtualLine = [\n            getPosByDirection(virtualPoses, dir1),\n            getPosByDirection(virtualPoses, dir2),\n        ];\n        const lineConstants = solveLineConstants(virtualLine);\n        const {\n            vertical: verticalSign,\n            horizontal: horizontalSign,\n        } = isStartLine(center, virtualLine);\n        const centerSign = hitTestLine(center, virtualLine) <= 0;\n\n        return {\n            multiple,\n            centerSign,\n            verticalSign,\n            horizontalSign,\n            lineConstants,\n            line: [\n                getPosByDirection(poses, dir1),\n                getPosByDirection(poses, dir2),\n            ],\n        };\n    });\n}\n\nfunction isBoundRotate(\n    relativePoses: number[][],\n    boundDots: number[][],\n    center: number[],\n    rad: number,\n) {\n    const nextPoses = rad ? relativePoses.map(pos => rotate(pos, rad)) : relativePoses;\n    return [\n        [nextPoses[0], nextPoses[1]],\n        [nextPoses[1], nextPoses[3]],\n        [nextPoses[3], nextPoses[2]],\n        [nextPoses[2], nextPoses[0]],\n    ].some(line => {\n        const centerSign = hitTestLine(center, line) <= 0;\n\n        return !isSameStartLine(boundDots, line, centerSign);\n    });\n}\nfunction getDistPointLine([pos1, pos2]: number[][]) {\n    // x = 0, y = 0\n    // d = (ax + by + c) / root(a2 + b2)\n\n    const dx = pos2[0] - pos1[0];\n    const dy = pos2[1] - pos1[1];\n\n    if (!dx) {\n        return Math.abs(pos1[0]);\n    }\n    if (!dy) {\n        return Math.abs(pos1[1]);\n    }\n    // y - y1 = a(x - x1)\n    // 0 = ax -y + -a * x1 + y1\n\n    const a = dy / dx;\n\n    return Math.abs((-a * pos1[0] + pos1[1]) / Math.sqrt(Math.pow(a, 2) + 1));\n}\nfunction solveReverseLine([pos1, pos2]: number[][]) {\n    const dx = pos2[0] - pos1[0];\n    const dy = pos2[1] - pos1[1];\n\n    if (!dx) {\n        return [pos1[0], 0];\n    }\n    if (!dy) {\n        return [0, pos1[1]];\n    }\n    const a = dy / dx;\n    // y - y1 = a (x  - x1)\n    // y = ax - a * x1 + y1\n    const b = -a * pos1[0] + pos1[1];\n    // y = ax + b = -1/a x\n    // x = -b / (a + 1 / a)\n    // y = b / (1 + 1 / a^2)\n\n    return [\n        -b / (a + 1 / a),\n        b / ((a * a) + 1),\n    ];\n}\nexport function checkRotateInnerBounds(\n    moveable: MoveableManagerInterface<SnappableProps & RotatableProps, any>,\n    prevPoses: number[][],\n    nextPoses: number[][],\n    origin: number[],\n    rotation: number,\n) {\n    const bounds = moveable.props.innerBounds;\n    const rad = rotation * Math.PI / 180;\n\n    if (!bounds) {\n        return [];\n    }\n    const {\n        left,\n        top,\n        width,\n        height,\n    } = bounds;\n\n    const relativeLeft = left - origin[0];\n    const relativeRight = left + width - origin[0];\n    const relativeTop = top - origin[1];\n    const relativeBottom = top + height - origin[1];\n    const dots = [\n        [relativeLeft, relativeTop],\n        [relativeRight, relativeTop],\n        [relativeLeft, relativeBottom],\n        [relativeRight, relativeBottom],\n    ];\n    const center = getPosByDirection(nextPoses, [0, 0]);\n\n    if (!isBoundRotate(nextPoses, dots, center, 0)) {\n        return [];\n    }\n    const result: number[] = [];\n    const dotInfos = dots.map(dot => [\n        getDistSize(dot),\n        getRad([0, 0], dot),\n    ]);\n    [\n        [nextPoses[0], nextPoses[1]],\n        [nextPoses[1], nextPoses[3]],\n        [nextPoses[3], nextPoses[2]],\n        [nextPoses[2], nextPoses[0]],\n    ].forEach(line => {\n        const lineRad = getRad([0, 0], solveReverseLine(line));\n        const lineDist = getDistPointLine(line);\n\n        result.push(...dotInfos\n            .filter(([dotDist]) => {\n                return dotDist && lineDist <= dotDist;\n            })\n            .map(([dotDist, dotRad]) => {\n                const distRad = Math.acos(dotDist ? lineDist / dotDist : 0);\n                const nextRad1 = dotRad + distRad;\n                const nextRad2 = dotRad - distRad;\n\n                return [\n                    rad + nextRad1 - lineRad,\n                    rad + nextRad2 - lineRad,\n                ];\n            })\n            .reduce((prev, cur) => {\n                prev.push(...cur);\n                return prev;\n            }, [])\n            .filter(nextRad => !isBoundRotate(prevPoses, dots, center, nextRad))\n            .map(nextRad => throttle(nextRad * 180 / Math.PI, TINY_NUM)));\n    });\n    return result;\n}\n\nexport function checkInnerBoundPoses(\n    moveable: MoveableManagerInterface<SnappableProps>,\n) {\n    const innerBounds = moveable.props.innerBounds;\n\n    if (!innerBounds) {\n        return {\n            vertical: [],\n            horizontal: [],\n        };\n    }\n    const {\n        pos1,\n        pos2,\n        pos3,\n        pos4,\n    } = moveable.getRect();\n    const poses = [pos1, pos2, pos3, pos4];\n    const center = getPosByDirection(poses, [0, 0]);\n    const { left, top, width, height } = innerBounds;\n    const leftLine = [[left, top], [left, top + height]];\n    const topLine = [[left, top], [left + width, top]];\n    const rightLine = [[left + width, top], [left + width, top + height]];\n    const bottomLine = [[left, top + height], [left + width, top + height]];\n    const lineInfos = getCheckInnerBoundLineInfos(moveable, poses, [0, 0], false);\n\n    const horizontalPoses: number[] = [];\n    const verticalPoses: number[] = [];\n\n    const boundMap = {\n        top: false,\n        bottom: false,\n        left: false,\n        right: false,\n    };\n\n    lineInfos.forEach(lineInfo => {\n        const { line, lineConstants } = lineInfo;\n        const {\n            horizontal: isHorizontalStart,\n            vertical: isVerticalStart,\n        } = isStartLine(center, line);\n\n        // test vertical\n        const topBoundInfo = checkLineBoundCollision(line, lineConstants, topLine, isVerticalStart, 1, true);\n        const bottomBoundInfo = checkLineBoundCollision(line, lineConstants, bottomLine, isVerticalStart, 1, true);\n\n        // test horizontal\n        const leftBoundInfo = checkLineBoundCollision(line, lineConstants, leftLine, isHorizontalStart, 1, true);\n        const rightBoundInfo = checkLineBoundCollision(line, lineConstants, rightLine, isHorizontalStart, 1, true);\n\n        if (topBoundInfo.isBound && !boundMap.top) {\n            horizontalPoses.push(top);\n            boundMap.top = true;\n        }\n        if (bottomBoundInfo.isBound && !boundMap.bottom) {\n            horizontalPoses.push(top + height);\n            boundMap.bottom = true;\n        }\n        if (leftBoundInfo.isBound && !boundMap.left) {\n            verticalPoses.push(left);\n            boundMap.left = true;\n        }\n        if (rightBoundInfo.isBound && !boundMap.right) {\n            verticalPoses.push(left + width);\n            boundMap.right = true;\n        }\n    });\n\n    return {\n        horizontal: horizontalPoses,\n        vertical: verticalPoses,\n    };\n}\n","import { getRad, throttle } from \"@daybrush/utils\";\nimport {\n    BoundInfo, SnappableProps, BoundType,\n    RotatableProps, MoveableManagerInterface, SnappableState,\n} from \"../../types\";\nimport { rotate, minus } from \"@scena/matrix\";\nimport { getDistSize } from \"../../utils\";\nimport { TINY_NUM } from \"../../consts\";\n\nexport function checkBoundPoses(\n    bounds: BoundType | false | undefined,\n    verticalPoses: number[],\n    horizontalPoses: number[],\n) {\n    const {\n        position = \"client\",\n        left = -Infinity,\n        top = -Infinity,\n        right = Infinity,\n        bottom = Infinity,\n    } = bounds || {};\n    const nextBounds = {\n        position,\n        left,\n        top,\n        right,\n        bottom,\n    };\n\n    return {\n        vertical: checkBounds(nextBounds, verticalPoses, true),\n        horizontal: checkBounds(nextBounds, horizontalPoses, false),\n    };\n}\nexport function getBounds(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    externalBounds?: BoundType | false | null,\n) {\n    const {\n        containerClientRect: {\n            clientHeight: containerHeight,\n            clientWidth: containerWidth,\n            clientLeft,\n            clientTop,\n        },\n        snapOffset: {\n            left: snapOffsetLeft,\n            top: snapOffsetTop,\n            right: snapOffsetRight,\n            bottom: snapOffsetBottom,\n        },\n    } = moveable.state;\n    const bounds = externalBounds || moveable.props.bounds || {} as BoundType;\n    const position = bounds.position || \"client\";\n    const isCSS = position === \"css\";\n    const {\n        left = -Infinity,\n        top = -Infinity,\n    } = bounds;\n    let {\n        right = isCSS ? -Infinity : Infinity,\n        bottom = isCSS ? -Infinity : Infinity,\n    } = bounds;\n\n    if (isCSS) {\n        right = containerWidth! + snapOffsetRight - snapOffsetLeft - right;\n        bottom = containerHeight! + snapOffsetBottom - snapOffsetTop - bottom;\n    }\n\n    return {\n        left: left + snapOffsetLeft - clientLeft!,\n        right: right + snapOffsetLeft - clientLeft!,\n        top: top + snapOffsetTop - clientTop!,\n        bottom: bottom + snapOffsetTop - clientTop!,\n    };\n}\nexport function checkBoundKeepRatio(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    startPos: number[],\n    endPos: number[],\n) {\n    const {\n        left,\n        top,\n        right,\n        bottom,\n    } = getBounds(moveable);\n\n    const [endX, endY] = endPos;\n    let [dx, dy] = minus(endPos, startPos);\n\n    if (Math.abs(dx) < TINY_NUM) {\n        dx = 0;\n    }\n    if (Math.abs(dy) < TINY_NUM) {\n        dy = 0;\n    }\n    const isBottom = dy > 0;\n    const isRight = dx > 0;\n\n    const verticalInfo = {\n        isBound: false,\n        offset: 0,\n        pos: 0,\n    };\n    const horizontalInfo = {\n        isBound: false,\n        offset: 0,\n        pos: 0,\n    };\n    if (dx === 0 && dy === 0) {\n        return {\n            vertical: verticalInfo,\n            horizontal: horizontalInfo,\n        };\n    } else if (dx === 0) {\n        if (isBottom) {\n            if (bottom < endY) {\n                horizontalInfo.pos = bottom;\n                horizontalInfo.offset = endY - bottom;\n            }\n        } else {\n            if (top > endY) {\n                horizontalInfo.pos = top;\n                horizontalInfo.offset = endY - top;\n            }\n        }\n    } else if (dy === 0) {\n        if (isRight) {\n            if (right < endX) {\n                verticalInfo.pos = right;\n                verticalInfo.offset = endX - right;\n            }\n        } else {\n            if (left > endX) {\n                verticalInfo.pos = left;\n                verticalInfo.offset = endX - left;\n            }\n        }\n    } else {\n        // y - y1 = a * (x - x1)\n        const a = dy / dx;\n        const b = endPos[1] - a * endX;\n        let y = 0;\n        let x = 0;\n        let isBound = false;\n\n        if (isRight && right <= endX) {\n            y = a * right + b;\n            x = right;\n            isBound = true;\n        } else if (!isRight && endX <= left) {\n            y = a * left + b;\n            x = left;\n            isBound = true;\n        }\n        if (isBound) {\n            if (y < top || y > bottom) {\n                isBound = false;\n            }\n        }\n        if (!isBound) {\n            if (isBottom && bottom <= endY) {\n                y = bottom;\n                x = (y - b) / a;\n                isBound = true;\n            } else if (!isBottom &&  endY <= top) {\n                y = top;\n                x = (y - b) / a;\n                isBound = true;\n            }\n        }\n        if (isBound) {\n            verticalInfo.isBound = true;\n            verticalInfo.pos = x;\n            verticalInfo.offset = endX - x;\n\n            horizontalInfo.isBound = true;\n            horizontalInfo.pos = y;\n            horizontalInfo.offset = endY - y;\n        }\n    }\n\n    return {\n        vertical: verticalInfo,\n        horizontal: horizontalInfo,\n    };\n}\nfunction checkBounds(\n    bounds: Required<BoundType>,\n    poses: number[],\n    isVertical: boolean,\n): BoundInfo[] {\n    // 0   [100 - 200]  300\n    const startBoundPos = bounds[isVertical ? \"left\" : \"top\"];\n    const endBoundPos = bounds[isVertical ? \"right\" : \"bottom\"];\n\n    // 450\n    const minPos = Math.min(...poses);\n    const maxPos = Math.max(...poses);\n    const boundInfos: BoundInfo[] = [];\n\n    if (startBoundPos + 1 > minPos) {\n        boundInfos.push({\n            isBound: true,\n            offset: minPos - startBoundPos,\n            pos: startBoundPos,\n        });\n    }\n    if (endBoundPos - 1 < maxPos) {\n        boundInfos.push({\n            isBound: true,\n            offset: maxPos - endBoundPos,\n            pos: endBoundPos,\n        });\n    }\n\n    if (!boundInfos.length) {\n        boundInfos.push({\n            isBound: false,\n            offset: 0,\n            pos: 0,\n        });\n    }\n\n    return boundInfos.sort((a, b) => Math.abs(b.offset) - Math.abs(a.offset));\n}\nexport function isBoundRotate(\n    relativePoses: number[][],\n    boundRect: { left: number, top: number, right: number, bottom: number },\n    rad: number,\n) {\n    const nextPoses = rad ? relativePoses.map(pos => rotate(pos, rad)) : relativePoses;\n\n    return nextPoses.some(pos => {\n        return (pos[0] < boundRect.left && Math.abs(pos[0] - boundRect.left) > 0.1)\n            || (pos[0] > boundRect.right && Math.abs(pos[0] - boundRect.right) > 0.1)\n            || (pos[1] < boundRect.top && Math.abs(pos[1] - boundRect.top) > 0.1)\n            || (pos[1] > boundRect.bottom && Math.abs(pos[1] - boundRect.bottom) > 0.1);\n    });\n}\nexport function boundRotate(\n    vec: number[],\n    boundPos: number,\n    index: number,\n) {\n    const r = getDistSize(vec);\n    const nextPos = Math.sqrt(r * r - boundPos * boundPos) || 0;\n\n    return [nextPos, -nextPos].sort((a, b) => {\n        return Math.abs(a - vec[index ? 0 : 1]) - Math.abs(b - vec[index ? 0 : 1]);\n    }).map(pos => {\n        return getRad([0, 0], index ? [pos, boundPos] : [boundPos, pos]);\n    });\n}\n\nexport function checkRotateBounds(\n    moveable: MoveableManagerInterface<SnappableProps & RotatableProps, SnappableState>,\n    prevPoses: number[][],\n    nextPoses: number[][],\n    origin: number[],\n    rotation: number,\n) {\n    if (!moveable.props.bounds) {\n        return [];\n    }\n    const rad = rotation * Math.PI / 180;\n\n    const {\n        left,\n        top,\n        right,\n        bottom,\n    } = getBounds(moveable);\n\n    const relativeLeft = left - origin[0];\n    const relativeRight = right - origin[0];\n    const relativeTop = top - origin[1];\n    const relativeBottom = bottom - origin[1];\n    const boundRect = {\n        left: relativeLeft,\n        top: relativeTop,\n        right: relativeRight,\n        bottom: relativeBottom,\n    };\n\n    if (!isBoundRotate(nextPoses, boundRect, 0)) {\n        return [];\n    }\n    const result: number[] = [];\n    [\n        [relativeLeft, 0],\n        [relativeRight, 0],\n        [relativeTop, 1],\n        [relativeBottom, 1],\n    ].forEach(([boundPos, index]) => {\n        nextPoses.forEach(nextPos => {\n            const relativeRad1 = getRad([0, 0], nextPos);\n\n            result.push(...boundRotate(nextPos, boundPos, index)\n                .map(relativeRad2 => rad + relativeRad2 - relativeRad1)\n                .filter(nextRad => !isBoundRotate(prevPoses, boundRect, nextRad))\n                .map(nextRad => throttle(nextRad * 180 / Math.PI, TINY_NUM)));\n        });\n    });\n\n    return result;\n}\n","import { throttle } from \"@daybrush/utils\";\nimport {\n    RenderGuidelineInfo, Renderer, RenderGuidelineInnerInfo,\n    MoveableManagerInterface, SnappableProps, SnapGuideline,\n    SnappableRenderType, SnappableState,\n    SnapDirectionPoses,\n} from \"../../types\";\nimport { prefix, groupBy } from \"../../utils\";\nimport { HORIZONTAL_NAMES_MAP, VERTICAL_NAMES_MAP } from \"./utils\";\n\nexport function renderGuideline(info: RenderGuidelineInfo, React: Renderer): any {\n    const { direction, classNames, size, pos, zoom, key } = info;\n    const isHorizontal = direction === \"horizontal\";\n    const scaleType = isHorizontal ? \"Y\" : \"X\";\n    // const scaleType2 = isHorizontal ? \"Y\" : \"X\";\n\n    return React.createElement(\"div\", {\n        key,\n        className: classNames.join(\" \"),\n        style: {\n            [isHorizontal ? \"width\" : \"height\"]: `${size}`,\n            transform: `translate(${pos[0]}, ${pos[1]}) translate${scaleType}(-50%) scale${scaleType}(${zoom})`,\n        },\n    });\n}\n\nexport function renderInnerGuideline(info: RenderGuidelineInnerInfo, React: Renderer): any {\n    return renderGuideline({\n        ...info,\n        classNames: [\n            prefix(\"line\", \"guideline\", info.direction),\n            ...info.classNames,\n        ].filter(className => className) as string[],\n        size: info.size || `${info.sizeValue}px`,\n        pos: info.pos || info.posValue.map(v => `${throttle(v, 0.1)}px`),\n    }, React);\n}\n\nexport function renderSnapPoses(\n    moveable: MoveableManagerInterface,\n    direction: string,\n    snapPoses: SnappableRenderType[],\n    minPos: number,\n    targetPos: number,\n    size: number,\n    index: number,\n    React: Renderer\n) {\n    const { zoom } = moveable.props;\n    return snapPoses.map(({ type, pos }, i) => {\n        const renderPos = [0, 0];\n\n        renderPos[index] = minPos;\n        renderPos[index ? 0 : 1] = -targetPos + pos;\n\n        return renderInnerGuideline(\n            {\n                key: `${direction}TargetGuideline${i}`,\n                classNames: [prefix(\"target\", \"bold\", type)],\n                posValue: renderPos,\n                sizeValue: size,\n                zoom: zoom!,\n                direction: direction,\n            },\n            React\n        );\n    });\n}\nexport function renderGuidelines(\n    moveable: MoveableManagerInterface<SnappableProps>,\n    type: \"vertical\" | \"horizontal\",\n    guidelines: SnapGuideline[],\n    targetPos: number[],\n    targetRect: SnapDirectionPoses,\n    React: Renderer\n): any[] {\n    const { zoom, isDisplayInnerSnapDigit } = moveable.props;\n\n    const mainNames = type === \"horizontal\" ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;\n    const targetStart = targetRect[mainNames.start]!;\n    const targetEnd = targetRect[mainNames.end]!;\n    return guidelines.filter(({ hide, elementRect }) => {\n        if (hide) {\n            return false;\n        }\n        if (isDisplayInnerSnapDigit && elementRect) {\n            // inner\n            const rect = elementRect.rect;\n\n            if (rect[mainNames.start]! <= targetStart && targetEnd <= rect[mainNames.end]!) {\n                return false;\n            }\n        }\n        return true;\n    }).map((guideline, i) => {\n        const { pos, size, element, className } = guideline;\n\n        const renderPos = [\n            -targetPos[0] + pos[0],\n            -targetPos[1] + pos[1],\n        ];\n\n        return renderInnerGuideline(\n            {\n                key: `${type}-default-guideline-${i}`,\n                classNames: element ? [prefix(\"bold\"), className] : [prefix(\"normal\"), className],\n                direction: type,\n                posValue: renderPos,\n                sizeValue: size,\n                zoom: zoom!,\n            },\n            React\n        );\n    });\n}\n\nexport function renderDigitLine(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    type: \"vertical\" | \"horizontal\",\n    lineType: \"dashed\" | \"gap\",\n    index: number,\n    gap: number,\n    renderPos: number[],\n    className: string | undefined,\n    React: Renderer,\n): any {\n    const {\n        snapDigit = 0,\n        isDisplaySnapDigit = true,\n        snapDistFormat = (v: number, type: \"vertical\" | \"horizontal\") => {\n            // Type can be used render different values.\n            if (type === 'vertical') {\n                return v;\n            }\n            return v;\n        },\n        zoom,\n    } = moveable.props;\n    const scaleType = type === \"horizontal\" ? \"X\" : \"Y\";\n    const sizeName = type === \"vertical\" ? \"height\" : \"width\";\n    const absGap = Math.abs(gap!);\n    const snapSize = isDisplaySnapDigit\n        ? parseFloat(absGap.toFixed(snapDigit))\n        : 0;\n    return <div\n        key={`${type}-${lineType}-guideline-${index}`}\n        className={prefix(\"guideline-group\", type)}\n        style={{\n            left: `${renderPos[0]}px`,\n            top: `${renderPos[1]}px`,\n            [sizeName]: `${absGap}px`,\n        }}\n    >\n        {renderInnerGuideline(\n            {\n                direction: type,\n                classNames: [prefix(lineType), className],\n                size: \"100%\",\n                posValue: [0, 0],\n                sizeValue: absGap,\n                zoom: zoom!,\n            },\n            React\n        )}\n        <div\n            className={prefix(\"size-value\", \"gap\")}\n            style={{\n                transform: `translate${scaleType}(-50%) scale(${zoom})`,\n            }}\n        >\n            {snapSize > 0 ? snapDistFormat(snapSize, type) : \"\"}\n        </div>\n    </div>;\n}\n\nexport function groupByElementGuidelines(\n    type: \"vertical\" | \"horizontal\",\n    guidelines: SnapGuideline[],\n    targetRect: SnapDirectionPoses,\n    isDisplayInnerSnapDigit: boolean,\n) {\n    const index = type === \"vertical\" ? 0 : 1;\n    const otherIndex = type === \"vertical\" ? 1 : 0;\n    const names = index ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;\n    const targetStart = targetRect[names.start]!;\n    const targetEnd = targetRect[names.end]!;\n    return groupBy(guidelines, (guideline) => {\n        return guideline.pos[index];\n    }).map(nextGuidelines => {\n        const start: SnapGuideline[] = [];\n        const end: SnapGuideline[] = [];\n        const inner: SnapGuideline[] = [];\n\n        nextGuidelines.forEach(guideline => {\n            const element = guideline.element!;\n            const rect = guideline.elementRect!.rect;\n            if (rect[names.end]! < targetStart) {\n                start.push(guideline);\n            } else if (targetEnd < rect[names.start]!) {\n                end.push(guideline);\n            } else if (rect[names.start]! <= targetStart && targetEnd <= rect[names.end]! && isDisplayInnerSnapDigit) {\n                const pos = guideline.pos;\n                const elementRect1 = { element, rect: { ...rect, [names.end]: rect[names.start]! } };\n                const elementRect2 = { element, rect: { ...rect, [names.start]: rect[names.end]! } };\n                const nextPos1 = [0, 0];\n                const nextPos2 = [0, 0];\n                nextPos1[index] = pos[index];\n                nextPos1[otherIndex] = pos[otherIndex];\n\n                nextPos2[index] = pos[index];\n                nextPos2[otherIndex] = pos[otherIndex] + guideline.size;\n\n\n                start.push({\n                    type,\n                    pos: nextPos1,\n                    size: 0,\n                    elementRect: elementRect1,\n                });\n                end.push({\n                    type,\n                    pos: nextPos2,\n                    size: 0,\n                    elementRect: elementRect2,\n                });\n                // inner.push(guideline);\n            }\n        });\n\n        start.sort((a, b) => {\n            return b.pos[otherIndex] - a.pos[otherIndex];\n        });\n        end.sort((a, b) => {\n            return a.pos[otherIndex] - b.pos[otherIndex];\n        });\n        return {\n            total: nextGuidelines,\n            start,\n            end,\n            inner,\n        };\n    });\n}\nexport function renderDashedGuidelines(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    guidelines: SnapGuideline[],\n    targetPos: number[],\n    targetRect: SnapDirectionPoses,\n    React: Renderer,\n): any[] {\n    const {\n        isDisplayInnerSnapDigit,\n    } = moveable.props;\n    const rendered: any[] = [];\n\n    ([\"vertical\", \"horizontal\"] as const).forEach(type => {\n        const nextGuidelines = guidelines.filter(guideline => guideline.type === type);\n        const index = type === \"vertical\" ? 1 : 0;\n        const otherIndex = index ? 0 : 1;\n\n        const groups = groupByElementGuidelines(type, nextGuidelines, targetRect, isDisplayInnerSnapDigit!);\n        const mainNames = index ? HORIZONTAL_NAMES_MAP : VERTICAL_NAMES_MAP;\n        const sideNames = index ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;\n        const targetStart = targetRect[mainNames.start]!;\n        const targetEnd = targetRect[mainNames.end]!;\n\n        groups.forEach(({ total, start, end, inner }) => {\n            const sidePos = targetPos[otherIndex] + total[0].pos[otherIndex] - targetRect[sideNames.start]!;\n\n            let prevRect = targetRect;\n\n            start.forEach(guideline => {\n                const nextRect = guideline.elementRect!.rect;\n                const size = prevRect[mainNames.start]! - nextRect[mainNames.end]!;\n\n                if (size > 0) {\n                    const renderPos = [0, 0];\n\n                    renderPos[index] = targetPos[index] + prevRect[mainNames.start]! - targetStart - size;\n                    renderPos[otherIndex] = sidePos;\n\n                    rendered.push(renderDigitLine(\n                        moveable,\n                        type,\n                        \"dashed\",\n                        rendered.length,\n                        size,\n                        renderPos,\n                        guideline.className,\n                        React\n                    ));\n                }\n                prevRect = nextRect;\n            });\n\n            prevRect = targetRect;\n            end.forEach(guideline => {\n                const nextRect = guideline.elementRect!.rect;\n                const size = nextRect[mainNames.start]! - prevRect[mainNames.end]!;\n\n                if (size > 0) {\n                    const renderPos = [0, 0];\n\n                    renderPos[index] = targetPos[index] + prevRect[mainNames.end]! - targetStart;\n                    renderPos[otherIndex] = sidePos;\n\n                    rendered.push(renderDigitLine(\n                        moveable,\n                        type,\n                        \"dashed\",\n                        rendered.length,\n                        size,\n                        renderPos,\n                        guideline.className,\n                        React\n                    ));\n                }\n                prevRect = nextRect;\n            });\n\n            inner.forEach(guideline => {\n                const nextRect = guideline.elementRect!.rect;\n\n                const size1 = targetStart - nextRect[mainNames.start]!;\n                const size2 = nextRect[mainNames.end]! - targetEnd;\n                const renderPos1 = [0, 0];\n                const renderPos2 = [0, 0];\n\n                renderPos1[index] = targetPos[index] - size1;\n                renderPos1[otherIndex] = sidePos;\n\n                renderPos2[index] = targetPos[index] + targetEnd - targetStart;\n                renderPos2[otherIndex] = sidePos;\n\n                rendered.push(renderDigitLine(\n                    moveable,\n                    type,\n                    \"dashed\",\n                    rendered.length,\n                    size1,\n                    renderPos1,\n                    guideline.className,\n                    React\n                ));\n                rendered.push(renderDigitLine(\n                    moveable,\n                    type,\n                    \"dashed\",\n                    rendered.length,\n                    size2,\n                    renderPos2,\n                    guideline.className,\n                    React\n                ));\n            });\n        });\n    });\n    return rendered;\n}\nexport function renderGapGuidelines(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    guidelines: SnapGuideline[],\n    targetPos: number[],\n    targetRect: SnapDirectionPoses,\n    React: any\n): any[] {\n    const rendered: any[] = [];\n    ([\"horizontal\", \"vertical\"] as const).forEach(type => {\n        const nextGuidelines = guidelines.filter(guideline => guideline.type === type);\n        const index = type === \"vertical\" ? 0 : 1;\n        const otherIndex = index ? 0 : 1;\n        const mainNames = index ? HORIZONTAL_NAMES_MAP : VERTICAL_NAMES_MAP;\n        const sideNames = index ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;\n        const targetStart = targetRect[mainNames.start]!;\n        const targetEnd = targetRect[mainNames.end]!;\n        const targetSideStart = targetRect[sideNames.start]!;\n        const targetSideEnd = targetRect[sideNames.end]!;\n\n\n        nextGuidelines.forEach(({ gap, gapRects }) => {\n            const sideStartPos = Math.max(\n                targetSideStart,\n                ...gapRects!.map(({ rect }) => rect[sideNames.start]!),\n            );\n            const sideEndPos = Math.min(\n                targetSideEnd,\n                ...gapRects!.map(({ rect }) => rect[sideNames.end]!),\n            );\n            const sideCenterPos = (sideStartPos + sideEndPos) / 2;\n\n            if (sideStartPos === sideEndPos || sideCenterPos === (targetSideStart + targetSideEnd)/ 2) {\n                return;\n            }\n            gapRects!.forEach(({ rect, className }) => {\n                const renderPos = [targetPos[0], targetPos[1]];\n\n                if (rect[mainNames.end]! < targetStart) {\n                    renderPos[index] += rect[mainNames.end]! - targetStart;\n                } else if (targetEnd < rect[mainNames.start]!) {\n                    renderPos[index] += rect[mainNames.start]! - targetStart - gap!;\n                } else {\n                    return;\n                }\n\n                renderPos[otherIndex] += sideCenterPos - targetSideStart;\n                rendered.push(renderDigitLine(\n                    moveable,\n                    index ? \"vertical\" : \"horizontal\",\n                    \"gap\",\n                    rendered.length,\n                    gap!,\n                    renderPos,\n                    className,\n                    React\n                ));\n            });\n        });\n    });\n    return rendered;\n}\n","import { getDist, getRad, IObject, TINY_NUM } from \"@daybrush/utils\";\nimport { minus } from \"@scena/matrix\";\nimport { getAbsolutePoses, getDistSize, getRect, maxOffset } from \"../../utils\";\nimport { getDragDist, getPosByDirection } from \"../../gesto/GestoUtils\";\nimport {\n    BoundInfo, SnapInfo, MoveableManagerInterface, SnappableProps,\n    SnappableState, SnapBoundInfo, SnapGuideline, BoundType, SnapOffsetInfo, DraggableProps,\n} from \"../../types\";\nimport { checkBoundKeepRatio, checkBoundPoses, getBounds } from \"./bounds\";\nimport { getInnerBoundDragInfo } from \"./innerBounds\";\nimport {\n    getNearestSnapGuidelineInfo, checkMoveableSnapPoses,\n    checkSnapPoses, checkSnapKeepRatio,\n} from \"./snap\";\nimport { hasGuidelines, getSnapDirections, splitSnapDirectionPoses } from \"./utils\";\n\ninterface DirectionSnapType<T> {\n    vertical: T;\n    horizontal: T;\n}\n\n\nexport function solveEquation(\n    pos1: number[],\n    pos2: number[],\n    snapOffset: number,\n    isVertical: boolean\n) {\n    let dx = pos2[0] - pos1[0];\n    let dy = pos2[1] - pos1[1];\n\n    if (Math.abs(dx) < TINY_NUM) {\n        dx = 0;\n    }\n    if (Math.abs(dy) < TINY_NUM) {\n        dy = 0;\n    }\n    if (!dx) {\n        // y = 0 * x + b\n        // only horizontal\n        if (!isVertical) {\n            return [0, snapOffset];\n        }\n        return [0, 0];\n    }\n    if (!dy) {\n        // only vertical\n        if (isVertical) {\n            return [snapOffset, 0];\n        }\n        return [0, 0];\n    }\n    // y = ax + b\n    const a = dy / dx;\n    const b = pos1[1] - a * pos1[0];\n\n    if (isVertical) {\n        // y = a * x + b\n        const y = a * (pos2[0] + snapOffset) + b;\n\n        return [snapOffset, y - pos2[1]];\n    } else {\n        // x = (y - b) / a\n        const x = (pos2[1] + snapOffset - b) / a;\n\n        return [x - pos2[0], snapOffset];\n    }\n}\n\n\nfunction solveNextOffset(\n    pos1: number[],\n    pos2: number[],\n    offset: number,\n    isVertical: boolean,\n    datas: IObject<any>\n) {\n    const sizeOffset = solveEquation(pos1, pos2, offset, isVertical);\n\n    if (!sizeOffset) {\n        return {\n            isOutside: false,\n            offset: [0, 0],\n        };\n    }\n    const size = getDist(pos1, pos2);\n    const dist1 = getDist(sizeOffset, pos1);\n    const dist2 = getDist(sizeOffset, pos2);\n\n    const isOutside = dist1 > size || dist2 > size;\n    const [widthOffset, heightOffset] = getDragDist({\n        datas,\n        distX: sizeOffset[0],\n        distY: sizeOffset[1],\n    });\n\n    return {\n        offset: [widthOffset, heightOffset],\n        isOutside,\n    };\n}\n\nfunction getSnapBound(boundInfo: BoundInfo, snapInfo: SnapInfo) {\n    if (boundInfo.isBound) {\n        return boundInfo.offset;\n    } else if (snapInfo.isSnap) {\n        return getNearestSnapGuidelineInfo(snapInfo).offset;\n    }\n    return 0;\n}\n\n\nexport function checkThrottleDragRotate(\n    throttleDragRotate: number,\n    [distX, distY]: number[],\n    [isVerticalBound, isHorizontalBound]: boolean[],\n    [isVerticalSnap, isHorizontalSnap]: boolean[],\n    [verticalOffset, horizontalOffset]: number[]\n) {\n    let offsetX = -verticalOffset;\n    let offsetY = -horizontalOffset;\n\n    if (throttleDragRotate && distX && distY) {\n        offsetX = 0;\n        offsetY = 0;\n        const adjustPoses: number[][] = [];\n        if (isVerticalBound && isHorizontalBound) {\n            adjustPoses.push([0, horizontalOffset], [verticalOffset, 0]);\n        } else if (isVerticalBound) {\n            adjustPoses.push([verticalOffset, 0]);\n        } else if (isHorizontalBound) {\n            adjustPoses.push([0, horizontalOffset]);\n        } else if (isVerticalSnap && isHorizontalSnap) {\n            adjustPoses.push([0, horizontalOffset], [verticalOffset, 0]);\n        } else if (isVerticalSnap) {\n            adjustPoses.push([verticalOffset, 0]);\n        } else if (isHorizontalSnap) {\n            adjustPoses.push([0, horizontalOffset]);\n        }\n        if (adjustPoses.length) {\n            adjustPoses.sort((a, b) => {\n                return (\n                    getDistSize(minus([distX, distY], a)) -\n                    getDistSize(minus([distX, distY], b))\n                );\n            });\n            const adjustPos = adjustPoses[0];\n\n            if (adjustPos[0] && Math.abs(distX) > TINY_NUM) {\n                offsetX = -adjustPos[0];\n                offsetY =\n                    (distY * Math.abs(distX + offsetX)) / Math.abs(distX) -\n                    distY;\n            } else if (adjustPos[1] && Math.abs(distY) > TINY_NUM) {\n                const prevDistY = distY;\n                offsetY = -adjustPos[1];\n                offsetX =\n                    (distX * Math.abs(distY + offsetY)) / Math.abs(prevDistY) -\n                    distX;\n            }\n            if (throttleDragRotate && isHorizontalBound && isVerticalBound) {\n                if (\n                    Math.abs(offsetX) > TINY_NUM &&\n                    Math.abs(offsetX) < Math.abs(verticalOffset)\n                ) {\n                    const scale = Math.abs(verticalOffset) / Math.abs(offsetX);\n\n                    offsetX *= scale;\n                    offsetY *= scale;\n                } else if (\n                    Math.abs(offsetY) > TINY_NUM &&\n                    Math.abs(offsetY) < Math.abs(horizontalOffset)\n                ) {\n                    const scale =\n                        Math.abs(horizontalOffset) / Math.abs(offsetY);\n\n                    offsetX *= scale;\n                    offsetY *= scale;\n                } else {\n                    offsetX = maxOffset(-verticalOffset, offsetX);\n                    offsetY = maxOffset(-horizontalOffset, offsetY);\n                }\n            }\n        }\n    } else {\n        offsetX = distX || isVerticalBound ? -verticalOffset : 0;\n        offsetY = distY || isHorizontalBound ? -horizontalOffset : 0;\n    }\n    return [offsetX, offsetY];\n}\n\nexport function checkSnapBoundsDrag(\n    moveable: MoveableManagerInterface<SnappableProps & DraggableProps, any>,\n    distX: number,\n    distY: number,\n    throttleDragRotate: number,\n    isRequest: boolean,\n    datas: any\n) {\n    if (!hasGuidelines(moveable, \"draggable\")) {\n        return [\n            {\n                isSnap: false,\n                isBound: false,\n                offset: 0,\n            },\n            {\n                isSnap: false,\n                isBound: false,\n                offset: 0,\n            },\n        ];\n    }\n    const poses = getAbsolutePoses(datas.absolutePoses, [distX, distY]);\n    const { left, right, top, bottom } = getRect(poses);\n    const boundPoses = {\n        horizontal: poses.map((pos) => pos[1]),\n        vertical: poses.map((pos) => pos[0]),\n    };\n    const snapDirections = getSnapDirections(moveable.props.snapDirections);\n    const snapPoses = splitSnapDirectionPoses(snapDirections, {\n        left,\n        right,\n        top,\n        bottom,\n        center: (left + right) / 2,\n        middle: (top + bottom) / 2,\n    });\n    const {\n        vertical: verticalSnapBoundInfo,\n        horizontal: horizontalSnapBoundInfo,\n    } = checkMoveableSnapBounds(moveable, isRequest, snapPoses, boundPoses);\n    const {\n        vertical: verticalInnerBoundInfo,\n        horizontal: horizontalInnerBoundInfo,\n    } = getInnerBoundDragInfo(moveable, poses, datas);\n\n    const isVerticalSnap = verticalSnapBoundInfo.isSnap;\n    const isHorizontalSnap = horizontalSnapBoundInfo.isSnap;\n    const isVerticalBound =\n        verticalSnapBoundInfo.isBound || verticalInnerBoundInfo.isBound;\n    const isHorizontalBound =\n        horizontalSnapBoundInfo.isBound || horizontalInnerBoundInfo.isBound;\n    const verticalOffset = maxOffset(\n        verticalSnapBoundInfo.offset,\n        verticalInnerBoundInfo.offset\n    );\n    const horizontalOffset = maxOffset(\n        horizontalSnapBoundInfo.offset,\n        horizontalInnerBoundInfo.offset\n    );\n\n    const [offsetX, offsetY] = checkThrottleDragRotate(\n        throttleDragRotate,\n        [distX, distY],\n        [isVerticalBound, isHorizontalBound],\n        [isVerticalSnap, isHorizontalSnap],\n        [verticalOffset, horizontalOffset]\n    );\n\n    return [\n        {\n            isBound: isVerticalBound,\n            isSnap: isVerticalSnap,\n            offset: offsetX,\n        },\n        {\n            isBound: isHorizontalBound,\n            isSnap: isHorizontalSnap,\n            offset: offsetY,\n        },\n    ];\n}\n\nexport function checkMoveableSnapBounds(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    isRequest: boolean,\n    poses: { vertical: number[]; horizontal: number[]; },\n    boundPoses: { vertical: number[]; horizontal: number[]; } = poses,\n): DirectionSnapType<Required<SnapBoundInfo>> {\n    const {\n        horizontal: horizontalBoundInfos,\n        vertical: verticalBoundInfos,\n    } = checkBoundPoses(\n        getBounds(moveable),\n        boundPoses.vertical,\n        boundPoses.horizontal,\n    );\n    const {\n        horizontal: horizontalSnapInfo,\n        vertical: verticalSnapInfo,\n    } = isRequest ? {\n        horizontal: { isSnap: false, index: -1 } as SnapInfo,\n        vertical: { isSnap: false, index: -1 } as SnapInfo,\n    } : checkMoveableSnapPoses(\n        moveable,\n        poses.vertical,\n        poses.horizontal,\n    );\n    const horizontalOffset = getSnapBound(\n        horizontalBoundInfos[0],\n        horizontalSnapInfo\n    );\n    const verticalOffset = getSnapBound(\n        verticalBoundInfos[0],\n        verticalSnapInfo\n    );\n\n    const horizontalDist = Math.abs(horizontalOffset);\n    const verticalDist = Math.abs(verticalOffset);\n\n    return {\n        horizontal: {\n            isBound: horizontalBoundInfos[0].isBound,\n            isSnap: horizontalSnapInfo.isSnap,\n            snapIndex: horizontalSnapInfo.index,\n            offset: horizontalOffset,\n            dist: horizontalDist,\n            bounds: horizontalBoundInfos,\n            snap: horizontalSnapInfo,\n        },\n        vertical: {\n            isBound: verticalBoundInfos[0].isBound,\n            isSnap: verticalSnapInfo.isSnap,\n            snapIndex: verticalSnapInfo.index,\n            offset: verticalOffset,\n            dist: verticalDist,\n            bounds: verticalBoundInfos,\n            snap: verticalSnapInfo,\n        },\n    };\n}\nexport function checkSnapBounds(\n    guideines: SnapGuideline[],\n    bounds: BoundType | undefined | false,\n    posesX: number[],\n    posesY: number[],\n    snapThreshold: number,\n): DirectionSnapType<Required<SnapBoundInfo>> {\n    const {\n        horizontal: horizontalBoundInfos,\n        vertical: verticalBoundInfos,\n    } = checkBoundPoses(bounds, posesX, posesY);\n\n    // options.isRequest ? {\n    //     horizontal: { isSnap: false, index: -1 } as SnapInfo,\n    //     vertical: { isSnap: false, index: -1 } as SnapInfo,\n    // } :\n    const {\n        horizontal: horizontalSnapInfo,\n        vertical: verticalSnapInfo,\n    } = checkSnapPoses(guideines, posesX, posesY, snapThreshold);\n\n    const horizontalOffset = getSnapBound(\n        horizontalBoundInfos[0],\n        horizontalSnapInfo\n    );\n    const verticalOffset = getSnapBound(\n        verticalBoundInfos[0],\n        verticalSnapInfo\n    );\n\n    const horizontalDist = Math.abs(horizontalOffset);\n    const verticalDist = Math.abs(verticalOffset);\n\n    return {\n        horizontal: {\n            isBound: horizontalBoundInfos[0].isBound,\n            isSnap: horizontalSnapInfo.isSnap,\n            snapIndex: horizontalSnapInfo.index,\n            offset: horizontalOffset,\n            dist: horizontalDist,\n            bounds: horizontalBoundInfos,\n            snap: horizontalSnapInfo,\n        },\n        vertical: {\n            isBound: verticalBoundInfos[0].isBound,\n            isSnap: verticalSnapInfo.isSnap,\n            snapIndex: verticalSnapInfo.index,\n            offset: verticalOffset,\n            dist: verticalDist,\n            bounds: verticalBoundInfos,\n            snap: verticalSnapInfo,\n        },\n    };\n}\n\n\nfunction checkSnapRightLine(\n    startPos: number[],\n    endPos: number[],\n    snapBoundInfo: { vertical: SnapBoundInfo; horizontal: SnapBoundInfo },\n    keepRatio: boolean\n) {\n    const rad = (getRad(startPos, endPos) / Math.PI) * 180;\n    const {\n        vertical: {\n            isBound: isVerticalBound,\n            isSnap: isVerticalSnap,\n            dist: verticalDist,\n        },\n        horizontal: {\n            isBound: isHorizontalBound,\n            isSnap: isHorizontalSnap,\n            dist: horizontalDist,\n        },\n    } = snapBoundInfo;\n\n    const rad180 = rad % 180;\n    const isHorizontalLine = rad180 < 3 || rad180 > 177;\n    const isVerticalLine = rad180 > 87 && rad180 < 93;\n\n    if (horizontalDist < verticalDist) {\n        if (\n            isVerticalBound ||\n            (isVerticalSnap &&\n                !isVerticalLine &&\n                (!keepRatio || !isHorizontalLine))\n        ) {\n            return \"vertical\";\n        }\n    }\n    if (\n        isHorizontalBound ||\n        (isHorizontalSnap &&\n            !isHorizontalLine &&\n            (!keepRatio || !isVerticalLine))\n    ) {\n        return \"horizontal\";\n    }\n    return \"\";\n}\n\n\nexport function getSnapBoundInfo(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    poses: number[][],\n    directions: number[][][],\n    keepRatio: boolean,\n    isRequest: boolean,\n    datas: any\n) {\n    return directions.map(([startDirection, endDirection]) => {\n        const otherStartPos = getPosByDirection(poses, startDirection);\n        const otherEndPos = getPosByDirection(poses, endDirection);\n        const snapBoundInfo = keepRatio\n            ? checkSnapBoundsKeepRatio(\n                moveable,\n                otherStartPos,\n                otherEndPos,\n                isRequest\n            )\n            : checkMoveableSnapBounds(moveable, isRequest, {\n                vertical: [otherEndPos[0]],\n                horizontal: [otherEndPos[1]],\n            });\n\n        const {\n            horizontal: {\n                // dist: otherHorizontalDist,\n                offset: otherHorizontalOffset,\n                isBound: isOtherHorizontalBound,\n                isSnap: isOtherHorizontalSnap,\n            },\n            vertical: {\n                // dist: otherVerticalDist,\n                offset: otherVerticalOffset,\n                isBound: isOtherVerticalBound,\n                isSnap: isOtherVerticalSnap,\n            },\n        } = snapBoundInfo;\n\n        const multiple = minus(endDirection, startDirection);\n\n        if (!otherVerticalOffset && !otherHorizontalOffset) {\n            return {\n                isBound: isOtherVerticalBound || isOtherHorizontalBound,\n                isSnap: isOtherVerticalSnap || isOtherHorizontalSnap,\n                sign: multiple,\n                offset: [0, 0],\n            };\n        }\n        const snapLine = checkSnapRightLine(\n            otherStartPos,\n            otherEndPos,\n            snapBoundInfo,\n            keepRatio\n        );\n\n        if (!snapLine) {\n            return {\n                sign: multiple,\n                isBound: false,\n                isSnap: false,\n                offset: [0, 0],\n            };\n        }\n\n        const isVertical = snapLine === \"vertical\";\n        let sizeOffset = [0, 0];\n\n        if (\n            !keepRatio\n            && Math.abs(endDirection[0]) === 1\n            && Math.abs(endDirection[1]) === 1\n            && startDirection[0] !== endDirection[0]\n            && startDirection[1] !== endDirection[1]\n        ) {\n            sizeOffset = getDragDist({\n                datas,\n                distX: -otherVerticalOffset,\n                distY: -otherHorizontalOffset,\n            });\n        } else {\n            sizeOffset = solveNextOffset(\n                otherStartPos,\n                otherEndPos,\n                -(isVertical ? otherVerticalOffset : otherHorizontalOffset),\n                isVertical,\n                datas,\n            ).offset;\n        }\n        sizeOffset = sizeOffset.map((size, i) => size * (multiple[i] ? 2 / multiple[i] : 0));\n\n\n        return {\n            sign: multiple,\n            isBound: isVertical ? isOtherVerticalBound : isOtherHorizontalBound,\n            isSnap: isVertical ? isOtherVerticalSnap : isOtherHorizontalSnap,\n            offset: sizeOffset,\n        };\n    });\n}\n\n\nfunction getSnapBoundOffset(boundInfo: BoundInfo, snapInfo: SnapOffsetInfo) {\n    if (boundInfo.isBound) {\n        return boundInfo.offset;\n    } else if (snapInfo.isSnap) {\n        return snapInfo.offset;\n    }\n    return 0;\n}\n\nexport function checkSnapBoundsKeepRatio(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    startPos: number[],\n    endPos: number[],\n    isRequest: boolean\n): DirectionSnapType<SnapBoundInfo> {\n    const {\n        horizontal: horizontalBoundInfo,\n        vertical: verticalBoundInfo,\n    } = checkBoundKeepRatio(moveable, startPos, endPos);\n    const {\n        horizontal: horizontalSnapInfo,\n        vertical: verticalSnapInfo,\n    } = isRequest ? ({\n        horizontal: { isSnap: false },\n        vertical: { isSnap: false },\n    } as any) : checkSnapKeepRatio(moveable, startPos, endPos);\n\n    const horizontalOffset = getSnapBoundOffset(\n        horizontalBoundInfo,\n        horizontalSnapInfo\n    );\n    const verticalOffset = getSnapBoundOffset(\n        verticalBoundInfo,\n        verticalSnapInfo\n    );\n\n    const horizontalDist = Math.abs(horizontalOffset);\n    const verticalDist = Math.abs(verticalOffset);\n\n    return {\n        horizontal: {\n            isBound: horizontalBoundInfo.isBound,\n            isSnap: horizontalSnapInfo.isSnap,\n            offset: horizontalOffset,\n            dist: horizontalDist,\n        },\n        vertical: {\n            isBound: verticalBoundInfo.isBound,\n            isSnap: verticalSnapInfo.isSnap,\n            offset: verticalOffset,\n            dist: verticalDist,\n        },\n    };\n}\n\nexport function checkMaxBounds(\n    moveable: MoveableManagerInterface<SnappableProps>,\n    poses: number[][],\n    direction: number[],\n    fixedPosition: number[],\n    datas: any\n) {\n    const fixedDirection = [-direction[0], -direction[1]];\n    const { width, height } = moveable.state;\n    const bounds = moveable.props.bounds;\n    let maxWidth = Infinity;\n    let maxHeight = Infinity;\n\n    if (bounds) {\n        const directions = [\n            [direction[0], -direction[1]],\n            [-direction[0], direction[1]],\n        ];\n        const {\n            left = -Infinity,\n            top = -Infinity,\n            right = Infinity,\n            bottom = Infinity,\n        } = bounds;\n\n        directions.forEach((otherDirection) => {\n            const isCheckVertical = otherDirection[0] !== fixedDirection[0];\n            const isCheckHorizontal = otherDirection[1] !== fixedDirection[1];\n            const otherPos = getPosByDirection(poses, otherDirection);\n            const deg = (getRad(fixedPosition, otherPos) * 360) / Math.PI;\n\n            if (isCheckHorizontal) {\n                const nextOtherPos = otherPos.slice();\n\n                if (Math.abs(deg - 360) < 2 || Math.abs(deg - 180) < 2) {\n                    nextOtherPos[1] = fixedPosition[1];\n                }\n                const {\n                    offset: [, heightOffset],\n                    isOutside: isHeightOutside,\n                } = solveNextOffset(\n                    fixedPosition,\n                    nextOtherPos,\n                    (fixedPosition[1] < otherPos[1] ? bottom : top) -\n                    otherPos[1],\n                    false,\n                    datas\n                );\n                if (!isNaN(heightOffset)) {\n                    maxHeight = height + (isHeightOutside ? 1 : -1) * Math.abs(heightOffset);\n                }\n            }\n            if (isCheckVertical) {\n                const nextOtherPos = otherPos.slice();\n\n                if (Math.abs(deg - 90) < 2 || Math.abs(deg - 270) < 2) {\n                    nextOtherPos[0] = fixedPosition[0];\n                }\n                const {\n                    offset: [widthOffset],\n                    isOutside: isWidthOutside,\n                } = solveNextOffset(\n                    fixedPosition,\n                    nextOtherPos,\n                    (fixedPosition[0] < otherPos[0] ? right : left) - otherPos[0],\n                    true,\n                    datas\n                );\n                if (!isNaN(widthOffset)) {\n                    maxWidth = width + (isWidthOutside ? 1 : -1) * Math.abs(widthOffset);\n                }\n            }\n        });\n    }\n    return {\n        maxWidth,\n        maxHeight,\n    };\n}\n","import { isObject, throttle } from \"@daybrush/utils\";\nimport { diff } from \"@egjs/children-differ\";\nimport { minus } from \"@scena/matrix\";\nimport { getMinMaxs } from \"overlap-area\";\nimport {\n    MoveableManagerInterface, SnappableProps,\n    SnappableState, SnapGuideline, SnapDirectionPoses, PosGuideline, ElementGuidelineValue, SnapElementRect,\n} from \"../../types\";\nimport { getRect, getAbsolutePosesByState, getRefTarget, calculateInversePosition, roundSign } from \"../../utils\";\nimport {\n    splitSnapDirectionPoses, getSnapDirections,\n    HORIZONTAL_NAMES_MAP, VERTICAL_NAMES_MAP, calculateContainerPos,\n} from \"./utils\";\n\nexport function getTotalGuidelines(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n) {\n    const {\n        snapOffset,\n        containerClientRect: {\n            overflow,\n            scrollHeight: containerHeight,\n            scrollWidth: containerWidth,\n            clientHeight: containerClientHeight,\n            clientWidth: containerClientWidth,\n            clientLeft,\n            clientTop,\n        },\n    } = moveable.state;\n    const {\n        snapGap = true,\n        verticalGuidelines,\n        horizontalGuidelines,\n        snapThreshold = 5,\n        snapGridWidth = 0,\n        snapGridHeight = 0,\n        maxSnapElementGuidelineDistance = Infinity,\n    } = moveable.props;\n    const { top, left, bottom, right } = getRect(getAbsolutePosesByState(moveable.state));\n    const targetRect = { top, left, bottom, right, center: (left + right) / 2, middle: (top + bottom) / 2 };\n    const elementGuidelines = getElementGuidelines(moveable);\n    let totalGuidelines: SnapGuideline[] = [...elementGuidelines];\n\n    if (snapGap) {\n        totalGuidelines.push(...getGapGuidelines(\n            moveable, targetRect, snapThreshold,\n        ));\n    }\n    totalGuidelines.push(...getGridGuidelines(\n        snapGridWidth,\n        snapGridHeight,\n        overflow ? containerWidth! : containerClientWidth!,\n        overflow ? containerHeight! : containerClientHeight!,\n        clientLeft,\n        clientTop,\n    ));\n\n    totalGuidelines.push(...getDefaultGuidelines(\n        horizontalGuidelines || false,\n        verticalGuidelines || false,\n        overflow ? containerWidth! : containerClientWidth!,\n        overflow ? containerHeight! : containerClientHeight!,\n        clientLeft,\n        clientTop,\n        snapOffset,\n    ));\n\n    totalGuidelines = totalGuidelines.filter(({ element, elementRect, type }) => {\n        if (!element || !elementRect) {\n            return true;\n        }\n        const rect = elementRect.rect;\n\n        return checkBetweenRects(targetRect, rect, type, maxSnapElementGuidelineDistance);\n    });\n\n    return totalGuidelines;\n}\n\nexport function getGapGuidelines(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    targetRect: SnapDirectionPoses,\n    snapThreshold: number,\n) {\n    const {\n        maxSnapElementGuidelineDistance = Infinity,\n    } = moveable.props;\n    const elementRects = moveable.state.elementRects;\n    const gapGuidelines: SnapGuideline[] = [];\n    [\n        [\"vertical\", VERTICAL_NAMES_MAP, HORIZONTAL_NAMES_MAP] as const,\n        [\"horizontal\", HORIZONTAL_NAMES_MAP, VERTICAL_NAMES_MAP] as const,\n    ].forEach(([type, mainNames, sideNames]) => {\n        const targetStart = targetRect[mainNames.start]!;\n        const targetEnd = targetRect[mainNames.end]!;\n        const targetCenter = targetRect[mainNames.center]!;\n        const targetStart2 = targetRect[sideNames.start]!;\n        const targetEnd2 = targetRect[sideNames.end]!;\n\n        // element : moveable\n        function getDist(elementRect: SnapElementRect) {\n            const rect = elementRect.rect;\n\n            if (rect[mainNames.end]! < targetStart + snapThreshold) {\n                return targetStart - rect[mainNames.end]!;\n            } else if (targetEnd - snapThreshold < rect[mainNames.start]!) {\n                return rect[mainNames.start]! - targetEnd;\n            } else {\n                return -1;\n            }\n        }\n        const nextElementRects = elementRects.filter(elementRect => {\n            const rect = elementRect.rect;\n\n            if (rect[sideNames.start]! > targetEnd2 || rect[sideNames.end]! < targetStart2) {\n                return false;\n            }\n\n            return getDist(elementRect) > 0;\n        }).sort((a, b) => {\n            return getDist(a) - getDist(b);\n        });\n\n        const groups: SnapElementRect[][] = [];\n\n        nextElementRects.forEach(snapRect1 => {\n            nextElementRects.forEach(snapRect2 => {\n                if (snapRect1 === snapRect2) {\n                    return;\n                }\n                const { rect: rect1 } = snapRect1;\n                const { rect: rect2 } = snapRect2;\n\n                const rect1Start = rect1[sideNames.start]!;\n                const rect1End = rect1[sideNames.end]!;\n                const rect2Start = rect2[sideNames.start]!;\n                const rect2End = rect2[sideNames.end]!;\n\n                if (rect1Start > rect2End || rect2Start > rect1End) {\n                    return;\n                }\n\n                groups.push([snapRect1, snapRect2]);\n            });\n        });\n\n        groups.forEach(([snapRect1, snapRect2]) => {\n            const { rect: rect1 } = snapRect1;\n            const { rect: rect2 } = snapRect2;\n\n            const rect1Start = rect1[mainNames.start]!;\n            const rect1End = rect1[mainNames.end]!;\n            const rect2Start = rect2[mainNames.start]!;\n            const rect2End = rect2[mainNames.end]!;\n            let gap = 0;\n            let pos = 0;\n            let isStart = false;\n            let isCenter = false;\n            let isEnd = false;\n\n            if (rect1End <= targetStart && targetEnd <= rect2Start) {\n                // (l)element1(r) : (l)target(r) : (l)element2(r)\n                isCenter = true;\n                gap = ((rect2Start - rect1End) - (targetEnd - targetStart)) / 2;\n                pos = rect1End + gap + (targetEnd - targetStart) / 2;\n\n                if (Math.abs(pos - targetCenter) > snapThreshold) {\n                    return;\n                }\n            } else if (rect1End < rect2Start && rect2End < targetStart + snapThreshold) {\n                // (l)element1(r) : (l)element2(r) : (l)target\n                isStart = true;\n\n                gap = rect2Start - rect1End;\n                pos = rect2End + gap;\n\n                if (Math.abs(pos - targetStart) > snapThreshold) {\n                    return;\n                }\n            } else if (rect1End < rect2Start && targetEnd - snapThreshold < rect1Start) {\n                // target(r) : (l)element1(r) : (l)element2(r)\n\n                isEnd = true;\n                gap = rect2Start - rect1End;\n                pos = rect1Start - gap;\n\n                if (Math.abs(pos - targetEnd) > snapThreshold) {\n                    return;\n                }\n            } else {\n                return;\n            }\n            if (!gap) {\n                return;\n            }\n            if (!checkBetweenRects(targetRect, rect2, type, maxSnapElementGuidelineDistance)) {\n                return;\n            }\n            gapGuidelines.push({\n                type,\n                pos: type === \"vertical\" ? [pos, 0] : [0, pos],\n                element: snapRect2.element,\n                size: 0,\n                className: snapRect2.className,\n                isStart,\n                isCenter,\n                isEnd,\n                gap,\n                hide: true,\n                gapRects: [snapRect1, snapRect2],\n            });\n        });\n    });\n    return gapGuidelines;\n}\nexport function getGridGuidelines(\n    snapGridWidth: number,\n    snapGridHeight: number,\n    containerWidth: number,\n    containerHeight: number,\n    clientLeft = 0,\n    clientTop = 0,\n): SnapGuideline[] {\n    const guidelines: SnapGuideline[] = [];\n\n    if (snapGridHeight) {\n        for (let pos = 0; pos <= containerHeight; pos += snapGridHeight) {\n            guidelines.push({\n                type: \"horizontal\",\n                pos: [0, throttle(pos - clientTop, 0.1)],\n                size: containerWidth!,\n                hide: true,\n            });\n        }\n    }\n    if (snapGridWidth) {\n        for (let pos = 0; pos <= containerWidth; pos += snapGridWidth) {\n            guidelines.push({\n                type: \"vertical\",\n                pos: [throttle(pos - clientLeft, 0.1), 0],\n                size: containerHeight!,\n                hide: true,\n            });\n        }\n    }\n    return guidelines;\n}\n\nexport function checkBetweenRects(\n    rect1: SnapDirectionPoses,\n    rect2: SnapDirectionPoses,\n    type: \"horizontal\" | \"vertical\",\n    distance: number,\n) {\n    if (type === \"horizontal\") {\n        return Math.abs(rect1.right! - rect2.left!) <= distance\n            || Math.abs(rect1.left! - rect2.right!) <= distance\n            || rect1.left! <= rect2.right! && rect2.left! <= rect1.right!;\n    } else if (type === \"vertical\") {\n        return Math.abs(rect1.bottom! - rect2.top!) <= distance\n            || Math.abs(rect1.top! - rect2.bottom!) <= distance\n            || rect1.top! <= rect2.bottom! && rect2.top! <= rect1.bottom!;\n    }\n    return true;\n}\n\n\nexport function getElementGuidelines(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n) {\n    const state = moveable.state;\n\n    const {\n        elementGuidelines = [],\n    } = moveable.props;\n\n    if (!elementGuidelines.length) {\n        state.elementRects = [];\n        return [];\n    }\n\n    const prevValues = (state.elementRects || []).filter(snapRect => !snapRect.refresh);\n    const nextElementGuidelines = elementGuidelines.map(el => {\n        if (isObject(el) && \"element\" in el) {\n            return {\n                ...el,\n                element: getRefTarget(el.element, true)!,\n            };\n        }\n        return {\n            element: getRefTarget(el, true)!,\n        };\n    }).filter(value => {\n        return value.element;\n    }) as ElementGuidelineValue[];\n\n    const {\n        maintained,\n        added,\n    } = diff(prevValues.map(v => v.element), nextElementGuidelines.map(v => v.element));\n\n\n    const nextValues: SnapElementRect[] = [];\n    maintained.forEach(([prevIndex, nextIndex]) => {\n        nextValues[nextIndex] = prevValues[prevIndex];\n    });\n\n    getSnapElementRects(moveable, added.map(index => nextElementGuidelines[index])).map((rect, i) => {\n        nextValues[added[i]] = rect;\n    });\n\n\n    state.elementRects = nextValues;\n    const elementSnapDirections = getSnapDirections(moveable.props.elementSnapDirections);\n    const nextGuidelines: SnapGuideline[] = [];\n\n    nextValues.forEach(snapRect => {\n        const {\n            element,\n            top: topValue = elementSnapDirections.top,\n            left: leftValue = elementSnapDirections.left,\n            right: rightValue = elementSnapDirections.right,\n            bottom: bottomValue = elementSnapDirections.bottom,\n            center: centerValue = elementSnapDirections.center,\n            middle: middleValue = elementSnapDirections.middle,\n            className,\n            rect,\n        } = snapRect;\n        const {\n            horizontal,\n            vertical,\n        } = splitSnapDirectionPoses({\n            top: topValue,\n            right: rightValue,\n            left: leftValue,\n            bottom: bottomValue,\n            center: centerValue,\n            middle: middleValue,\n        }, rect);\n        const rectTop = rect.top!;\n        const rectLeft = rect.left!;\n        const width = rect.right! - rectLeft;\n        const height = rect.bottom! - rectTop;\n        const sizes = [width, height];\n\n        vertical.forEach(pos => {\n            nextGuidelines.push({\n                type: \"vertical\", element, pos: [\n                    throttle(pos, 0.1),\n                    rectTop,\n                ], size: height,\n                sizes,\n                className,\n                elementRect: snapRect,\n            });\n        });\n        horizontal.forEach(pos => {\n            nextGuidelines.push({\n                type: \"horizontal\", element, pos: [\n                    rectLeft,\n                    throttle(pos, 0.1),\n                ], size: width,\n                sizes,\n                className,\n                elementRect: snapRect,\n            });\n        });\n    });\n\n    return nextGuidelines;\n}\n\n\nexport function getDefaultGuidelines(\n    horizontalGuidelines: Array<PosGuideline | number> | false,\n    verticalGuidelines: Array<PosGuideline | number> | false,\n    width: number,\n    height: number,\n    clientLeft = 0,\n    clientTop = 0,\n    snapOffset = { left: 0, top: 0, right: 0, bottom: 0 },\n): SnapGuideline[] {\n    const guidelines: SnapGuideline[] = [];\n    const {\n        left: snapOffsetLeft,\n        top: snapOffsetTop,\n        bottom: snapOffsetBottom,\n        right: snapOffsetRight,\n    } = snapOffset;\n    const snapWidth = width! + snapOffsetRight - snapOffsetLeft;\n    const snapHeight = height! + snapOffsetBottom - snapOffsetTop;\n\n    horizontalGuidelines && horizontalGuidelines!.forEach(posInfo => {\n        const nextPosInfo = isObject(posInfo) ? posInfo : { pos: posInfo };\n\n        guidelines.push({\n            type: \"horizontal\", pos: [\n                snapOffsetLeft,\n                throttle(nextPosInfo.pos - clientTop + snapOffsetTop, 0.1),\n            ], size: snapWidth,\n            className: nextPosInfo.className,\n        });\n    });\n    verticalGuidelines && verticalGuidelines!.forEach(posInfo => {\n        const nextPosInfo = isObject(posInfo) ? posInfo : { pos: posInfo };\n\n        guidelines.push({\n            type: \"vertical\", pos: [\n                throttle(nextPosInfo.pos - clientLeft + snapOffsetLeft, 0.1),\n                snapOffsetTop,\n            ], size: snapHeight,\n            className: nextPosInfo.className,\n        });\n    });\n    return guidelines;\n}\n\n\n\nexport function getSnapElementRects(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    values: ElementGuidelineValue[],\n): SnapElementRect[] {\n    if (!values.length) {\n        return [];\n    }\n    const state = moveable.state;\n    const {\n        containerClientRect,\n        targetClientRect: {\n            top: clientTop,\n            left: clientLeft,\n        },\n        rootMatrix,\n        is3d,\n    } = state;\n    const n = is3d ? 4 : 3;\n    const [containerLeft, containerTop] = calculateContainerPos(rootMatrix, containerClientRect, n);\n    const poses = getAbsolutePosesByState(state);\n    const {\n        minX: targetLeft,\n        minY: targetTop,\n    } = getMinMaxs(poses);\n    const [distLeft, distTop] = minus([targetLeft, targetTop], calculateInversePosition(rootMatrix, [\n        clientLeft - containerLeft,\n        clientTop - containerTop,\n    ], n)).map(pos => roundSign(pos));\n\n    return values.map(value => {\n        const rect = value.element.getBoundingClientRect();\n        const left = rect.left - containerLeft;\n        const top = rect.top - containerTop;\n        const bottom = top + rect.height;\n        const right = left + rect.width;\n        const [elementLeft, elementTop] = calculateInversePosition(rootMatrix, [left, top], n);\n        const [elementRight, elementBottom] = calculateInversePosition(rootMatrix, [right, bottom], n);\n\n        return {\n            ...value,\n            rect: {\n                left: elementLeft + distLeft,\n                right: elementRight + distLeft,\n                top: elementTop + distTop,\n                bottom: elementBottom + distTop,\n                center: (elementLeft + elementRight) / 2 + distLeft,\n                middle: (elementTop + elementBottom) / 2 + distTop,\n            },\n        };\n    });\n}\n\n","import {\n    Renderer,\n    SnappableProps,\n    SnappableState,\n    SnapGuideline,\n    SnapInfo,\n    ScalableProps,\n    SnapPosInfo,\n    RotatableProps,\n    RectInfo,\n    MoveableManagerInterface,\n    SnappableRenderType,\n    BoundType,\n    MoveableGroupInterface,\n} from \"../types\";\nimport {\n    prefix,\n    calculatePoses,\n    getRect,\n    getAbsolutePosesByState,\n    getAbsolutePoses,\n    getClientRect,\n    getRefTarget,\n    getDragDistByState,\n    triggerEvent,\n    getDirectionCondition,\n} from \"../utils\";\nimport {\n    findIndex, hasClass, throttle,\n} from \"@daybrush/utils\";\nimport {\n    getDragDist,\n    scaleMatrix,\n    getPosByDirection,\n} from \"../gesto/GestoUtils\";\nimport { minus, rotate, plus } from \"@scena/matrix\";\nimport { dragControlCondition as rotatableDragControlCondtion } from \"./Rotatable\";\nimport { FLOAT_POINT_NUM } from \"../consts\";\nimport {\n    getInnerBoundInfo,\n    getCheckInnerBoundLineInfos,\n    checkRotateInnerBounds,\n    checkInnerBoundPoses,\n} from \"./snappable/innerBounds\";\nimport {\n    checkBoundPoses,\n    checkRotateBounds,\n    getBounds,\n} from \"./snappable/bounds\";\nimport {\n    checkSnaps,\n    getSnapInfosByDirection,\n    getNearOffsetInfo,\n    getCheckSnapDirections,\n} from \"./snappable/snap\";\nimport {\n    renderSnapPoses,\n    renderGuidelines,\n    renderDashedGuidelines,\n    renderGapGuidelines,\n} from \"./snappable/render\";\nimport {\n    hasGuidelines,\n} from \"./snappable/utils\";\nimport {\n    checkMaxBounds,\n    checkMoveableSnapBounds,\n    getSnapBoundInfo,\n} from \"./snappable/snapBounds\";\nimport { getTotalGuidelines } from \"./snappable/getTotalGuidelines\";\n\n\nexport interface SnapPoses {\n    vertical: number[];\n    horizontal: number[];\n}\n\nexport function snapStart(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n) {\n    const state = moveable.state;\n\n    if (state.guidelines && state.guidelines.length) {\n        return;\n    }\n    const container = moveable.state.container;\n    const snapContainer = moveable.props.snapContainer || container!;\n\n    const containerClientRect = state.containerClientRect;\n    const snapOffset = {\n        left: 0,\n        top: 0,\n        bottom: 0,\n        right: 0,\n    };\n\n    if (container !== snapContainer) {\n        const snapContainerTarget = getRefTarget(snapContainer, true);\n\n        if (snapContainerTarget) {\n            const snapContainerRect = getClientRect(snapContainerTarget);\n            const offset1 = getDragDistByState(state, [\n                snapContainerRect.left - containerClientRect.left,\n                snapContainerRect.top - containerClientRect.top,\n            ]);\n            const offset2 = getDragDistByState(state, [\n                snapContainerRect.right - containerClientRect.right,\n                snapContainerRect.bottom - containerClientRect.bottom,\n            ]);\n            snapOffset.left = throttle(offset1[0], 0.00001);\n            snapOffset.top = throttle(offset1[1], 0.00001);\n            snapOffset.right = throttle(offset2[0], 0.00001);\n            snapOffset.bottom = throttle(offset2[1], 0.00001);\n        }\n    }\n\n    state.snapOffset = snapOffset;\n    state.guidelines = getTotalGuidelines(moveable);\n    state.enableSnap = true;\n}\n\nfunction getNextFixedPoses(\n    matrix: number[],\n    width: number,\n    height: number,\n    fixedDirection: number[],\n    fixedPos: number[],\n    is3d: boolean\n) {\n    const nextPoses = calculatePoses(matrix, width, height, is3d ? 4 : 3);\n    const nextFixedPos = getPosByDirection(nextPoses, fixedDirection);\n\n    return getAbsolutePoses(nextPoses, minus(fixedPos, nextFixedPos));\n}\n\nexport function normalized(value: number) {\n    return value ? value / Math.abs(value) : 0;\n}\n\n\nexport function getSizeOffsetInfo(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    poses: number[][],\n    direction: number[],\n    keepRatio: boolean,\n    isRequest: boolean,\n    datas: any\n) {\n    const { fixedDirection } = datas;\n    const directions = getCheckSnapDirections(direction, fixedDirection, keepRatio);\n    const innerBoundLineInfos = getCheckInnerBoundLineInfos(moveable, poses, direction, keepRatio);\n    const offsets = [\n        ...getSnapBoundInfo(\n            moveable,\n            poses,\n            directions,\n            keepRatio,\n            isRequest,\n            datas\n        ),\n        ...getInnerBoundInfo(\n            moveable,\n            innerBoundLineInfos,\n            datas\n        ),\n    ];\n    const widthOffsetInfo = getNearOffsetInfo(offsets, 0);\n    const heightOffsetInfo = getNearOffsetInfo(offsets, 1);\n\n    return {\n        width: {\n            isBound: widthOffsetInfo.isBound,\n            offset: widthOffsetInfo.offset[0],\n        },\n        height: {\n            isBound: heightOffsetInfo.isBound,\n            offset: heightOffsetInfo.offset[1],\n        },\n    };\n}\nexport function recheckSizeByTwoDirection(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    poses: number[][],\n    width: number,\n    height: number,\n    maxWidth: number,\n    maxHeight: number,\n    direction: number[],\n    isRequest: boolean,\n    datas: any\n) {\n    const snapPos = getPosByDirection(poses, direction);\n\n    const {\n        horizontal: { offset: horizontalOffset },\n        vertical: { offset: verticalOffset },\n    } = checkMoveableSnapBounds(moveable, isRequest, {\n        vertical: [snapPos[0]],\n        horizontal: [snapPos[1]],\n    });\n\n    if (verticalOffset || horizontalOffset) {\n        const [nextWidthOffset, nextHeightOffset] = getDragDist({\n            datas,\n            distX: -verticalOffset,\n            distY: -horizontalOffset,\n        });\n        const nextWidth = Math.min(\n            maxWidth || Infinity,\n            width + direction[0] * nextWidthOffset\n        );\n        const nextHeight = Math.min(\n            maxHeight || Infinity,\n            height + direction[1] * nextHeightOffset\n        );\n\n        return [nextWidth - width, nextHeight - height];\n    }\n    return [0, 0];\n}\nexport function checkSizeDist(\n    moveable: MoveableManagerInterface<any, any>,\n    getNextPoses: (widthOffset: number, heightOffset: number) => number[][],\n    width: number,\n    height: number,\n    direction: number[],\n    fixedPosition: number[],\n    isRequest: boolean,\n    datas: any\n) {\n    const poses = getAbsolutePosesByState(moveable.state);\n    const keepRatio = moveable.props.keepRatio;\n\n    let widthOffset = 0;\n    let heightOffset = 0;\n\n    for (let i = 0; i < 2; ++i) {\n        const nextPoses = getNextPoses(widthOffset, heightOffset);\n        const {\n            width: widthOffsetInfo,\n            height: heightOffsetInfo,\n        } = getSizeOffsetInfo(\n            moveable,\n            nextPoses,\n            direction,\n            keepRatio,\n            isRequest,\n            datas\n        );\n\n        const isWidthBound = widthOffsetInfo.isBound;\n        const isHeightBound = heightOffsetInfo.isBound;\n        let nextWidthOffset = widthOffsetInfo.offset;\n        let nextHeightOffset = heightOffsetInfo.offset;\n\n        if (i === 1) {\n            if (!isWidthBound) {\n                nextWidthOffset = 0;\n            }\n            if (!isHeightBound) {\n                nextHeightOffset = 0;\n            }\n        }\n        if (i === 0 && isRequest && !isWidthBound && !isHeightBound) {\n            return [0, 0];\n        }\n        if (keepRatio) {\n            const widthDist =\n                Math.abs(nextWidthOffset) * (width ? 1 / width : 1);\n            const heightDist =\n                Math.abs(nextHeightOffset) * (height ? 1 / height : 1);\n            const isGetWidthOffset =\n                isWidthBound && isHeightBound\n                    ? widthDist < heightDist\n                    : isHeightBound ||\n                    (!isWidthBound && widthDist < heightDist);\n            if (isGetWidthOffset) {\n                // width : height = ? : heightOffset\n                nextWidthOffset = (width * nextHeightOffset) / height;\n            } else {\n                // width : height = widthOffset : ?\n                nextHeightOffset = (height * nextWidthOffset) / width;\n            }\n        }\n        widthOffset += nextWidthOffset;\n        heightOffset += nextHeightOffset;\n    }\n\n    if (direction[0] && direction[1]) {\n        const { maxWidth, maxHeight } = checkMaxBounds(\n            moveable,\n            poses,\n            direction,\n            fixedPosition,\n            datas\n        );\n\n        const [nextWidthOffset, nextHeightOffset] = recheckSizeByTwoDirection(\n            moveable,\n            getNextPoses(widthOffset, heightOffset).map(pos => pos.map(p => throttle(p, FLOAT_POINT_NUM))),\n            width + widthOffset,\n            height + heightOffset,\n            maxWidth,\n            maxHeight,\n            direction,\n            isRequest,\n            datas\n        );\n        widthOffset += nextWidthOffset;\n        heightOffset += nextHeightOffset;\n    }\n\n    return [widthOffset, heightOffset];\n}\n\nexport function checkSnapRotate(\n    moveable: MoveableManagerInterface<SnappableProps & RotatableProps, any>,\n    rect: RectInfo,\n    origin: number[],\n    rotation: number\n) {\n    if (!hasGuidelines(moveable, \"rotatable\")) {\n        return rotation;\n    }\n\n    const { pos1, pos2, pos3, pos4 } = rect;\n    const rad = (rotation * Math.PI) / 180;\n    const prevPoses = [pos1, pos2, pos3, pos4].map((pos) => minus(pos, origin));\n    const nextPoses = prevPoses.map((pos) => rotate(pos, rad));\n\n    const result = [\n        ...checkRotateBounds(moveable, prevPoses, nextPoses, origin, rotation),\n        ...checkRotateInnerBounds(\n            moveable,\n            prevPoses,\n            nextPoses,\n            origin,\n            rotation\n        ),\n    ];\n    result.sort((a, b) => Math.abs(a - rotation) - Math.abs(b - rotation));\n\n    if (result.length) {\n        return result[0];\n    } else {\n        return rotation;\n    }\n}\nexport function checkSnapResize(\n    moveable: MoveableManagerInterface<{}, {}>,\n    width: number,\n    height: number,\n    direction: number[],\n    fixedPosition: number[],\n    isRequest: boolean,\n    datas: any\n) {\n    if (!hasGuidelines(moveable, \"resizable\")) {\n        return [0, 0];\n    }\n    const { fixedDirection, nextAllMatrix } = datas;\n    const { allMatrix, is3d } = moveable.state;\n\n    return checkSizeDist(\n        moveable,\n        (widthOffset: number, heightOffset: number) => {\n            return getNextFixedPoses(\n                nextAllMatrix || allMatrix,\n                width + widthOffset,\n                height + heightOffset,\n                fixedDirection,\n                fixedPosition,\n                is3d\n            );\n        },\n        width,\n        height,\n        direction,\n        fixedPosition,\n        isRequest,\n        datas\n    );\n}\nexport function checkSnapScale(\n    moveable: MoveableManagerInterface<ScalableProps, any>,\n    scale: number[],\n    direction: number[],\n    isRequest: boolean,\n    datas: any\n) {\n    if (!hasGuidelines(moveable, \"scalable\")) {\n        return [0, 0];\n    }\n    const { startOffsetWidth, startOffsetHeight, fixedPosition, fixedDirection, is3d } = datas;\n    const sizeDist = checkSizeDist(\n        moveable,\n        (widthOffset: number, heightOffset: number) => {\n            return getNextFixedPoses(\n                scaleMatrix(\n                    datas,\n                    plus(scale, [widthOffset / startOffsetWidth, heightOffset / startOffsetHeight]),\n                ),\n                startOffsetWidth,\n                startOffsetHeight,\n                fixedDirection,\n                fixedPosition,\n                is3d\n            );\n        },\n        startOffsetWidth,\n        startOffsetHeight,\n        direction,\n        fixedPosition,\n        isRequest,\n        datas\n    );\n    return [sizeDist[0] / startOffsetWidth, sizeDist[1] / startOffsetHeight];\n}\n\nexport function startCheckSnapDrag(\n    moveable: MoveableManagerInterface<any, any>,\n    datas: any\n) {\n    datas.absolutePoses = getAbsolutePosesByState(moveable.state);\n}\n\n\n\nfunction getSnapGuidelines(posInfos: SnapPosInfo[]) {\n    const guidelines: SnapGuideline[] = [];\n\n    posInfos.forEach((posInfo) => {\n        posInfo.guidelineInfos.forEach(({ guideline }) => {\n            if (guidelines.indexOf(guideline) > -1) {\n                return;\n            }\n            guidelines.push(guideline);\n        });\n    });\n\n    return guidelines;\n}\n\nfunction addBoundGuidelines(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    verticalPoses: number[],\n    horizontalPoses: number[],\n    verticalSnapPoses: SnappableRenderType[],\n    horizontalSnapPoses: SnappableRenderType[],\n    externalBounds?: BoundType | false | null\n) {\n    const {\n        vertical: verticalBoundInfos,\n        horizontal: horizontalBoundInfos,\n    } = checkBoundPoses(\n        getBounds(moveable, externalBounds),\n        verticalPoses,\n        horizontalPoses\n    );\n    verticalBoundInfos.forEach((info) => {\n        if (info.isBound) {\n            verticalSnapPoses.push({\n                type: \"bounds\",\n                pos: info.pos,\n            });\n        }\n    });\n    horizontalBoundInfos.forEach((info) => {\n        if (info.isBound) {\n            horizontalSnapPoses.push({\n                type: \"bounds\",\n                pos: info.pos,\n            });\n        }\n    });\n    const {\n        vertical: verticalInnerBoundPoses,\n        horizontal: horizontalInnerBoundPoses,\n    } = checkInnerBoundPoses(moveable);\n\n    verticalInnerBoundPoses.forEach((innerPos) => {\n        if (\n            findIndex(\n                verticalSnapPoses,\n                ({ type, pos }) => type === \"bounds\" && pos === innerPos\n            ) >= 0\n        ) {\n            return;\n        }\n        verticalSnapPoses.push({\n            type: \"bounds\",\n            pos: innerPos,\n        });\n    });\n\n    horizontalInnerBoundPoses.forEach((innerPos) => {\n        if (\n            findIndex(\n                horizontalSnapPoses,\n                ({ type, pos }) => type === \"bounds\" && pos === innerPos\n            ) >= 0\n        ) {\n            return;\n        }\n        horizontalSnapPoses.push({\n            type: \"bounds\",\n            pos: innerPos,\n        });\n    });\n}\n\nconst directionCondition = getDirectionCondition(\"\", [\"resizable\", \"scalable\"]);\n\n/**\n * @namespace Moveable.Snappable\n * @description Whether or not target can be snapped to the guideline. (default: false)\n * @sort 2\n */\nexport default {\n    name: \"snappable\",\n    dragRelation: \"strong\",\n    props: {\n        snappable: [Boolean, Array],\n        snapContainer: Object,\n\n        snapDirections: [Boolean, Object],\n        elementSnapDirections: [Boolean, Object],\n\n        snapGap: Boolean,\n        snapGridWidth: Number,\n        snapGridHeight: Number,\n        isDisplaySnapDigit: Boolean,\n        isDisplayInnerSnapDigit: Boolean,\n        snapDigit: Number,\n        snapThreshold: Number,\n\n        horizontalGuidelines: Array,\n        verticalGuidelines: Array,\n        elementGuidelines: Array,\n\n        bounds: Object,\n        innerBounds: Object,\n        snapDistFormat: Function,\n    } as const,\n    events: {\n        onSnap: \"snap\",\n    } as const,\n    css: [\n        `:host {\n    --bounds-color: #d66;\n}\n.guideline {\n    pointer-events: none;\n    z-index: 2;\n}\n.guideline.bounds {\n    background: #d66;\n    background: var(--bounds-color);\n}\n.guideline-group {\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.guideline-group .size-value {\n    position: absolute;\n    color: #f55;\n    font-size: 12px;\n    font-weight: bold;\n}\n.guideline-group.horizontal .size-value {\n    transform-origin: 50% 100%;\n    transform: translateX(-50%);\n    left: 50%;\n    bottom: 5px;\n}\n.guideline-group.vertical .size-value {\n    transform-origin: 0% 50%;\n    top: 50%;\n    transform: translateY(-50%);\n    left: 5px;\n}\n.guideline.gap {\n    background: #f55;\n}\n.size-value.gap {\n    color: #f55;\n}\n`,\n    ],\n    render(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n        React: Renderer\n    ): any[] {\n        const state = moveable.state;\n        const {\n            top: targetTop,\n            left: targetLeft,\n            pos1,\n            pos2,\n            pos3,\n            pos4,\n            snapRenderInfo,\n        } = state;\n\n        if (!snapRenderInfo || !hasGuidelines(moveable, \"\")) {\n            return [];\n        }\n        state.guidelines = getTotalGuidelines(moveable);\n\n\n        const minLeft = Math.min(pos1[0], pos2[0], pos3[0], pos4[0]);\n        const minTop = Math.min(pos1[1], pos2[1], pos3[1], pos4[1]);\n        const externalPoses = snapRenderInfo.externalPoses || [];\n        const poses = getAbsolutePosesByState(moveable.state);\n        const verticalSnapPoses: SnappableRenderType[] = [];\n        const horizontalSnapPoses: SnappableRenderType[] = [];\n        const verticalGuidelines: SnapGuideline[] = [];\n        const horizontalGuidelines: SnapGuideline[] = [];\n        const snapInfos: Array<{\n            vertical: SnapInfo;\n            horizontal: SnapInfo;\n        }> = [];\n        const { width, height, top, left, bottom, right } = getRect(poses);\n        const targetRect = { left, right, top, bottom, center: (left + right) / 2, middle: (top + bottom) / 2 };\n        const hasExternalPoses = externalPoses.length > 0;\n        const externalRect = hasExternalPoses\n            ? getRect(externalPoses)\n            : ({} as ReturnType<typeof getRect>);\n\n        if (!snapRenderInfo.request) {\n            if (snapRenderInfo.direction) {\n                snapInfos.push(\n                    getSnapInfosByDirection(\n                        moveable,\n                        poses,\n                        snapRenderInfo.direction\n                    )\n                );\n            }\n            if (snapRenderInfo.snap) {\n                const rect = getRect(poses);\n                if (snapRenderInfo.center) {\n                    (rect as any).middle = (rect.top + rect.bottom) / 2;\n                    (rect as any).center = (rect.left + rect.right) / 2;\n                }\n                snapInfos.push(checkSnaps(moveable, rect, 1));\n            }\n            if (hasExternalPoses) {\n                if (snapRenderInfo.center) {\n                    (externalRect as any).middle =\n                        (externalRect.top + externalRect.bottom) / 2;\n                    (externalRect as any).center =\n                        (externalRect.left + externalRect.right) / 2;\n                }\n                snapInfos.push(checkSnaps(moveable, externalRect, 1));\n            }\n            snapInfos.forEach((snapInfo) => {\n                const {\n                    vertical: { posInfos: verticalPosInfos },\n                    horizontal: { posInfos: horizontalPosInfos },\n                } = snapInfo;\n                verticalSnapPoses.push(\n                    ...verticalPosInfos.filter(({ guidelineInfos }) => {\n                        return guidelineInfos.some(({ guideline }) => !guideline.hide);\n                    }).map(\n                        (posInfo) => ({\n                            type: \"snap\",\n                            pos: posInfo.pos,\n                        } as const)\n                    )\n                );\n                horizontalSnapPoses.push(\n                    ...horizontalPosInfos.filter(({ guidelineInfos }) => {\n                        return guidelineInfos.some(({ guideline }) => !guideline.hide);\n                    }).map(\n                        (posInfo) => ({\n                            type: \"snap\",\n                            pos: posInfo.pos,\n                        } as const)\n                    )\n                );\n                verticalGuidelines.push(...getSnapGuidelines(verticalPosInfos));\n                horizontalGuidelines.push(...getSnapGuidelines(horizontalPosInfos));\n            });\n        }\n\n        addBoundGuidelines(\n            moveable,\n            [left, right],\n            [top, bottom],\n            verticalSnapPoses,\n            horizontalSnapPoses\n        );\n        if (hasExternalPoses) {\n            addBoundGuidelines(\n                moveable,\n                [externalRect.left, externalRect.right],\n                [externalRect.top, externalRect.bottom],\n                verticalSnapPoses,\n                horizontalSnapPoses,\n                snapRenderInfo.externalBounds\n            );\n        }\n        const allGuidelines = [...verticalGuidelines, ...horizontalGuidelines];\n        const elementGuidelines = allGuidelines.filter(guideline => guideline.element && !guideline.gapRects);\n        const gapGuidelines = allGuidelines.filter(guideline => guideline.gapRects);\n        triggerEvent(\n            moveable,\n            \"onSnap\",\n            {\n                guidelines: allGuidelines.filter(({ element }) => !element),\n                elements: elementGuidelines,\n                gaps: gapGuidelines,\n            },\n            true\n        );\n        return [\n            ...renderDashedGuidelines(\n                moveable,\n                elementGuidelines,\n                [minLeft, minTop],\n                targetRect,\n                React,\n            ),\n            ...renderGapGuidelines(\n                moveable,\n                gapGuidelines,\n                [minLeft, minTop],\n                targetRect,\n                React,\n            ),\n            ...renderGuidelines(\n                moveable,\n                \"horizontal\",\n                horizontalGuidelines,\n                [targetLeft, targetTop],\n                targetRect,\n                React\n            ),\n            ...renderGuidelines(\n                moveable,\n                \"vertical\",\n                verticalGuidelines,\n                [targetLeft, targetTop],\n                targetRect,\n                React\n            ),\n            ...renderSnapPoses(\n                moveable,\n                \"horizontal\",\n                horizontalSnapPoses,\n                minLeft,\n                targetTop,\n                width,\n                0,\n                React\n            ),\n            ...renderSnapPoses(\n                moveable,\n                \"vertical\",\n                verticalSnapPoses,\n                minTop,\n                targetLeft,\n                height,\n                1,\n                React\n            ),\n        ];\n    },\n    dragStart(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n        e: any\n    ) {\n        moveable.state.snapRenderInfo = {\n            request: e.isRequest,\n            snap: true,\n            center: true,\n        };\n        snapStart(moveable);\n    },\n    drag(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n    ) {\n        const state = moveable.state;\n        state.guidelines = getTotalGuidelines(moveable);\n    },\n    pinchStart(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n    ) {\n        this.unset(moveable);\n    },\n    dragEnd(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n    ) {\n        this.unset(moveable);\n    },\n    dragControlCondition(moveable: MoveableManagerInterface, e: any) {\n        if (directionCondition(moveable, e) || rotatableDragControlCondtion(moveable, e)) {\n            return true;\n        }\n        if (!e.isRequest && e.inputEvent) {\n            return hasClass(e.inputEvent.target, prefix(\"snap-control\"));\n        }\n    },\n    dragControlStart(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n    ) {\n        moveable.state.snapRenderInfo = null;\n        snapStart(moveable);\n    },\n    dragControl(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n    ) {\n        this.drag(moveable);\n    },\n    dragControlEnd(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n    ) {\n        this.unset(moveable);\n    },\n    dragGroupStart(moveable: any, e: any) {\n        this.dragStart(moveable, e);\n    },\n    dragGroup(\n        moveable: MoveableGroupInterface<SnappableProps, SnappableState>\n    ) {\n        this.drag(moveable);\n    },\n    dragGroupEnd(\n        moveable: MoveableGroupInterface<SnappableProps, SnappableState>\n    ) {\n        this.unset(moveable);\n    },\n    dragGroupControlStart(\n        moveable: MoveableGroupInterface<SnappableProps, SnappableState>\n    ) {\n        moveable.state.snapRenderInfo = null;\n        snapStart(moveable);\n    },\n    dragGroupControl(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n    ) {\n        this.drag(moveable);\n    },\n    dragGroupControlEnd(\n        moveable: MoveableGroupInterface<SnappableProps, SnappableState>\n    ) {\n        this.unset(moveable);\n    },\n    unset(moveable: any) {\n        const state = moveable.state;\n\n        state.enableSnap = false;\n        state.guidelines = [];\n        state.snapRenderInfo = null;\n        state.elementRects = [];\n    },\n};\n\n\n/**\n * Whether or not target can be snapped to the guideline. (default: false)\n * @name Moveable.Snappable#snappable\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snappable = true;\n */\n/**\n *  A snap container that is the basis for snap, bounds, and innerBounds. (default: null = container)\n * @name Moveable.Snappable#snapContainer\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.querySelector(\".container\"));\n *\n * moveable.snapContainer = document.body;\n */\n/**\n * You can specify the directions to snap to the target. (default: { left: true, top: true, right: true, bottom: true })\n * @name Moveable.Snappable#snapDirections\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   snappable: true,\n *   snapDirections: true,\n * });\n * // snap center\n * moveable.snapDirections = { left: true, top: true, right: true, bottom: true, center: true, middle: true };\n */\n\n/**\n * You can specify the snap directions of elements. (default: { left: true, top: true, right: true, bottom: true })\n * @name Moveable.Snappable#elementSnapDirections\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   snappable: true,\n *   elementSnapDirections: true,\n * });\n * // snap center\n * moveable.elementSnapDirections = { left: true, top: true, right: true, bottom: true, center: true, middle: true };\n */\n/**\n * When you drag, make the gap snap in the element guidelines. (default: true)\n * @name Moveable.Snappable#snapGap\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   snappable: true,\n *   snapElement: true,\n *   snapGap: true,\n * });\n *\n * moveable.snapGap = false;\n */\n/**\n * Distance value that can snap to guidelines. (default: 5)\n * @name Moveable.Snappable#snapThreshold\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snapThreshold = 5;\n */\n\n/**\n * Add guidelines in the horizontal direction. (default: [])\n * @name Moveable.Snappable#horizontalGuidelines\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.horizontalGuidelines = [100, 200, 500];\n */\n\n/**\n * Add guidelines in the vertical direction. (default: [])\n * @name Moveable.Snappable#verticalGuidelines\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.verticalGuidelines = [100, 200, 500];\n */\n/**\n * Add guidelines for the element. (default: [])\n * @name Moveable.Snappable#elementGuidelines\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.elementGuidelines = [\n *   document.querySelector(\".element\"),\n * ];\n */\n/**\n * You can set up boundaries.\n * @name Moveable.Snappable#bounds\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @default null\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.bounds = { left: 0, right: 1000, top: 0, bottom: 1000};\n */\n/**\n * You can set up inner boundaries.\n * @name Moveable.Snappable#innerBounds\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @default null\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.innerBounds = { left: 500, top: 500, width: 100, height: 100};\n */\n/**\n * snap distance digits (default: 0)\n * @name Moveable.Snappable#snapDigit\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snapDigit = 0\n */\n\n/**\n * If width size is greater than 0, you can vertical snap to the grid. (default: 0)\n * @name Moveable.Snappable#snapGridWidth\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snapGridWidth = 5;\n */\n\n/**\n * If height size is greater than 0, you can horizontal snap to the grid. (default: 0)\n * @name Moveable.Snappable#snapGridHeight\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snapGridHeight = 5;\n */\n/**\n * Whether to show snap distance (default: true)\n * @name Moveable.Snappable#isDisplaySnapDigit\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.isDisplaySnapDigit = true;\n */\n\n/**\n * Whether to show element inner snap distance (default: false)\n * @name Moveable.Snappable#isDisplayInnerSnapDigit\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.isDisplayInnerSnapDigit = true;\n */\n\n\n/**\n * You can set the text format of the distance shown in the guidelines. (default: self)\n * @name Moveable.Snappable#snapDistFormat\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  snappable: true,\n *  snapDistFormat: (v, type) => v,\n * });\n * moveable.snapDistFormat = (v, type) => `${v}px`;\n */\n\n/**\n * When you drag or dragControl, the `snap` event is called.\n * @memberof Moveable.Snappable\n * @event snap\n * @param {Moveable.Snappable.OnSnap} - Parameters for the `snap` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     snappable: true\n * });\n * moveable.on(\"snap\", e => {\n *     console.log(\"onSnap\", e);\n * });\n */\n","import { prefix, getControlTransform, getLineStyle, getProps } from \"./utils\";\nimport {\n    Renderer, MoveableManagerInterface,\n    RenderDirections,\n} from \"./types\";\nimport { DIRECTION_INDEXES, DIRECTION_ROTATIONS, DIRECTIONS, DIRECTIONS4 } from \"./consts\";\nimport { IObject, throttle, getRad, getKeys } from \"@daybrush/utils\";\n\nexport interface DirectionControlInfo {\n    data: Record<string, any>;\n    classNames: string[];\n    dir: string;\n}\nexport function renderDirectionControlsByInfos(\n    moveable: MoveableManagerInterface<Partial<RenderDirections>>,\n    ableName: string,\n    renderDirections: DirectionControlInfo[],\n    React: Renderer,\n): any[] {\n\n    const {\n        renderPoses,\n        rotation: rotationRad,\n        direction,\n    } = moveable.state;\n    const {\n        zoom,\n    } = getProps(moveable.props, ableName as any);\n\n\n    const sign = (direction > 0 ? 1 : -1);\n    const degRotation = rotationRad / Math.PI * 180;\n    const directionMap: IObject<boolean> = {};\n\n    const renderState = moveable.renderState;\n    if (!renderState.renderDirectionMap) {\n        renderState.renderDirectionMap = {};\n    }\n    const renderDirectionMap = renderState.renderDirectionMap;\n\n    renderDirections.forEach(({ dir }) => {\n        directionMap[dir] = true;\n    });\n\n    return renderDirections.map(({ data, classNames, dir }) => {\n        const indexes = DIRECTION_INDEXES[dir];\n\n        if (!indexes || !directionMap[dir]) {\n            return null;\n        }\n        renderDirectionMap[dir] = true;\n        const directionRotation = (throttle(degRotation, 15) + sign * DIRECTION_ROTATIONS[dir] + 720) % 180;\n\n        const dataAttrs: Record<string, string> = {};\n\n        getKeys(data).forEach(name => {\n            dataAttrs[`data-${name}`] = data[name];\n        });\n        return (\n            <div className={prefix(\"control\", \"direction\", dir, ableName, ...classNames)}\n                data-rotation={directionRotation}\n                data-direction={dir}\n                {...dataAttrs}\n                key={`direction-${dir}`}\n                style={getControlTransform(rotationRad, zoom!, ...indexes.map(index => renderPoses[index]))}></div>\n        );\n    });\n}\nexport function renderDirectionControls(\n    moveable: MoveableManagerInterface<Partial<RenderDirections>>,\n    defaultDirections: string[],\n    ableName: string,\n    React: Renderer,\n): any[] {\n    const {\n        renderDirections: directions = defaultDirections,\n    } = getProps(moveable.props, ableName as any);\n\n    if (!directions) {\n        return [];\n    }\n    const renderDirections = directions === true ? DIRECTIONS : directions;\n\n    return renderDirectionControlsByInfos(\n        moveable,\n        ableName,\n        renderDirections.map(dir => {\n            return {\n                data: {},\n                classNames: [],\n                dir,\n            };\n        }),\n        React,\n    );\n}\nexport function renderAroundControls(\n    moveable: MoveableManagerInterface<Partial<RenderDirections>>,\n    React: Renderer,\n): any[] {\n    const renderState = moveable.renderState;\n    if (!renderState.renderDirectionMap) {\n        renderState.renderDirectionMap = {};\n    }\n    const {\n        renderPoses,\n        rotation: rotationRad,\n        direction,\n    } = moveable.state;\n\n    const renderDirectionMap = renderState.renderDirectionMap;\n\n    const {\n        zoom,\n    } = moveable.props;\n    const sign = (direction > 0 ? 1 : -1);\n    const degRotation = rotationRad / Math.PI * 180;\n\n    return getKeys(renderDirectionMap).map(dir => {\n        const indexes = DIRECTION_INDEXES[dir];\n\n        if (!indexes) {\n            return null;\n        }\n        const directionRotation = (throttle(degRotation, 15) + sign * DIRECTION_ROTATIONS[dir] + 720) % 180;\n\n        return (\n            <div className={prefix(\"around-control\")} data-rotation={directionRotation} data-direction={dir} key={`direction-around-${dir}`}\n                style={getControlTransform(rotationRad, zoom!, ...indexes.map(index => renderPoses[index]))}></div>\n        );\n    });\n}\n\nexport function renderLine(\n    React: Renderer,\n    direction: string,\n    pos1: number[],\n    pos2: number[],\n    zoom: number,\n    key: number | string,\n    ...classNames: string[]\n): any {\n    const rad = getRad(pos1, pos2);\n    const rotation = direction ? (throttle(rad / Math.PI * 180, 15)) % 180 : -1;\n\n    return <div key={`line${key}`}\n        className={prefix(\"line\", \"direction\", direction ? \"edge\" : \"\", direction, ...classNames)}\n        data-rotation={rotation}\n        data-line-index={key}\n        data-direction={direction} style={getLineStyle(pos1, pos2, zoom, rad)}></div>;\n}\n\nexport function renderEdgeLines(\n    React: Renderer,\n    ableName: string,\n    edge: true | string[],\n    poses: number[][],\n    zoom: number,\n): any[] {\n    const directions = edge === true ? DIRECTIONS4 : edge;\n\n    return directions.map((direction, i) => {\n        const [index1, index2] = DIRECTION_INDEXES[direction];\n\n        if (index2 == null) {\n            return;\n        }\n        return renderLine(React, direction, poses[index1], poses[index2], zoom, `${ableName}Edge${i}`, ableName);\n    }).filter(Boolean);\n}\nexport function getRenderDirections(ableName: string) {\n    return (\n        moveable: MoveableManagerInterface<Partial<RenderDirections>>,\n        React: Renderer,\n    ) => {\n        const edge = getProps(moveable.props, ableName as any).edge;\n\n        if (edge && (edge === true || edge.length)) {\n            return [\n                ...renderEdgeLines(\n                    React,\n                    ableName,\n                    edge,\n                    moveable.state.renderPoses,\n                    moveable.props.zoom!,\n                ),\n                ...renderDiagonalDirections(moveable, ableName, React),\n            ];\n        }\n        return renderAllDirections(moveable, ableName, React);\n    };\n}\nexport function renderAllDirections(\n    moveable: MoveableManagerInterface<Partial<RenderDirections>>,\n    ableName: string,\n    React: Renderer,\n) {\n    return renderDirectionControls(moveable, DIRECTIONS, ableName, React);\n}\nexport function renderDiagonalDirections(\n    moveable: MoveableManagerInterface<Partial<RenderDirections>>,\n    ableName: string,\n    React: Renderer,\n): any[] {\n    return renderDirectionControls(moveable, [\"nw\", \"ne\", \"sw\", \"se\"], ableName, React);\n}\n","import {\n    setDragStart, getBeforeDragDist, getTransformDist,\n    convertTransformFormat, resolveTransformEvent, fillTransformStartEvent,\n    setDefaultTransformIndex, fillOriginalTransform,\n} from \"../gesto/GestoUtils\";\nimport {\n    triggerEvent, fillParams,\n    getDistSize, prefix,\n    fillEndParams, getComputedStyle,\n    fillCSSObject,\n} from \"../utils\";\nimport { minus, plus } from \"@scena/matrix\";\nimport {\n    DraggableProps, OnDrag, OnDragGroup,\n    OnDragGroupStart, OnDragStart, OnDragEnd, DraggableState,\n    Renderer, OnDragGroupEnd, MoveableManagerInterface, MoveableGroupInterface,\n} from \"../types\";\nimport { triggerChildGesto } from \"../groupUtils\";\nimport { startCheckSnapDrag } from \"./Snappable\";\nimport { IObject, getRad, throttle, throttleArray } from \"@daybrush/utils\";\nimport { checkSnapBoundsDrag } from \"./snappable/snapBounds\";\nimport { TINY_NUM } from \"../consts\";\n\n/**\n * @namespace Draggable\n * @memberof Moveable\n * @description Draggable refers to the ability to drag and move targets.\n */\nexport default {\n    name: \"draggable\",\n    props: {\n        draggable: Boolean,\n        throttleDrag: Number,\n        throttleDragRotate: Number,\n        startDragRotate: Number,\n        edgeDraggable: Boolean,\n    } as const,\n    events: {\n        onDragStart: \"dragStart\",\n        onDrag: \"drag\",\n        onDragEnd: \"dragEnd\",\n        onDragGroupStart: \"dragGroupStart\",\n        onDragGroup: \"dragGroup\",\n        onDragGroupEnd: \"dragGroupEnd\",\n    } as const,\n    render(\n        moveable: MoveableManagerInterface<DraggableProps, DraggableState>,\n        React: Renderer,\n    ): any[] {\n        const { throttleDragRotate, zoom } = moveable.props;\n        const { dragInfo, beforeOrigin } = moveable.state;\n\n        if (!throttleDragRotate || !dragInfo) {\n            return [];\n        }\n        const dist = dragInfo.dist;\n\n        if (!dist[0] && !dist[1]) {\n            return [];\n        }\n\n        const width = getDistSize(dist);\n        const rad = getRad(dist, [0, 0]);\n\n        return [<div className={prefix(\n            \"line\",\n            \"horizontal\",\n            \"dragline\",\n            \"dashed\",\n        )} key={`dragRotateGuideline`} style={{\n            width: `${width}px`,\n            transform: `translate(${beforeOrigin[0]}px, ${beforeOrigin[1]}px) rotate(${rad}rad) scaleY(${zoom})`,\n        }} />];\n    },\n    dragStart(\n        moveable: MoveableManagerInterface<DraggableProps, any>,\n        e: any,\n    ) {\n        const { datas, parentEvent, parentGesto } = e;\n        const state = moveable.state;\n        const {\n            target,\n            gestos,\n        } = state;\n\n        if (gestos.draggable) {\n            return false;\n        }\n        gestos.draggable = parentGesto || moveable.targetGesto;\n        const style = getComputedStyle(target!);\n\n        datas.datas = {};\n        datas.left = parseFloat(style.left || \"\") || 0;\n        datas.top = parseFloat(style.top || \"\") || 0;\n        datas.bottom = parseFloat(style.bottom || \"\") || 0;\n        datas.right = parseFloat(style.right || \"\") || 0;\n        datas.startValue = [0, 0];\n\n        setDragStart(moveable, e);\n        setDefaultTransformIndex(e, \"translate\");\n        startCheckSnapDrag(moveable, datas);\n\n        datas.prevDist = [0, 0];\n        datas.prevBeforeDist = [0, 0];\n        datas.isDrag = false;\n        datas.deltaOffset = [0, 0];\n\n        const params = fillParams<OnDragStart>(moveable, e, {\n            set: (translate: number[]) => {\n                datas.startValue = translate;\n            },\n            ...fillTransformStartEvent(e),\n        });\n        const result = parentEvent || triggerEvent(moveable, \"onDragStart\", params);\n\n        if (result !== false) {\n            datas.isDrag = true;\n            moveable.state.dragInfo = {\n                startRect: moveable.getRect(),\n                dist: [0, 0],\n            };\n        } else {\n            gestos.draggable = null;\n            datas.isPinch = false;\n        }\n        return datas.isDrag ? params : false;\n    },\n    drag(\n        moveable: MoveableManagerInterface<DraggableProps, any>,\n        e: any,\n    ): OnDrag | undefined {\n        if (!e) {\n            return;\n        }\n        resolveTransformEvent(e, \"translate\");\n\n        const { datas, parentEvent, parentFlag, isPinch, isRequest, deltaOffset } = e;\n        let { distX, distY } = e;\n        const { isDrag, prevDist, prevBeforeDist, startValue } = datas;\n\n        if (!isDrag) {\n            return;\n        }\n\n        if (deltaOffset) {\n            distX += deltaOffset[0];\n            distY += deltaOffset[1];\n        }\n        const props = moveable.props;\n\n        const parentMoveable = props.parentMoveable;\n        const throttleDrag = parentEvent ? 0 : (props.throttleDrag || 0);\n        const throttleDragRotate = parentEvent ? 0 : (props.throttleDragRotate || 0);\n\n        let isSnap = false;\n        let dragRotateRad = 0;\n\n        if (!parentEvent && throttleDragRotate > 0 && (distX || distY)) {\n            const startDragRotate = props.startDragRotate || 0;\n            const deg\n                = throttle(startDragRotate + getRad([0, 0], [distX, distY]) * 180 / Math.PI, throttleDragRotate)\n                - startDragRotate;\n            const ry = distY * Math.abs(Math.cos((deg - 90) / 180 * Math.PI));\n            const rx = distX * Math.abs(Math.cos(deg / 180 * Math.PI));\n            const r = getDistSize([rx, ry]);\n            dragRotateRad = deg * Math.PI / 180;\n\n            distX = r * Math.cos(dragRotateRad);\n            distY = r * Math.sin(dragRotateRad);\n        }\n\n        if (!isPinch && !parentEvent && !parentFlag && (!throttleDragRotate || distX || distY)) {\n            const [verticalInfo, horizontalInfo] = checkSnapBoundsDrag(\n                moveable, distX, distY, throttleDragRotate, isRequest || deltaOffset, datas,\n            );\n            const {\n                isSnap: isVerticalSnap,\n                isBound: isVerticalBound,\n                offset: verticalOffset,\n            } = verticalInfo;\n            const {\n                isSnap: isHorizontalSnap,\n                isBound: isHorizontalBound,\n                offset: horizontalOffset,\n            } = horizontalInfo;\n\n            isSnap = isVerticalSnap || isHorizontalSnap || isVerticalBound || isHorizontalBound;\n\n            distX += verticalOffset;\n            distY += horizontalOffset;\n        }\n\n        const beforeTranslate = plus(getBeforeDragDist({ datas, distX, distY }), startValue);\n        const translate = plus(getTransformDist({ datas, distX, distY }), startValue);\n\n        if (!throttleDragRotate && !isSnap) {\n            throttleArray(translate, throttleDrag);\n            throttleArray(beforeTranslate, throttleDrag);\n        }\n        throttleArray(translate, TINY_NUM);\n        throttleArray(beforeTranslate, TINY_NUM);\n\n        const beforeDist = minus(beforeTranslate, startValue);\n        const dist = minus(translate, startValue);\n        const delta = minus(dist, prevDist);\n        const beforeDelta = minus(beforeDist, prevBeforeDist);\n\n        datas.prevDist = dist;\n        datas.prevBeforeDist = beforeDist;\n\n\n        datas.passDelta = delta; //distX - (datas.passDistX || 0);\n        // datas.passDeltaY = distY - (datas.passDistY || 0);\n        datas.passDist = dist; //distX;\n        // datas.passDistY = distY;\n\n        const left = datas.left + beforeDist[0];\n        const top = datas.top + beforeDist[1];\n        const right = datas.right - beforeDist[0];\n        const bottom = datas.bottom - beforeDist[1];\n        const nextTransform = convertTransformFormat(datas,\n            `translate(${translate[0]}px, ${translate[1]}px)`, `translate(${dist[0]}px, ${dist[1]}px)`);\n\n        fillOriginalTransform(e, nextTransform);\n\n        moveable.state.dragInfo.dist = parentEvent ? [0, 0] : dist;\n        if (!parentEvent && !parentMoveable && delta.every(num => !num) && beforeDelta.some(num => !num)) {\n            return;\n        }\n\n        const {\n            width,\n            height,\n        } = moveable.state;\n        const params = fillParams<OnDrag>(moveable, e, {\n            transform: nextTransform,\n            dist,\n            delta,\n            translate,\n            beforeDist,\n            beforeDelta,\n            beforeTranslate,\n            left,\n            top,\n            right,\n            bottom,\n            width,\n            height,\n            isPinch,\n            ...fillCSSObject({\n                transform: nextTransform,\n            }, e),\n        });\n\n        !parentEvent && triggerEvent(moveable, \"onDrag\", params);\n        return params;\n    },\n    dragAfter(\n        moveable: MoveableManagerInterface<DraggableProps, DraggableState>,\n        e: any,\n    ) {\n        const datas = e.datas;\n        const {\n            deltaOffset,\n        } = datas;\n\n        if (deltaOffset[0] || deltaOffset[1]) {\n            datas.deltaOffset = [0, 0];\n            return this.drag(moveable, {...e, deltaOffset });\n        }\n        return false;\n    },\n    dragEnd(\n        moveable: MoveableManagerInterface<DraggableProps, DraggableState>,\n        e: any,\n    ) {\n        const { parentEvent, datas } = e;\n\n        moveable.state.dragInfo = null;\n        if (!datas.isDrag) {\n            return;\n        }\n        datas.isDrag = false;\n        const param = fillEndParams<OnDragEnd>(moveable, e, {});\n        !parentEvent && triggerEvent(moveable, \"onDragEnd\", param);\n        return param;\n    },\n    dragGroupStart(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas, clientX, clientY } = e;\n\n        const params = this.dragStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n        const events = triggerChildGesto(moveable, this, \"dragStart\", [\n            clientX || 0,\n            clientY || 0,\n        ], e, false, \"draggable\");\n\n        const nextParams: OnDragGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events,\n        };\n        const result = triggerEvent(moveable, \"onDragGroupStart\", nextParams);\n\n        datas.isDrag = result !== false;\n\n        return datas.isDrag ? params : false;\n    },\n    dragGroup(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas } = e;\n\n        if (!datas.isDrag) {\n            return;\n        }\n        const params = this.drag(moveable, e);\n        const { passDelta } = e.datas;\n        const events = triggerChildGesto(moveable, this, \"drag\", passDelta, e, false, \"draggable\");\n\n        if (!params) {\n            return;\n        }\n        const nextParams: OnDragGroup = {\n            targets: moveable.props.targets!,\n            events,\n            ...params,\n        };\n\n        triggerEvent(moveable, \"onDragGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupEnd(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isDrag) {\n            return;\n        }\n        this.dragEnd(moveable, e);\n        const events = triggerChildGesto(moveable, this, \"dragEnd\", [0, 0], e, false, \"draggable\");\n        triggerEvent(moveable, \"onDragGroupEnd\", fillEndParams<OnDragGroupEnd>(moveable, e, {\n            targets: moveable.props.targets!,\n            events,\n        }));\n\n        return isDrag;\n    },\n    /**\n     * @method Moveable.Draggable#request\n     * @param {object} [e] - the draggable's request parameter\n     * @param {number} [e.x] - x position\n     * @param {number} [e.y] - y position\n     * @param {number} [e.deltaX] - X number to move\n     * @param {number} [e.deltaY] - Y number to move\n     * @return {Moveable.Requester} Moveable Requester\n     * @example\n\n     * // Instantly Request (requestStart - request - requestEnd)\n     * // Use Relative Value\n     * moveable.request(\"draggable\", { deltaX: 10, deltaY: 10 }, true);\n     * // Use Absolute Value\n     * moveable.request(\"draggable\", { x: 200, y: 100 }, true);\n     *\n     * // requestStart\n     * const requester = moveable.request(\"draggable\");\n     *\n     * // request\n     * // Use Relative Value\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * // Use Absolute Value\n     * moveable.request(\"draggable\", { x: 200, y: 100 });\n     * moveable.request(\"draggable\", { x: 220, y: 100 });\n     * moveable.request(\"draggable\", { x: 240, y: 100 });\n     *\n     * // requestEnd\n     * requester.requestEnd();\n     */\n    request(moveable: MoveableManagerInterface<any, any>) {\n        const datas = {};\n        const rect = moveable.getRect();\n        let distX = 0;\n        let distY = 0;\n\n        return {\n            isControl: false,\n            requestStart() {\n                return { datas };\n            },\n            request(e: IObject<any>) {\n                if (\"x\" in e) {\n                    distX = e.x - rect.left;\n                } else if (\"deltaX\" in e) {\n                    distX += e.deltaX;\n                }\n                if (\"y\" in e) {\n                    distY = e.y - rect.top;\n                } else if (\"deltaY\" in e) {\n                    distY += e.deltaY;\n                }\n\n                return { datas, distX, distY };\n            },\n            requestEnd() {\n                return { datas, isDrag: true };\n            },\n        };\n    },\n    unset(moveable: any) {\n        moveable.state.dragInfo = null;\n    },\n};\n\n/**\n * Whether or not target can be dragged. (default: false)\n * @name Moveable.Draggable#draggable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.draggable = true;\n */\n\n/**\n * throttle of x, y when drag.\n * @name Moveable.Draggable#throttleDrag\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.throttleDrag = 1;\n */\n\n/**\n* throttle of angle of x, y when drag.\n* @name Moveable.Draggable#throttleDragRotate\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body);\n*\n* moveable.throttleDragRotate = 45;\n*/\n\n/**\n* start angle of throttleDragRotate of x, y when drag.\n* @name Moveable.Draggable#startDragRotate\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body);\n*\n* // 45, 135, 225, 315\n* moveable.throttleDragRotate = 90;\n* moveable.startDragRotate = 45;\n*/\n\n/**\n * When the drag starts, the dragStart event is called.\n * @memberof Moveable.Draggable\n * @event dragStart\n * @param {Moveable.Draggable.OnDragStart} - Parameters for the dragStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { draggable: true });\n * moveable.on(\"dragStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When dragging, the drag event is called.\n * @memberof Moveable.Draggable\n * @event drag\n * @param {Moveable.Draggable.OnDrag} - Parameters for the drag event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { draggable: true });\n * moveable.on(\"drag\", ({ target, transform }) => {\n *     target.style.transform = transform;\n * });\n */\n/**\n * When the drag finishes, the dragEnd event is called.\n * @memberof Moveable.Draggable\n * @event dragEnd\n * @param {Moveable.Draggable.OnDragEnd} - Parameters for the dragEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { draggable: true });\n * moveable.on(\"dragEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n/**\n* When the group drag starts, the `dragGroupStart` event is called.\n* @memberof Moveable.Draggable\n* @event dragGroupStart\n* @param {Moveable.Draggable.OnDragGroupStart} - Parameters for the `dragGroupStart` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     draggable: true\n* });\n* moveable.on(\"dragGroupStart\", ({ targets }) => {\n*     console.log(\"onDragGroupStart\", targets);\n* });\n*/\n\n/**\n* When the group drag, the `dragGroup` event is called.\n* @memberof Moveable.Draggable\n* @event dragGroup\n* @param {Moveable.Draggable.OnDragGroup} - Parameters for the `dragGroup` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     draggable: true\n* });\n* moveable.on(\"dragGroup\", ({ targets, events }) => {\n*     console.log(\"onDragGroup\", targets);\n*     events.forEach(ev => {\n*          // drag event\n*          console.log(\"onDrag left, top\", ev.left, ev.top);\n*          // ev.target!.style.left = `${ev.left}px`;\n*          // ev.target!.style.top = `${ev.top}px`;\n*          console.log(\"onDrag translate\", ev.dist);\n*          ev.target!.style.transform = ev.transform;)\n*     });\n* });\n*/\n\n/**\n * When the group drag finishes, the `dragGroupEnd` event is called.\n * @memberof Moveable.Draggable\n * @event dragGroupEnd\n * @param {Moveable.Draggable.OnDragGroupEnd} - Parameters for the `dragGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     draggable: true\n * });\n * moveable.on(\"dragGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onDragGroupEnd\", targets, isDrag);\n * });\n */\n","import {\n    getDirection, triggerEvent,\n    fillParams,\n    fillEndParams,\n    getAbsolutePosesByState,\n    catchEvent,\n    getOffsetSizeDist,\n    getProps,\n    getDirectionCondition,\n    calculatePoses,\n    fillAfterTransform,\n} from \"../utils\";\nimport {\n    setDragStart,\n    getResizeDist,\n    getAbsolutePosition,\n    getPosByDirection,\n    getNextMatrix,\n    getNextTransforms,\n} from \"../gesto/GestoUtils\";\nimport {\n    ResizableProps, OnResizeGroup, OnResizeGroupEnd,\n    OnResizeGroupStart, DraggableProps, OnDrag, OnResizeStart, SnappableState,\n    OnResize, OnResizeEnd, MoveableManagerInterface, MoveableGroupInterface, SnappableProps,\n    OnBeforeResize, OnBeforeResizeGroup, ResizableRequestParam,\n} from \"../types\";\nimport { getRenderDirections } from \"../renderDirections\";\nimport {\n    fillChildEvents,\n    triggerChildAbles,\n} from \"../groupUtils\";\nimport Draggable from \"./Draggable\";\nimport { calculate, convertDimension, createRotateMatrix, plus } from \"@scena/matrix\";\nimport CustomGesto, { setCustomDrag } from \"../gesto/CustomGesto\";\nimport { checkSnapResize } from \"./Snappable\";\nimport {\n    calculateBoundSize,\n    isString, convertUnitSize,\n    throttle,\n    isNumber,\n} from \"@daybrush/utils\";\nimport { TINY_NUM } from \"../consts\";\nimport { parseMat } from \"css-to-mat\";\n\n/**\n * @namespace Resizable\n * @memberof Moveable\n * @description Resizable indicates whether the target's width and height can be increased or decreased.\n */\n\nconst directionCondition = getDirectionCondition(\"resizable\");\n\nexport default {\n    name: \"resizable\",\n    ableGroup: \"size\",\n    canPinch: true,\n    props: {\n        resizable: Boolean,\n        throttleResize: Number,\n        renderDirections: Array,\n        keepRatio: Boolean,\n        resizeFormat: Function,\n        keepRatioFinally: Boolean,\n        edge: Boolean,\n    } as const,\n    events: {\n        onResizeStart: \"resizeStart\",\n        onBeforeResize: \"beforeResize\",\n        onResize: \"resize\",\n        onResizeEnd: \"resizeEnd\",\n\n        onResizeGroupStart: \"resizeGroupStart\",\n        onBeforeResizeGroup: \"beforeResizeGroup\",\n        onResizeGroup: \"resizeGroup\",\n        onResizeGroupEnd: \"resizeGroupEnd\",\n    } as const,\n    render: getRenderDirections(\"resizable\"),\n    dragControlCondition: directionCondition,\n    dragControlStart(\n        moveable: MoveableManagerInterface<ResizableProps & DraggableProps, SnappableState>,\n        e: any,\n    ) {\n        const {\n            inputEvent,\n            isPinch,\n            isGroup,\n            parentDirection,\n            parentGesto,\n            datas,\n            parentFixedDirection,\n            parentEvent,\n        } = e;\n\n        const direction = parentDirection || (isPinch ? [0, 0] : getDirection(inputEvent.target));\n        const state = moveable.state;\n        const { target, width, height, gestos } = state;\n\n        if (!direction || !target) {\n            return false;\n        }\n        if (gestos.resizable) {\n            return false;\n        }\n        gestos.resizable = parentGesto || moveable.controlGesto;\n        !isPinch && setDragStart(moveable, e);\n\n        datas.datas = {};\n        datas.direction = direction;\n        datas.startOffsetWidth = width;\n        datas.startOffsetHeight = height;\n        datas.prevWidth = 0;\n        datas.prevHeight = 0;\n\n        datas.minSize = [0, 0];\n        datas.startWidth = state.cssWidth;\n        datas.startHeight = state.cssHeight;\n        datas.maxSize = [Infinity, Infinity];\n\n        if (!isGroup) {\n            datas.minSize = [\n                state.minOffsetWidth,\n                state.minOffsetHeight,\n            ];\n            datas.maxSize = [\n                state.maxOffsetWidth,\n                state.maxOffsetHeight,\n            ];\n        }\n        const transformOrigin = moveable.props.transformOrigin || \"% %\";\n\n        datas.transformOrigin = transformOrigin && isString(transformOrigin)\n            ? transformOrigin.split(\" \")\n            : transformOrigin;\n\n        datas.startOffsetMatrix = state.offsetMatrix;\n        datas.startTransformOrigin = state.transformOrigin;\n\n        datas.isWidth = e?.parentIsWidth ?? ((!direction[0] && !direction[1]) || direction[0] || !direction[1]);\n\n        function setRatio(ratio: number) {\n            datas.ratio = ratio && isFinite(ratio) ? ratio : 0;\n        }\n\n\n        datas.startPositions = getAbsolutePosesByState(moveable.state);\n\n        function setFixedDirection(fixedDirection: number[]) {\n            datas.fixedDirection = fixedDirection;\n            datas.fixedPosition = getPosByDirection(datas.startPositions, fixedDirection);\n        }\n        function setMin(minSize: Array<string | number>)  {\n            datas.minSize = [\n                convertUnitSize(`${minSize[0]}`, 0) || 0,\n                convertUnitSize(`${minSize[1]}`, 0) || 0,\n            ];\n        }\n        function setMax(maxSize: Array<string | number>) {\n            const nextMaxSize = [\n                maxSize[0] || Infinity,\n                maxSize[1] || Infinity,\n            ];\n            if (!isNumber(nextMaxSize[0]) || isFinite(nextMaxSize[0])) {\n                nextMaxSize[0] = convertUnitSize(`${nextMaxSize[0]}`, 0) || Infinity;\n            }\n            if (!isNumber(nextMaxSize[1]) || isFinite(nextMaxSize[1])) {\n                nextMaxSize[1] = convertUnitSize(`${nextMaxSize[1]}`, 0) || Infinity;\n            }\n            datas.maxSize = nextMaxSize;\n        }\n\n        setRatio(width / height);\n        setFixedDirection(parentFixedDirection || [-direction[0], -direction[1]]);\n\n        datas.setFixedDirection = setFixedDirection;\n        datas.setMin = setMin;\n        datas.setMax = setMax;\n        const params = fillParams<OnResizeStart>(moveable, e, {\n            direction,\n            startRatio: datas.ratio,\n            set: ([startWidth, startHeight]: number[]) => {\n                datas.startWidth = startWidth;\n                datas.startHeight = startHeight;\n            },\n            setMin,\n            setMax,\n            setRatio,\n            setFixedDirection,\n            setOrigin: (origin: Array<string | number>) => {\n                datas.transformOrigin = origin;\n            },\n            dragStart: Draggable.dragStart(\n                moveable,\n                new CustomGesto().dragStart([0, 0], e),\n            ),\n        });\n        const result = parentEvent || triggerEvent(moveable, \"onResizeStart\", params);\n\n        datas.startFixedDirection = datas.fixedDirection;\n        if (result !== false) {\n            datas.isResize = true;\n            moveable.state.snapRenderInfo = {\n                request: e.isRequest,\n                direction,\n            };\n        }\n        return datas.isResize ? params : false;\n    },\n    dragControl(\n        moveable: MoveableManagerInterface<ResizableProps & DraggableProps & SnappableProps>,\n        e: any,\n    ) {\n        const {\n            datas,\n            parentFlag,\n            isPinch,\n            parentKeepRatio,\n            dragClient,\n            parentDist,\n            isRequest,\n            isGroup,\n            parentEvent,\n            resolveMatrix,\n        } = e;\n\n        const {\n            isResize,\n            transformOrigin,\n            startWidth,\n            startHeight,\n            prevWidth,\n            prevHeight,\n            minSize,\n            maxSize,\n            ratio,\n            startOffsetWidth,\n            startOffsetHeight,\n            isWidth,\n        } = datas;\n\n        if (!isResize) {\n            return;\n        }\n        if (resolveMatrix) {\n            const {\n                is3d,\n            } = moveable.state;\n            const {\n                startOffsetMatrix,\n                startTransformOrigin,\n            } = datas;\n            const n = is3d ? 4 : 3;\n            let targetMatrix = parseMat(getNextTransforms(e));\n            const targetN = Math.sqrt(targetMatrix.length);\n\n            if (n !== targetN) {\n                targetMatrix = convertDimension(targetMatrix, targetN, n);\n            }\n\n            const nextAllMatrix = getNextMatrix(\n                startOffsetMatrix,\n                targetMatrix,\n                startTransformOrigin,\n                n,\n            );\n            const poses = calculatePoses(nextAllMatrix, startOffsetWidth, startOffsetHeight, n);\n\n            datas.startPositions = poses;\n            datas.nextTargetMatrix = targetMatrix;\n            datas.nextAllMatrix = nextAllMatrix;\n        }\n        const props = getProps(moveable.props, \"resizable\");\n        const {\n            resizeFormat,\n            throttleResize = parentFlag ? 0 : 1,\n            parentMoveable,\n            keepRatioFinally,\n        } = props;\n        const direction = datas.direction;\n        let sizeDirection = direction;\n        let distWidth = 0;\n        let distHeight = 0;\n\n        if (!direction[0] && !direction[1]) {\n            sizeDirection = [1, 1];\n        }\n        const keepRatio = (ratio && (parentKeepRatio != null ? parentKeepRatio : props.keepRatio)) || false;\n\n        function getNextBoundingSize() {\n            const fixedDirection = datas.fixedDirection;\n            const nextSize = getOffsetSizeDist(sizeDirection, keepRatio, datas, e);\n\n            distWidth = nextSize.distWidth;\n            distHeight = nextSize.distHeight;\n\n            let nextWidth = (sizeDirection[0] - fixedDirection[0]) || keepRatio\n                ? Math.max(startOffsetWidth + distWidth, TINY_NUM) : startOffsetWidth;\n            let nextHeight = (sizeDirection[1] - fixedDirection[1]) || keepRatio\n                ? Math.max(startOffsetHeight + distHeight, TINY_NUM) : startOffsetHeight;\n\n            if (keepRatio && startOffsetWidth && startOffsetHeight) {\n                // startOffsetWidth : startOffsetHeight = nextWidth : nextHeight\n                if (isWidth) {\n                    nextHeight = nextWidth / ratio;\n                } else {\n                    nextWidth = nextHeight * ratio;\n                }\n            }\n            return [nextWidth, nextHeight];\n        }\n\n        let [boundingWidth, boundingHeight] = getNextBoundingSize();\n\n        if (!parentEvent) {\n            datas.setFixedDirection(datas.fixedDirection);\n\n            triggerEvent(moveable, \"onBeforeResize\", fillParams<OnBeforeResize>(moveable, e, {\n                startFixedDirection: datas.startFixedDirection,\n                setFixedDirection(nextFixedDirection: number[]) {\n                    datas.setFixedDirection(nextFixedDirection);\n\n                    [boundingWidth, boundingHeight] = getNextBoundingSize();\n\n                    return [boundingWidth, boundingHeight];\n                },\n                boundingWidth,\n                boundingHeight,\n                setSize(size: number[]) {\n                    [boundingWidth, boundingHeight] = size;\n                },\n            }, true));\n        }\n\n        let fixedPosition = dragClient;\n\n        if (!dragClient) {\n            if (!parentFlag && isPinch) {\n                fixedPosition = getAbsolutePosition(moveable, [0, 0]);\n            } else {\n                fixedPosition = datas.fixedPosition;\n            }\n        }\n\n        let snapDist = [0, 0];\n\n        if (!isPinch) {\n            snapDist = checkSnapResize(\n                moveable,\n                boundingWidth,\n                boundingHeight,\n                direction,\n                fixedPosition,\n                isRequest,\n                datas,\n            );\n        }\n        if (parentDist) {\n            !parentDist[0] && (snapDist[0] = 0);\n            !parentDist[1] && (snapDist[1] = 0);\n        }\n\n        function computeSize() {\n            if (resizeFormat) {\n                [boundingWidth, boundingHeight] = resizeFormat([boundingWidth, boundingHeight]);\n            }\n            boundingWidth = throttle(boundingWidth, throttleResize!);\n            boundingHeight = throttle(boundingHeight, throttleResize!);\n        }\n        if (keepRatio) {\n            if (sizeDirection[0] && sizeDirection[1] && snapDist[0] && snapDist[1]) {\n                if (Math.abs(snapDist[0]) > Math.abs(snapDist[1])) {\n                    snapDist[1] = 0;\n                } else {\n                    snapDist[0] = 0;\n                }\n            }\n            const isNoSnap = !snapDist[0] && !snapDist[1];\n\n            if (isNoSnap) {\n                // pre-compute before maintaining the ratio\n                computeSize();\n            }\n            if (\n                (sizeDirection[0] && !sizeDirection[1])\n                || (snapDist[0] && !snapDist[1])\n                || (isNoSnap && isWidth)\n            ) {\n                boundingWidth += snapDist[0];\n                boundingHeight = boundingWidth / ratio;\n            } else if (\n                (!sizeDirection[0] && sizeDirection[1])\n                || (!snapDist[0] && snapDist[1])\n                || (isNoSnap && !isWidth)\n            ) {\n                boundingHeight += snapDist[1];\n                boundingWidth = boundingHeight * ratio;\n            }\n        } else {\n            boundingWidth += snapDist[0];\n            boundingHeight += snapDist[1];\n\n            boundingWidth = Math.max(0, boundingWidth);\n            boundingHeight = Math.max(0, boundingHeight);\n        }\n\n        [boundingWidth, boundingHeight] = calculateBoundSize(\n            [boundingWidth, boundingHeight],\n            minSize,\n            maxSize,\n            keepRatio ? ratio : false,\n        );\n        computeSize();\n\n        if (keepRatio && (isGroup || keepRatioFinally)) {\n            if (isWidth) {\n                boundingHeight = boundingWidth / ratio;\n            } else {\n                boundingWidth = boundingHeight * ratio;\n            }\n        }\n        distWidth = boundingWidth - startOffsetWidth;\n        distHeight = boundingHeight - startOffsetHeight;\n\n        const delta = [distWidth - prevWidth, distHeight - prevHeight];\n\n        datas.prevWidth = distWidth;\n        datas.prevHeight = distHeight;\n\n        const inverseDelta = getResizeDist(\n            moveable,\n            boundingWidth,\n            boundingHeight,\n            fixedPosition,\n            transformOrigin,\n            datas,\n        );\n\n        if (!parentMoveable && delta.every(num => !num) && inverseDelta.every(num => !num)) {\n            return;\n        }\n        const drag = Draggable.drag(\n            moveable,\n            setCustomDrag(e, moveable.state, inverseDelta, !!isPinch, false, \"draggable\"),\n        ) as OnDrag;\n        const transform = drag.transform;\n\n        const nextWidth = startWidth + distWidth;\n        const nextHeight = startHeight + distHeight;\n\n        const params = fillParams<OnResize>(moveable, e, {\n            width: nextWidth,\n            height: nextHeight,\n            offsetWidth: Math.round(boundingWidth),\n            offsetHeight: Math.round(boundingHeight),\n            startRatio: ratio,\n            boundingWidth,\n            boundingHeight,\n            direction,\n            dist: [distWidth, distHeight],\n            delta,\n            isPinch: !!isPinch,\n            drag,\n            ...fillAfterTransform({\n                style: {\n                    width: `${nextWidth}px`,\n                    height: `${nextHeight}px`,\n                },\n                transform,\n            }, drag, e),\n        });\n        !parentEvent && triggerEvent(moveable, \"onResize\", params);\n        return params;\n    },\n    dragControlAfter(\n        moveable: MoveableManagerInterface<ResizableProps & DraggableProps>,\n        e: any,\n    ) {\n        const datas = e.datas;\n        const {\n            isResize,\n            startOffsetWidth,\n            startOffsetHeight,\n            prevWidth,\n            prevHeight,\n        } = datas;\n\n        if (!isResize) {\n            return;\n        }\n        const {\n            width,\n            height,\n        } = moveable.state;\n        const errorWidth = width - (startOffsetWidth + prevWidth);\n        const errorHeight = height - (startOffsetHeight + prevHeight);\n        const isErrorWidth = Math.abs(errorWidth) > 3;\n        const isErrorHeight = Math.abs(errorHeight) > 3;\n\n        if (isErrorWidth) {\n            datas.startWidth += errorWidth;\n            datas.startOffsetWidth += errorWidth;\n            datas.prevWidth += errorWidth;\n        }\n        if (isErrorHeight) {\n            datas.startHeight += errorHeight;\n            datas.startOffsetHeight += errorHeight;\n            datas.prevHeight += errorHeight;\n        }\n        if (isErrorWidth || isErrorHeight) {\n            return this.dragControl(moveable, e);\n        }\n    },\n    dragControlEnd(\n        moveable: MoveableManagerInterface<ResizableProps & DraggableProps>,\n        e: any,\n    ) {\n        const { datas, parentEvent } = e;\n        if (!datas.isResize) {\n            return;\n        }\n        datas.isResize = false;\n\n        const params = fillEndParams<OnResizeEnd>(moveable, e, {});\n        !parentEvent && triggerEvent(moveable, \"onResizeEnd\", params);\n        return params;\n    },\n    dragGroupControlCondition: directionCondition,\n    dragGroupControlStart(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas } = e;\n        const params = this.dragControlStart(moveable, {...e, isGroup: true });\n\n        if (!params) {\n            return false;\n        }\n        const originalEvents = fillChildEvents(moveable, \"resizable\", e);\n        function setDist(child: MoveableManagerInterface, ev: any) {\n            const fixedDirection = datas.fixedDirection;\n            const fixedPosition = datas.fixedPosition;\n\n            const startPositions = ev.datas.startPositions || getAbsolutePosesByState(child.state);\n            const pos = getPosByDirection(startPositions, fixedDirection);\n            const [originalX, originalY] = calculate(\n                createRotateMatrix(-moveable.rotation / 180 * Math.PI, 3),\n                [pos[0] - fixedPosition[0], pos[1] - fixedPosition[1], 1],\n                3,\n            );\n            ev.datas.originalX = originalX;\n            ev.datas.originalY = originalY;\n\n            return ev;\n        }\n        const {\n            startOffsetWidth: parentStartOffsetWidth,\n            startOffsetHeight: parentStartOffsetHeight,\n        } = datas;\n\n        function updateGroupMin() {\n            const originalMinSize = datas.minSize;\n            originalEvents.forEach(ev => {\n                const {\n                    minSize: childMinSize,\n                    startOffsetWidth: childStartOffsetWidth,\n                    startOffsetHeight: childStartOffsetHeight,\n                } = ev.datas;\n\n                const parentMinWidth = parentStartOffsetWidth\n                    * (childStartOffsetWidth ? childMinSize[0] / childStartOffsetWidth : 0);\n                const parentMinHeight = parentStartOffsetHeight\n                    * (childStartOffsetHeight ? childMinSize[1] / childStartOffsetHeight : 0);\n\n                originalMinSize[0] = Math.max(originalMinSize[0], parentMinWidth);\n                originalMinSize[1] = Math.max(originalMinSize[1], parentMinHeight);\n            });\n        }\n\n        function updateGroupMax() {\n            const originalMaxSize = datas.maxSize;\n            originalEvents.forEach(ev => {\n                const {\n                    maxSize: childMaxSize,\n                    startOffsetWidth: childStartOffsetWidth,\n                    startOffsetHeight: childStartOffsetHeight,\n                } = ev.datas;\n\n                const parentMaxWidth = parentStartOffsetWidth\n                    * (childStartOffsetWidth ? childMaxSize[0] / childStartOffsetWidth : 0);\n                const parentMaxHeight = parentStartOffsetHeight\n                    * (childStartOffsetHeight ? childMaxSize[1] / childStartOffsetHeight : 0);\n\n                originalMaxSize[0] = Math.min(originalMaxSize[0], parentMaxWidth);\n                originalMaxSize[1] = Math.min(originalMaxSize[1], parentMaxHeight);\n            });\n        }\n        const events = triggerChildAbles(\n            moveable,\n            this,\n            \"dragControlStart\",\n            e,\n            (child, ev) => {\n                return setDist(child, ev);\n            },\n        );\n\n\n        updateGroupMin();\n        updateGroupMax();\n\n        const setFixedDirection = (fixedDirection: number[]) => {\n            params.setFixedDirection(fixedDirection);\n            events.forEach((ev, i) => {\n                ev.setFixedDirection(fixedDirection);\n                setDist(ev.moveable, originalEvents[i]);\n            });\n        };\n\n        datas.setFixedDirection = setFixedDirection;\n\n        const nextParams: OnResizeGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events: events.map(ev => {\n                return {\n                    ...ev,\n                    setMin: (minSize: Array<number | string>) => {\n                        ev.setMin(minSize);\n                        updateGroupMin();\n                    },\n                    setMax: (maxSize: Array<number | string>) => {\n                        ev.setMax(maxSize);\n                        updateGroupMax();\n                    },\n                };\n            }),\n            setFixedDirection,\n            setMin: (minSize: Array<number | string>) => {\n                params.setMin(minSize);\n                updateGroupMin();\n            },\n            setMax: (maxSize: Array<number | string>) => {\n                params.setMax(maxSize);\n                updateGroupMax();\n            },\n        };\n        const result = triggerEvent(moveable, \"onResizeGroupStart\", nextParams);\n\n        datas.isResize = result !== false;\n        return datas.isResize ? params : false;\n    },\n    dragGroupControl(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas } = e;\n        if (!datas.isResize) {\n            return;\n        }\n        const props = getProps(moveable.props, \"resizable\");\n\n        catchEvent(moveable, \"onBeforeResize\", parentEvent => {\n            triggerEvent(moveable, \"onBeforeResizeGroup\", fillParams<OnBeforeResizeGroup>(moveable, e, {\n                ...parentEvent,\n                targets: props.targets!,\n            }, true));\n        });\n\n\n        const params = this.dragControl(moveable, {...e, isGroup: true });\n\n        if (!params) {\n            return;\n        }\n        const {\n            boundingWidth,\n            boundingHeight,\n            dist,\n        } = params;\n\n        const keepRatio = props.keepRatio;\n\n        const parentScale = [\n            boundingWidth / (boundingWidth - dist[0]),\n            boundingHeight / (boundingHeight - dist[1]),\n        ];\n        const fixedPosition = datas.fixedPosition;\n\n        const events = triggerChildAbles(\n            moveable,\n            this,\n            \"dragControl\",\n            e,\n            (_, ev) => {\n                const [clientX, clientY] = calculate(\n                    createRotateMatrix(moveable.rotation / 180 * Math.PI, 3),\n                    [\n                        ev.datas.originalX * parentScale[0],\n                        ev.datas.originalY * parentScale[1],\n                        1,\n                    ],\n                    3,\n                );\n\n                return {\n                    ...ev,\n                    parentDist: null,\n                    parentScale,\n                    dragClient: plus(fixedPosition, [clientX, clientY]),\n                    parentKeepRatio: keepRatio,\n                };\n            },\n        );\n        const nextParams: OnResizeGroup = {\n            targets: props.targets!,\n            events,\n            ...params,\n        };\n\n        triggerEvent(moveable, \"onResizeGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupControlEnd(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isResize) {\n            return;\n        }\n\n        this.dragControlEnd(moveable, e);\n        const events = triggerChildAbles(moveable, this, \"dragControlEnd\", e);\n\n        const nextParams: OnResizeGroupEnd = fillEndParams<OnResizeGroupEnd>(moveable, e, {\n            targets: moveable.props.targets!,\n            events,\n        });\n\n        triggerEvent(moveable, \"onResizeGroupEnd\", nextParams);\n        return isDrag;\n    },\n    /**\n     * @method Moveable.Resizable#request\n     * @param {Moveable.Resizable.ResizableRequestParam} e - the Resizable's request parameter\n     * @return {Moveable.Requester} Moveable Requester\n     * @example\n\n     * // Instantly Request (requestStart - request - requestEnd)\n     * // Use Relative Value\n     * moveable.request(\"resizable\", { deltaWidth: 10, deltaHeight: 10 }, true);\n     *\n     * // Use Absolute Value\n     * moveable.request(\"resizable\", { offsetWidth: 100, offsetHeight: 100 }, true);\n     *\n     * // requestStart\n     * const requester = moveable.request(\"resizable\");\n     *\n     * // request\n     * // Use Relative Value\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     *\n     * // Use Absolute Value\n     * moveable.request(\"resizable\", { offsetWidth: 100, offsetHeight: 100 });\n     * moveable.request(\"resizable\", { offsetWidth: 110, offsetHeight: 100 });\n     * moveable.request(\"resizable\", { offsetWidth: 120, offsetHeight: 100 });\n     *\n     * // requestEnd\n     * requester.requestEnd();\n     */\n    request(moveable: MoveableManagerInterface<any>) {\n        const datas: Record<string, any> = {};\n        let distWidth = 0;\n        let distHeight = 0;\n        const rect = moveable.getRect();\n\n        return {\n            isControl: true,\n            requestStart(e: ResizableRequestParam) {\n                return { datas, parentDirection: e.direction || [1, 1], parentIsWidth: e?.horizontal ?? true };\n            },\n            request(e: ResizableRequestParam) {\n                if (\"offsetWidth\" in e) {\n                    distWidth = e.offsetWidth! - rect.offsetWidth;\n                } else if (\"deltaWidth\" in e) {\n                    distWidth += e.deltaWidth!;\n                }\n                if (\"offsetHeight\" in e) {\n                    distHeight = e.offsetHeight! - rect.offsetHeight;\n                } else if (\"deltaHeight\" in e) {\n                    distHeight += e.deltaHeight!;\n                }\n\n\n                return { datas, parentDist: [distWidth, distHeight], parentKeepRatio: e.keepRatio };\n            },\n            requestEnd() {\n                return { datas, isDrag: true };\n            },\n        };\n    },\n};\n\n/**\n * Whether or not target can be resized.\n * @name Moveable.Resizable#resizable\n * @default false\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     resizable: false,\n * });\n *\n * moveable.resizable = true;\n */\n\n/**\n * throttle of width, height when resize. If throttleResize is set to less than 1, the target may shake.\n * @name Moveable.Resizable#throttleResize\n * @default 1\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   resizable: true,\n *   throttleResize: 1,\n * });\n *\n * moveable.throttleResize = 0;\n */\n/**\n * When resize or scale, keeps a ratio of the width, height.\n * @name Moveable.Resizable#keepRatio\n * @default false\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   resizable: true,\n * });\n *\n * moveable.keepRatio = true;\n */\n/**\n * Set directions to show the control box.\n * @name Moveable.Resizable#renderDirections\n * @default [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"]\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   resizable: true,\n *   renderDirections: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"],\n * });\n *\n * moveable.renderDirections = [\"nw\", \"ne\", \"sw\", \"se\"];\n */\n\n/**\n * Function to convert size for resize\n * @name Moveable.Resizable#resizeFormat\n * @default oneself\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   resizable: true,\n *   resizeFormat: v => v,\n * });\n *\n * moveable.resizeFormat = (size: number[]) => ([Math.trunc(size[0]), Math.trunc(size[1])];\n */\n\n/**\n * When the resize starts, the resizeStart event is called.\n * @memberof Moveable.Resizable\n * @event resizeStart\n * @param {Moveable.Resizable.OnResizeStart} - Parameters for the resizeStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { resizable: true });\n * moveable.on(\"resizeStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n\n/**\n * When resizing, `beforeResize` is called before `resize` occurs. In `beforeResize`, you can get and set the pre-value before resizing.\n * @memberof Moveable.Resizable\n * @event beforeResize\n * @param {Moveable.Resizable.OnBeforeResize} - Parameters for the `beforeResize` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { resizable: true });\n * moveable.on(\"beforeResize\", ({ setFixedDirection }) => {\n *     if (shiftKey) {\n *        setFixedDirection([0, 0]);\n *     }\n * });\n * moveable.on(\"resize\", ({ target, width, height, drag }) => {\n *     target.style.width = `${width}px`;\n *     target.style.height = `${height}px`;\n *     target.style.transform = drag.transform;\n * });\n */\n\n/**\n * When resizing, the resize event is called.\n * @memberof Moveable.Resizable\n * @event resize\n * @param {Moveable.Resizable.OnResize} - Parameters for the resize event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { resizable: true });\n * moveable.on(\"resize\", ({ target, width, height }) => {\n *     target.style.width = `${e.width}px`;\n *     target.style.height = `${e.height}px`;\n * });\n */\n/**\n * When the resize finishes, the resizeEnd event is called.\n * @memberof Moveable.Resizable\n * @event resizeEnd\n * @param {Moveable.Resizable.OnResizeEnd} - Parameters for the resizeEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { resizable: true });\n * moveable.on(\"resizeEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n/**\n* When the group resize starts, the `resizeGroupStart` event is called.\n* @memberof Moveable.Resizable\n* @event resizeGroupStart\n* @param {Moveable.Resizable.OnResizeGroupStart} - Parameters for the `resizeGroupStart` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     resizable: true\n* });\n* moveable.on(\"resizeGroupStart\", ({ targets }) => {\n*     console.log(\"onResizeGroupStart\", targets);\n* });\n*/\n\n/**\n* When the group resize, the `resizeGroup` event is called.\n* @memberof Moveable.Resizable\n* @event resizeGroup\n* @param {Moveable.Resizable.onResizeGroup} - Parameters for the `resizeGroup` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     resizable: true\n* });\n* moveable.on(\"resizeGroup\", ({ targets, events }) => {\n*     console.log(\"onResizeGroup\", targets);\n*     events.forEach(ev => {\n*         const offset = [\n*             direction[0] < 0 ? -ev.delta[0] : 0,\n*             direction[1] < 0 ? -ev.delta[1] : 0,\n*         ];\n*         // ev.drag is a drag event that occurs when the group resize.\n*         const left = offset[0] + ev.drag.beforeDist[0];\n*         const top = offset[1] + ev.drag.beforeDist[1];\n*         const width = ev.width;\n*         const top = ev.top;\n*     });\n* });\n*/\n\n/**\n * When the group resize finishes, the `resizeGroupEnd` event is called.\n * @memberof Moveable.Resizable\n * @event resizeGroupEnd\n * @param {Moveable.Resizable.OnResizeGroupEnd} - Parameters for the `resizeGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     resizable: true\n * });\n * moveable.on(\"resizeGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onResizeGroupEnd\", targets, isDrag);\n * });\n */\n","import {\n    prefix, triggerEvent, fillParams,\n    calculatePosition, fillEndParams, getRotationRad, getRefTargets,\n    catchEvent, getProps, calculateMoveableClientPositions,\n    fillAfterTransform,\n} from \"../utils\";\nimport {\n    IObject, hasClass, getRad,\n    throttle,\n    getDist,\n    getKeys,\n    isArray,\n} from \"@daybrush/utils\";\nimport {\n    RotatableProps, OnRotateGroup, OnRotateGroupEnd,\n    Renderer, OnRotateGroupStart, OnRotateStart, OnRotate,\n    OnRotateEnd, MoveableClientRect, SnappableProps,\n    SnappableState, MoveableManagerInterface, MoveableGroupInterface, DraggableProps,\n    OnBeforeRotate,\n    OnBeforeRotateGroup,\n    OnResizeStart,\n    OnResize,\n    TransformObject,\n    OnDragStart,\n} from \"../types\";\nimport { triggerChildAbles } from \"../groupUtils\";\nimport { calculate, convertPositionMatrix, getOrigin, minus, plus, rotate as rotateMatrix } from \"@scena/matrix\";\nimport CustomGesto, { setCustomDrag } from \"../gesto/CustomGesto\";\nimport { checkSnapRotate } from \"./Snappable\";\nimport {\n    fillTransformStartEvent,\n    convertTransformFormat, getRotateDist,\n    getOriginDirection,\n    getDirectionOffset,\n    fillTransformEvent,\n    setDefaultTransformIndex,\n    resolveTransformEvent,\n    getTransformDirection,\n    getPosByDirection,\n} from \"../gesto/GestoUtils\";\nimport { DirectionControlInfo, renderAroundControls, renderDirectionControlsByInfos } from \"../renderDirections\";\nimport { DIRECTIONS, DIRECTION_REGION_TO_DIRECTION } from \"../consts\";\nimport Resizable from \"./Resizable\";\nimport Draggable from \"./Draggable\";\n\n/**\n * @namespace Rotatable\n * @memberof Moveable\n * @description Rotatable indicates whether the target can be rotated.\n */\n\nfunction setRotateStartInfo(\n    moveable: MoveableManagerInterface<any, any>,\n    datas: IObject<any>, clientX: number, clientY: number,\n    rect: MoveableClientRect,\n) {\n    const groupable = moveable.props.groupable;\n    const state = moveable.state;\n    const n = state.is3d ? 4 : 3;\n    const origin = datas.origin;\n    const nextOrigin = calculatePosition(\n        moveable.state.rootMatrix,\n        // TO-DO #710\n        minus([origin[0], origin[1]], groupable ? [0, 0] : [state.left, state.top]),\n        n,\n    );\n    const startAbsoluteOrigin = plus([rect.left, rect.top], nextOrigin);\n\n    datas.startAbsoluteOrigin = startAbsoluteOrigin;\n    datas.prevDeg = getRad(startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180;\n    datas.defaultDeg = datas.prevDeg;\n    datas.prevSnapDeg = 0;\n    datas.loop = 0;\n    datas.startDist = getDist(startAbsoluteOrigin, [clientX, clientY]);\n}\n\nfunction getAbsoluteDist(\n    deg: number,\n    direction: number,\n    datas: IObject<any>,\n) {\n    const {\n        defaultDeg,\n        prevDeg,\n    } = datas;\n\n\n    let normalizedPrevDeg = prevDeg % 360;\n    let loop = Math.floor(prevDeg / 360);\n\n    if (normalizedPrevDeg < 0) {\n        normalizedPrevDeg += 360;\n    }\n\n    if (normalizedPrevDeg > deg && normalizedPrevDeg > 270 && deg < 90) {\n        // 360 => 0\n        ++loop;\n    } else if (normalizedPrevDeg < deg && normalizedPrevDeg < 90 && deg > 270) {\n        // 0 => 360\n        --loop;\n    }\n    const dist = direction * (loop * 360 + deg - defaultDeg);\n\n    datas.prevDeg = defaultDeg + dist;\n\n    return dist;\n}\nfunction getAbsoluteDistByClient(\n    clientX: number, clientY: number,\n    direction: number,\n    datas: IObject<any>,\n) {\n    return getAbsoluteDist(\n        getRad(datas.startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180,\n        direction,\n        datas,\n    );\n}\nfunction getRotateInfo(\n    moveable: MoveableManagerInterface<any, any>,\n    moveableRect: any,\n    datas: IObject<any>,\n    dist: number,\n    startValue: number,\n    isSnap?: boolean,\n) {\n    const {\n        throttleRotate = 0,\n    } = moveable.props;\n    let nextDist = dist;\n\n    const prevSnapDeg = datas.prevSnapDeg;\n\n\n\n    if (isSnap) {\n        nextDist = checkSnapRotate(moveable, moveableRect, datas.origin, nextDist);\n    }\n\n    const snapRotation = throttle(startValue + nextDist, throttleRotate);\n    const snapDeg = snapRotation - startValue;\n\n    datas.prevSnapDeg = snapDeg;\n\n    return [snapDeg - prevSnapDeg, nextDist, snapRotation];\n\n\n}\n\nexport function getReversePositionX(dir: string) {\n    if (dir === \"left\") {\n        return \"right\";\n    } else if (dir === \"right\") {\n        return \"left\";\n    }\n    return dir;\n}\nexport function getReversePositionY(dir: string) {\n    if (dir === \"top\") {\n        return \"bottom\";\n    } else if (dir === \"bottom\") {\n        return \"top\";\n    }\n    return dir;\n}\nexport function getRotationPositions(\n    rotationPosition: RotatableProps[\"rotationPosition\"],\n    [pos1, pos2, pos3, pos4]: number[][],\n    direction: number,\n) {\n    if (rotationPosition === \"none\") {\n        return;\n    }\n    const [dir1, dir2] = (rotationPosition || \"top\").split(\"-\");\n    let radPoses = [pos1, pos2];\n\n    // if (scale[0] < 0) {\n    //     dir1 = getReversePositionX(dir1);\n    //     dir2 = getReversePositionX(dir2);\n    // }\n    // if (scale[1] < 0) {\n    //     dir1 = getReversePositionY(dir1);\n    //     dir2 = getReversePositionY(dir2);\n    // }\n    if (dir1 === \"left\") {\n        radPoses = [pos3, pos1];\n    } else if (dir1 === \"right\") {\n        radPoses = [pos2, pos4];\n    } else if (dir1 === \"bottom\") {\n        radPoses = [pos4, pos3];\n    }\n    let pos = [\n        (radPoses[0][0] + radPoses[1][0]) / 2,\n        (radPoses[0][1] + radPoses[1][1]) / 2,\n    ];\n    const rad = getRotationRad(radPoses, direction);\n    if (dir2) {\n        const isStart = dir2 === \"top\" || dir2 === \"left\";\n        const isReverse = dir1 === \"bottom\" || dir1 === \"left\";\n\n        pos = radPoses[(isStart && !isReverse) || (!isStart && isReverse) ? 0 : 1];\n    }\n    return [pos, rad] as const;\n}\n\nexport function dragControlCondition(moveable: MoveableManagerInterface<RotatableProps>, e: any) {\n    if (e.isRequest) {\n        return e.requestAble === \"rotatable\";\n    }\n    const target = e.inputEvent.target as HTMLElement;\n    if (\n        hasClass(target, prefix(\"rotation-control\"))\n        || hasClass(target, prefix(\"around-control\"))\n        || (hasClass(target, prefix(\"control\")) && hasClass(target, prefix(\"rotatable\")))\n    ) {\n        return true;\n    }\n    const rotationTarget = moveable.props.rotationTarget;\n\n    if (rotationTarget) {\n        return getRefTargets(rotationTarget, true).some(element => {\n            if (!element) {\n                return false;\n            }\n            return target === element || target.contains(element);\n        });\n    }\n    return false;\n}\n\nconst directionCSS = DIRECTIONS.map(dir => {\n    let top = \"\";\n    let left = \"\";\n    let originX = \"center\";\n    let originY = \"center\";\n\n    if (dir.indexOf(\"n\") > -1) {\n        top = \"top: -20px;\";\n        originY = \"bottom\";\n    }\n    if (dir.indexOf(\"s\") > -1) {\n        top = \"top: 0px;\";\n        originY = \"top\";\n    }\n    if (dir.indexOf(\"w\") > -1) {\n        left = \"left: -20px;\";\n        originX = \"right\";\n    }\n    if (dir.indexOf(\"e\") > -1) {\n        left = \"left: 0px;\";\n        originX = \"left\";\n    }\n    return `.around-control[data-direction*=\"${dir}\"] {\n        ${left}${top}\n        transform-origin: ${originX} ${originY};\n    }`;\n}).join(\"\\n\");\nconst css = `.rotation {\n    position: absolute;\n    height: 40px;\n    width: 1px;\n    transform-origin: 50% 100%;\n    height: calc(40px * var(--zoom));\n    top: auto;\n    left: 0;\n    bottom: 100%;\n    will-change: transform;\n}\n.rotation .rotation-line {\n    display: block;\n    width: 100%;\n    height: 100%;\n    transform-origin: 50% 50%;\n}\n.rotation .rotation-control {\n    border-color: #4af;\n    border-color: var(--moveable-color);\n    background:#fff;\n    cursor: alias;\n}\n.rotatable.direction.control {\n    cursor: alias;\n}\n.around-control {\n    position: absolute;\n    will-change: transform;\n    width: 20px;\n    height: 20px;\n    left: -10px;\n    top: -10px;\n    box-sizing: border-box;\n    background: transparent;\n    z-index: 8;\n    cursor: alias;\n    transform-origin: center center;\n}\n.rotatable.direction.control.move {\n    cursor: move;\n}\n${directionCSS}\n`;\nexport default {\n    name: \"rotatable\",\n    canPinch: true,\n    props: {\n        rotatable: Boolean,\n        rotationPosition: String,\n        throttleRotate: Number,\n        renderDirections: Object,\n        rotationTarget: Object,\n        rotateAroundControls: Boolean,\n        edge: Boolean,\n        resolveAblesWithRotatable: Object,\n    } as const,\n    events: {\n        onRotateStart: \"rotateStart\",\n        onBeforeRotate: \"beforeRotate\",\n        onRotate: \"rotate\",\n        onRotateEnd: \"rotateEnd\",\n        onRotateGroupStart: \"rotateGroupStart\",\n        onBeforeRotateGroup: \"beforeRotateGroup\",\n        onRotateGroup: \"rotateGroup\",\n        onRotateGroupEnd: \"rotateGroupEnd\",\n    } as const,\n    css: [css],\n    render(moveable: MoveableManagerInterface<RotatableProps>, React: Renderer): any {\n        const {\n            rotatable,\n            rotationPosition,\n            zoom,\n            renderDirections,\n            rotateAroundControls,\n            resolveAblesWithRotatable,\n        } = getProps(moveable.props, \"rotatable\");\n        const {\n            renderPoses,\n            direction,\n        } = moveable.state;\n        if (!rotatable) {\n            return null;\n        }\n        const positions = getRotationPositions(rotationPosition!, renderPoses, direction);\n\n        const jsxs = [];\n\n        if (positions) {\n            const [pos, rad] = positions;\n            jsxs.push(\n                <div key=\"rotation\" className={prefix(\"rotation\")} style={{\n                    // tslint:disable-next-line: max-line-length\n                    transform: `translate(-50%) translate(${pos[0]}px, ${pos[1]}px) rotate(${rad}rad)`,\n                }}>\n                    <div className={prefix(\"line rotation-line\")} style={{\n                        transform: `scaleX(${zoom})`,\n                    }}></div>\n                    <div className={prefix(\"control rotation-control\")} style={{\n                        transform: `translate(0.5px) scale(${zoom})`,\n                    }}></div>\n                </div>\n            );\n        }\n        if (renderDirections) {\n            const ables = getKeys(resolveAblesWithRotatable || {});\n            const resolveMap: Record<string, string> = {};\n\n            ables.forEach(name => {\n                resolveAblesWithRotatable![name]!.forEach(direction => {\n                    resolveMap[direction] = name;\n                });\n            });\n\n            let directionControlInfos: DirectionControlInfo[] = [];\n\n            if (isArray(renderDirections)) {\n                directionControlInfos = renderDirections.map(dir => {\n                    const able = resolveMap[dir];\n\n                    return {\n                        data: able ? { resolve: able } : {},\n                        classNames: able ? [`move`] : [],\n                        dir,\n                    };\n                });\n            }\n\n            jsxs.push(...renderDirectionControlsByInfos(\n                moveable,\n                \"rotatable\",\n                directionControlInfos,\n                React,\n            ));\n        }\n        if (rotateAroundControls) {\n            jsxs.push(...renderAroundControls(moveable, React));\n        }\n\n        return jsxs;\n    },\n    dragControlCondition: dragControlCondition as (moveable: any, e: any) => boolean,\n    dragControlStart(\n        moveable: MoveableManagerInterface<RotatableProps & SnappableProps & DraggableProps, SnappableState>,\n        e: any) {\n        const {\n            datas,\n            clientX, clientY,\n            parentRotate, parentFlag, isPinch,\n            isRequest,\n        } = e;\n        const state = moveable.state;\n        const {\n            target, left, top,\n            direction, beforeDirection, targetTransform,\n            moveableClientRect,\n            offsetMatrix,\n            targetMatrix,\n            allMatrix,\n            width,\n            height,\n        } = state;\n\n        if (!isRequest && !target) {\n            return false;\n        }\n\n        const rect = moveable.getRect();\n        datas.rect = rect;\n        datas.transform = targetTransform;\n        datas.left = left;\n        datas.top = top;\n        let setFixedDirection: OnRotateStart[\"setFixedDirection\"] = (fixedDirection: number[]) => {\n            datas.fixedDirection = fixedDirection;\n            datas.fixedPosition = getDirectionOffset(moveable, fixedDirection);\n\n            if (resizeStart) {\n                resizeStart.setFixedDirection(fixedDirection);\n            }\n        };\n        let startClientX = clientX;\n        let startClientY = clientY;\n\n        if (isRequest || isPinch || parentFlag) {\n            const externalRotate = parentRotate || 0;\n\n            datas.beforeInfo = {\n                origin: rect.beforeOrigin,\n                prevDeg: externalRotate,\n                defaultDeg: externalRotate,\n                prevSnapDeg: 0,\n                startDist: 0,\n            };\n            datas.afterInfo = {\n                ...datas.beforeInfo,\n                origin: rect.origin,\n            };\n            datas.absoluteInfo = {\n                ...datas.beforeInfo,\n                origin: rect.origin,\n                startValue: externalRotate,\n            };\n        } else {\n            const inputTarget = e.inputEvent?.target;\n\n            if (inputTarget) {\n                const regionDirection = inputTarget.getAttribute(\"data-direction\") || \"\";\n                const controlDirection = DIRECTION_REGION_TO_DIRECTION[regionDirection];\n\n                if (controlDirection) {\n                    datas.isControl = true;\n                    datas.isAroundControl = hasClass(inputTarget, prefix(\"around-control\"));\n                    datas.controlDirection = controlDirection;\n                    const resolve = inputTarget.getAttribute(\"data-resolve\");\n\n                    if (resolve) {\n                        datas.resolveAble = resolve;\n                    }\n\n                    const clientPoses = calculateMoveableClientPositions(\n                        state.rootMatrix,\n                        state.renderPoses,\n                        moveableClientRect,\n                    );\n\n\n                    [startClientX, startClientY] = getPosByDirection(clientPoses, controlDirection);\n                }\n            }\n\n\n            datas.beforeInfo = { origin: rect.beforeOrigin };\n            datas.afterInfo = { origin: rect.origin };\n            datas.absoluteInfo = {\n                origin: rect.origin,\n                startValue: rect.rotation,\n            };\n\n            const originalFixedDirection = setFixedDirection;\n\n            setFixedDirection = (fixedDirection: number[]) => {\n                const n = state.is3d ? 4 : 3;\n                const originalPosition = getPosByDirection([\n                    [0, 0],\n                    [width, 0],\n                    [0, height],\n                    [width, height],\n                ], fixedDirection);\n                const [originX, originY] = plus(getOrigin(targetMatrix, n), originalPosition);\n                const fixedBeforeOrigin = calculate(\n                    offsetMatrix,\n                    convertPositionMatrix([originX, originY], n),\n                );\n                const fixedAfterOrigin = calculate(\n                    allMatrix,\n                    convertPositionMatrix([originalPosition[0], originalPosition[1]], n),\n                );\n                originalFixedDirection(fixedDirection);\n\n                datas.beforeInfo.origin = fixedBeforeOrigin;\n                datas.afterInfo.origin = fixedAfterOrigin;\n                datas.absoluteInfo.origin = fixedAfterOrigin;\n\n                setRotateStartInfo(moveable, datas.beforeInfo, startClientX, startClientY, moveableClientRect);\n                setRotateStartInfo(moveable, datas.afterInfo, startClientX, startClientY, moveableClientRect);\n                setRotateStartInfo(moveable, datas.absoluteInfo, startClientX, startClientY, moveableClientRect);\n            };\n        }\n\n        datas.startClientX = startClientX;\n        datas.startClientY = startClientY;\n        datas.direction = direction;\n        datas.beforeDirection = beforeDirection;\n        datas.startValue = 0;\n        datas.datas = {};\n\n        setDefaultTransformIndex(e, \"rotate\");\n\n        let dragStart: OnDragStart | false = false;\n        let resizeStart: OnResizeStart | false = false;\n\n\n\n        if (datas.isControl && datas.resolveAble) {\n            const resolveAble = datas.resolveAble;\n\n            if  (resolveAble === \"resizable\") {\n                resizeStart = Resizable.dragControlStart(moveable, {\n                    ...(new CustomGesto(\"resizable\").dragStart([0, 0], e)),\n                    parentDirection: datas.controlDirection,\n                    parentFixedDirection: datas.fixedDirection,\n                });\n            }\n        }\n\n        if (!resizeStart) {\n            dragStart = Draggable.dragStart!(\n                moveable,\n                new CustomGesto().dragStart([0, 0], e),\n            );\n        }\n\n        setFixedDirection(getOriginDirection(moveable));\n        const params = fillParams<OnRotateStart>(moveable, e, {\n            set: (rotatation: number) => {\n                datas.startValue = rotatation * Math.PI / 180;\n            },\n            setFixedDirection,\n            ...fillTransformStartEvent(e),\n            dragStart,\n            resizeStart,\n        });\n        const result = triggerEvent(moveable, \"onRotateStart\", params);\n        datas.isRotate = result !== false;\n        state.snapRenderInfo = {\n            request: e.isRequest,\n        };\n\n        return datas.isRotate ? params : false;\n    },\n    dragControl(\n        moveable: MoveableManagerInterface<RotatableProps & DraggableProps>,\n        e: any,\n    ) {\n        const { datas, distX, distY, parentRotate, parentFlag, isPinch, groupDelta } = e;\n        const {\n            beforeDirection,\n            beforeInfo,\n            afterInfo,\n            absoluteInfo,\n            isRotate,\n            startValue,\n            rect,\n            startClientX,\n            startClientY,\n        } = datas;\n\n        if (!isRotate) {\n            return;\n        }\n\n        resolveTransformEvent(e, \"rotate\");\n\n        const targetDirection = getTransformDirection(e);\n        const direction = beforeDirection * targetDirection;\n        const {\n            parentMoveable,\n        } = moveable.props;\n\n\n        let beforeDelta = 0;\n        let beforeDist: number;\n        let beforeRotation: number;\n\n        let delta = 0;\n        let dist: number;\n        let rotation: number;\n\n        let absoluteDelta = 0;\n        let absoluteDist: number;\n        let absoluteRotation: number;\n\n        const startRotation = 180 / Math.PI * startValue;\n        const absoluteStartRotation = absoluteInfo.startValue;\n        let isSnap = false;\n        const nextClientX = startClientX + distX;\n        const nextClientY = startClientY + distY;\n\n        if (!parentFlag && \"parentDist\" in e) {\n            const parentDist = e.parentDist;\n\n            beforeDist = parentDist;\n            dist = parentDist;\n            absoluteDist = parentDist;\n        } else if (isPinch || parentFlag) {\n            beforeDist = getAbsoluteDist(parentRotate, beforeDirection, beforeInfo);\n            dist = getAbsoluteDist(parentRotate, direction, afterInfo);\n            absoluteDist = getAbsoluteDist(parentRotate, direction, absoluteInfo);\n        } else {\n            beforeDist = getAbsoluteDistByClient(nextClientX, nextClientY, beforeDirection, beforeInfo);\n            dist = getAbsoluteDistByClient(nextClientX, nextClientY, direction, afterInfo);\n            absoluteDist = getAbsoluteDistByClient(nextClientX, nextClientY, direction, absoluteInfo);\n            isSnap = true;\n        }\n        beforeRotation = startRotation + beforeDist;\n        rotation = startRotation + dist;\n        absoluteRotation = absoluteStartRotation + absoluteDist;\n\n\n        triggerEvent(moveable, \"onBeforeRotate\", fillParams<OnBeforeRotate>(moveable, e, {\n            beforeRotation,\n            rotation,\n            absoluteRotation,\n            setRotation(nextRotation: number) {\n                dist = nextRotation - startRotation;\n                beforeDist = dist;\n                absoluteDist = dist;\n            },\n        }, true));\n        [\n            beforeDelta,\n            beforeDist,\n            beforeRotation,\n        ] = getRotateInfo(moveable, rect, beforeInfo, beforeDist, startRotation, isSnap);\n\n        [\n            delta,\n            dist,\n            rotation,\n        ] = getRotateInfo(moveable, rect, afterInfo, dist, startRotation, isSnap);\n\n        [\n            absoluteDelta,\n            absoluteDist,\n            absoluteRotation,\n        ] = getRotateInfo(moveable, rect, absoluteInfo, absoluteDist, absoluteStartRotation, isSnap);\n\n        if (!absoluteDelta && !delta && !beforeDelta && !parentMoveable) {\n            return;\n        }\n\n        const nextTransform = convertTransformFormat(\n            datas, `rotate(${rotation}deg)`, `rotate(${dist}deg)`,\n        );\n\n        const inverseDist = getRotateDist(moveable, dist, datas);\n        const inverseDelta = minus(\n            plus(groupDelta || [0, 0], inverseDist),\n            datas.prevInverseDist || [0, 0],\n        );\n        datas.prevInverseDist = inverseDist;\n\n        datas.requestValue = null;\n\n        const dragEvent = fillTransformEvent(\n            moveable,\n            nextTransform,\n            inverseDelta,\n            isPinch,\n            e,\n        );\n\n        let transformEvent: TransformObject = dragEvent;\n        const parentDistance = getDist(\n            [nextClientX, nextClientY],\n            absoluteInfo.startAbsoluteOrigin,\n        ) - absoluteInfo.startDist;\n\n        let resize: OnResize | undefined = undefined;\n\n        if (datas.resolveAble === \"resizable\") {\n            const resizeEvent = Resizable.dragControl(\n                moveable,\n                {\n                    ...setCustomDrag(e, moveable.state, [e.deltaX, e.deltaY], !!isPinch, false, \"resizable\"),\n                    resolveMatrix: true,\n                    parentDistance,\n                },\n            );\n\n            if (resizeEvent) {\n                resize = resizeEvent;\n                transformEvent = fillAfterTransform(transformEvent, resizeEvent, e);\n            }\n        }\n\n        const params = fillParams<OnRotate>(moveable, e, {\n            delta,\n            dist,\n            rotate: rotation,\n            rotation,\n\n            beforeDist,\n            beforeDelta,\n            beforeRotate: beforeRotation,\n            beforeRotation,\n\n            absoluteDist,\n            absoluteDelta,\n            absoluteRotate: absoluteRotation,\n            absoluteRotation,\n\n            isPinch: !!isPinch,\n            resize,\n            ...dragEvent,\n            ...transformEvent,\n        });\n        triggerEvent(moveable, \"onRotate\", params);\n\n        return params;\n    },\n    dragControlAfter(moveable: MoveableManagerInterface<RotatableProps>, e: any) {\n        const requestValue = e.datas.requestValue;\n\n        if (requestValue != null) {\n            // return this.dragControl(moveable, {...e, parentDist: });\n        }\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<RotatableProps>, e: any) {\n        const { datas } = e;\n\n        if (!datas.isRotate) {\n            return;\n        }\n        datas.isRotate = false;\n\n        const params = fillEndParams<OnRotateEnd>(moveable, e, {});\n\n        triggerEvent(moveable, \"onRotateEnd\", params);\n        return params;\n    },\n    dragGroupControlCondition: dragControlCondition as (moveable: any, e: any) => boolean,\n    dragGroupControlStart(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas } = e;\n        const {\n            left: parentLeft,\n            top: parentTop,\n            beforeOrigin: parentBeforeOrigin,\n        } = moveable.state;\n\n        const params = this.dragControlStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n\n        params.set(datas.beforeDirection * moveable.rotation);\n\n        const events = triggerChildAbles(\n            moveable,\n            this,\n            \"dragControlStart\",\n            e,\n            (child, ev) => {\n                const { left, top, beforeOrigin } = child.state;\n                const childClient = plus(\n                    minus([left, top], [parentLeft, parentTop]),\n                    minus(beforeOrigin, parentBeforeOrigin),\n                );\n\n                ev.datas.groupClient = childClient;\n                return { ...ev, parentRotate: 0 };\n            },\n        );\n\n        const nextParams: OnRotateGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events,\n        };\n        const result = triggerEvent(moveable, \"onRotateGroupStart\", nextParams);\n\n        datas.isRotate = result !== false;\n\n        return datas.isRotate ? params : false;\n    },\n    dragGroupControl(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas } = e;\n\n        if (!datas.isRotate) {\n            return;\n        }\n\n        catchEvent(moveable, \"onBeforeRotate\", parentEvent => {\n            triggerEvent(moveable, \"onBeforeRotateGroup\", fillParams<OnBeforeRotateGroup>(moveable, e, {\n                ...parentEvent,\n                targets: moveable.props.targets!,\n            }, true));\n        });\n        const params = this.dragControl(moveable, e);\n\n        if (!params) {\n            return;\n        }\n        const direction = datas.beforeDirection;\n        const parentRotate = params.beforeDist;\n        const deg = params.beforeDelta;\n        const rad = deg / 180 * Math.PI;\n\n        const events = triggerChildAbles(\n            moveable,\n            this,\n            \"dragControl\",\n            e,\n            (_, ev) => {\n                const [prevX, prevY] = ev.datas.groupClient;\n                const [clientX, clientY] = rotateMatrix([prevX, prevY], rad * direction);\n                const delta = [clientX - prevX, clientY - prevY];\n\n                ev.datas.groupClient = [clientX, clientY];\n                return { ...ev, parentRotate, groupDelta: delta };\n            },\n        );\n        moveable.rotation = direction * params.beforeRotation;\n\n        const nextParams: OnRotateGroup = {\n            targets: moveable.props.targets!,\n            events,\n            set(rotation: number) {\n                moveable.rotation = rotation;\n            },\n            setGroupRotation(rotation: number) {\n                moveable.rotation = rotation;\n            },\n            ...params,\n        };\n\n        triggerEvent(moveable, \"onRotateGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupControlEnd(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isRotate) {\n            return;\n        }\n\n        this.dragControlEnd(moveable, e);\n        const events = triggerChildAbles(moveable, this, \"dragControlEnd\", e);\n\n        const nextParams = fillEndParams<OnRotateGroupEnd>(moveable, e, {\n            targets: moveable.props.targets!,\n            events,\n        });\n\n        triggerEvent(moveable, \"onRotateGroupEnd\", nextParams);\n        return isDrag;\n    },\n    /**\n     * @method Moveable.Rotatable#request\n     * @param {object} [e] - the Resizable's request parameter\n     * @param {number} [e.deltaRotate=0] -  delta number of rotation\n     * @param {number} [e.rotate=0] - absolute number of moveable's rotation\n     * @return {Moveable.Requester} Moveable Requester\n     * @example\n\n     * // Instantly Request (requestStart - request - requestEnd)\n     * moveable.request(\"rotatable\", { deltaRotate: 10 }, true);\n     *\n     * * moveable.request(\"rotatable\", { rotate: 10 }, true);\n     *\n     * // requestStart\n     * const requester = moveable.request(\"rotatable\");\n     *\n     * // request\n     * requester.request({ deltaRotate: 10 });\n     * requester.request({ deltaRotate: 10 });\n     * requester.request({ deltaRotate: 10 });\n     *\n     * requester.request({ rotate: 10 });\n     * requester.request({ rotate: 20 });\n     * requester.request({ rotate: 30 });\n     *\n     * // requestEnd\n     * requester.requestEnd();\n     */\n    request(moveable: MoveableManagerInterface<RotatableProps>) {\n        const datas = {};\n        let distRotate = 0;\n\n        const startRotation = moveable.getRotation();\n        return {\n            isControl: true,\n            requestStart() {\n                return { datas };\n            },\n            request(e: IObject<any>) {\n                if (\"deltaRotate\" in e) {\n                    distRotate += e.deltaRotate;\n                } else if (\"rotate\" in e) {\n                    distRotate = e.rotate - startRotation;\n                }\n\n                return { datas, parentDist: distRotate };\n            },\n            requestEnd() {\n                return { datas, isDrag: true };\n            },\n        };\n    },\n};\n/**\n * Whether or not target can be rotated. (default: false)\n * @name Moveable.Rotatable#rotatable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.rotatable = true;\n */\n/**\n * You can specify the position of the rotation. (default: \"top\")\n * @name Moveable.Rotatable#rotationPosition\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   rotationPosition: \"top\",\n * });\n *\n * moveable.rotationPosition = \"bottom\"\n */\n\n/**\n * throttle of angle(degree) when rotate.\n * @name Moveable.Rotatable#throttleRotate\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.throttleRotate = 1;\n */\n\n/**\n * When the rotate starts, the rotateStart event is called.\n * @memberof Moveable.Rotatable\n * @event rotateStart\n * @param {Moveable.Rotatable.OnRotateStart} - Parameters for the rotateStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { rotatable: true });\n * moveable.on(\"rotateStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n\n/**\n* When rotating, the rotate event is called.\n* @memberof Moveable.Rotatable\n* @event rotate\n* @param {Moveable.Rotatable.OnRotate} - Parameters for the rotate event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, { rotatable: true });\n* moveable.on(\"rotate\", ({ target, transform, dist }) => {\n*     target.style.transform = transform;\n* });\n*/\n/**\n * When the rotate finishes, the rotateEnd event is called.\n * @memberof Moveable.Rotatable\n * @event rotateEnd\n * @param {Moveable.Rotatable.OnRotateEnd} - Parameters for the rotateEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { rotatable: true });\n * moveable.on(\"rotateEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n/**\n * When the group rotate starts, the `rotateGroupStart` event is called.\n * @memberof Moveable.Rotatable\n * @event rotateGroupStart\n * @param {Moveable.Rotatable.OnRotateGroupStart} - Parameters for the `rotateGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     rotatable: true\n * });\n * moveable.on(\"rotateGroupStart\", ({ targets }) => {\n *     console.log(\"onRotateGroupStart\", targets);\n * });\n */\n\n/**\n* When the group rotate, the `rotateGroup` event is called.\n* @memberof Moveable.Rotatable\n* @event rotateGroup\n* @param {Moveable.Rotatable.OnRotateGroup} - Parameters for the `rotateGroup` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     rotatable: true\n* });\n* moveable.on(\"rotateGroup\", ({ targets, events }) => {\n*     console.log(\"onRotateGroup\", targets);\n*     events.forEach(ev => {\n*         const target = ev.target;\n*         // ev.drag is a drag event that occurs when the group rotate.\n*         const left = ev.drag.beforeDist[0];\n*         const top = ev.drag.beforeDist[1];\n*         const deg = ev.beforeDist;\n*     });\n* });\n*/\n\n/**\n * When the group rotate finishes, the `rotateGroupEnd` event is called.\n * @memberof Moveable.Rotatable\n * @event rotateGroupEnd\n * @param {Moveable.Rotatable.OnRotateGroupEnd} - Parameters for the `rotateGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     rotatable: true\n * });\n * moveable.on(\"rotateGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onRotateGroupEnd\", targets, isDrag);\n * });\n */\n","import {\n    getDirection, triggerEvent, multiply2,\n    fillParams, fillEndParams, getAbsolutePosesByState, catchEvent, getOffsetSizeDist, getDirectionCondition,\n} from \"../utils\";\nimport { MIN_SCALE } from \"../consts\";\nimport {\n    setDragStart, resolveTransformEvent,\n    convertTransformFormat,\n    getScaleDist,\n    fillTransformStartEvent,\n    fillTransformEvent,\n    getAbsolutePosition,\n    setDefaultTransformIndex,\n    getPosByDirection,\n} from \"../gesto/GestoUtils\";\nimport { getRenderDirections } from \"../renderDirections\";\nimport {\n    ScalableProps, OnScaleGroup, OnScaleGroupEnd,\n    OnScaleGroupStart, DraggableProps, OnDragStart,\n    SnappableState, GroupableProps, OnScaleStart,\n    OnScale, OnScaleEnd, MoveableManagerInterface, MoveableGroupInterface,\n    OnBeforeScaleGroup,\n    OnBeforeScale,\n} from \"../types\";\nimport {\n    fillChildEvents,\n    triggerChildAbles,\n} from \"../groupUtils\";\nimport Draggable from \"./Draggable\";\nimport { calculate, createRotateMatrix, plus, minus } from \"@scena/matrix\";\nimport CustomGesto from \"../gesto/CustomGesto\";\nimport { checkSnapScale } from \"./Snappable\";\nimport {\n    isArray, IObject, getDist,\n    throttle,\n} from \"@daybrush/utils\";\n\nconst directionCondition = getDirectionCondition(\"scalable\");\n\n/**\n * @namespace Scalable\n * @memberof Moveable\n * @description Scalable indicates whether the target's x and y can be scale of transform.\n */\nexport default {\n    name: \"scalable\",\n    ableGroup: \"size\",\n    canPinch: true,\n    props: {\n        scalable: Boolean,\n        throttleScale: Number,\n        renderDirections: String,\n        keepRatio: Boolean,\n        edge: Boolean,\n    } as const,\n    events: {\n        onScaleStart: \"scaleStart\",\n        onBeforeScale: \"beforeScale\",\n        onScale: \"scale\",\n        onScaleEnd: \"scaleEnd\",\n        onScaleGroupStart: \"scaleGroupStart\",\n        onBeforeScaleGroup: \"beforeScaleGroup\",\n        onScaleGroup: \"scaleGroup\",\n        onScaleGroupEnd: \"scaleGroupEnd\",\n    } as const,\n    render: getRenderDirections(\"scalable\"),\n    dragControlCondition: directionCondition,\n    dragControlStart(\n        moveable: MoveableManagerInterface<ScalableProps & DraggableProps, SnappableState>,\n        e: any) {\n        const { datas, isPinch, inputEvent, parentDirection } = e;\n        const direction = parentDirection || (isPinch ? [0, 0] : getDirection(inputEvent.target));\n        const {\n            width,\n            height,\n            targetTransform,\n            target,\n            pos1,\n            pos2,\n            pos4,\n        } = moveable.state;\n\n        if (!direction || !target) {\n            return false;\n        }\n        if (!isPinch) {\n            setDragStart(moveable, e);\n        }\n        datas.datas = {};\n        datas.transform = targetTransform;\n        datas.prevDist = [1, 1];\n        datas.direction = direction;\n        datas.startOffsetWidth = width;\n        datas.startOffsetHeight = height;\n        datas.startValue = [1, 1];\n\n        const scaleWidth = getDist(pos1, pos2);\n        const scaleHeight = getDist(pos2, pos4);\n        const isWidth = (!direction[0] && !direction[1]) || direction[0] || !direction[1];\n\n\n        datas.scaleWidth = scaleWidth;\n        datas.scaleHeight = scaleHeight;\n        datas.scaleXRatio = scaleWidth / width;\n        datas.scaleYRatio = scaleHeight / height;\n\n        setDefaultTransformIndex(e, \"scale\");\n\n\n\n        datas.isWidth = isWidth;\n\n\n        function setRatio(ratio: number) {\n            datas.ratio = ratio && isFinite(ratio) ? ratio : 0;\n        }\n\n        datas.startPositions = getAbsolutePosesByState(moveable.state);\n        function setFixedDirection(fixedDirection: number[]) {\n            datas.fixedDirection = fixedDirection;\n            datas.fixedPosition = getPosByDirection(datas.startPositions, fixedDirection);\n        }\n\n\n        datas.setFixedDirection = setFixedDirection;\n        setRatio(getDist(pos1, pos2) / getDist(pos2, pos4));\n        setFixedDirection([-direction[0], -direction[1]]);\n\n        const params = fillParams<OnScaleStart>(moveable, e, {\n            direction,\n            set: (scale: number[]) => {\n                datas.startValue = scale;\n            },\n            setRatio,\n            setFixedDirection,\n            ...fillTransformStartEvent(e),\n            dragStart: Draggable.dragStart(\n                moveable,\n                new CustomGesto().dragStart([0, 0], e),\n            ) as OnDragStart,\n        });\n        const result = triggerEvent(moveable, \"onScaleStart\", params);\n\n        datas.startFixedDirection = datas.fixedDirection;\n\n        if (result !== false) {\n            datas.isScale = true;\n            moveable.state.snapRenderInfo = {\n                request: e.isRequest,\n                direction,\n            };\n\n        }\n        return datas.isScale ? params : false;\n    },\n    dragControl(\n        moveable: MoveableManagerInterface<ScalableProps & DraggableProps & GroupableProps, SnappableState>,\n        e: any) {\n        resolveTransformEvent(e, \"scale\");\n        const {\n            datas,\n            parentKeepRatio,\n            parentFlag, isPinch,\n            dragClient,\n            isRequest,\n        } = e;\n        const {\n            prevDist,\n            direction,\n            startOffsetWidth,\n            startOffsetHeight,\n            isScale,\n            startValue,\n            isWidth,\n            ratio,\n        } = datas;\n\n        if (!isScale) {\n            return false;\n        }\n\n        const props = moveable.props;\n        const {\n            throttleScale,\n            parentMoveable,\n        } = props;\n        let sizeDirection = direction;\n\n        if (!direction[0] && !direction[1]) {\n            sizeDirection = [1, 1];\n        }\n        const keepRatio = (ratio && (parentKeepRatio != null ? parentKeepRatio : props.keepRatio)) || false;\n        const state = moveable.state;\n\n        function getNextScale() {\n            const {\n                distWidth,\n                distHeight,\n            } = getOffsetSizeDist(sizeDirection, keepRatio, datas, e);\n\n\n            let scaleX = (startOffsetWidth + distWidth) / startOffsetWidth;\n            let scaleY = (startOffsetHeight + distHeight) / startOffsetHeight;\n\n            scaleX = sizeDirection[0] || keepRatio ? scaleX * startValue[0] : startValue[0];\n            scaleY = sizeDirection[1] || keepRatio ? scaleY * startValue[1] : startValue[1];\n\n            if (scaleX === 0) {\n                scaleX = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;\n            }\n            if (scaleY === 0) {\n                scaleY = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;\n            }\n            return [scaleX, scaleY];\n        }\n\n\n        let scale = getNextScale();\n\n        if (!isPinch && moveable.props.groupable) {\n            const snapRenderInfo = state.snapRenderInfo || {};\n            const stateDirection = snapRenderInfo.direction;\n\n            if (isArray(stateDirection) && (stateDirection[0] || stateDirection[1])) {\n                state.snapRenderInfo = { direction, request: e.isRequest };\n            }\n        }\n\n        triggerEvent(moveable, \"onBeforeScale\", fillParams<OnBeforeScale>(moveable, e, {\n            scale,\n            setFixedDirection(nextFixedDirection: number[]) {\n                datas.setFixedDirection(nextFixedDirection);\n\n                scale = getNextScale();\n\n                return scale;\n            },\n            startFixedDirection: datas.startFixedDirection,\n            setScale(nextScale: number[]) {\n                scale = nextScale;\n            },\n        }, true));\n\n        const dist = [scale[0] / startValue[0], scale[1] / startValue[1]];\n        let fixedPosition = dragClient;\n        let snapDist = [0, 0];\n\n\n        if (!dragClient) {\n            if (!parentFlag && isPinch) {\n                fixedPosition = getAbsolutePosition(moveable, [0, 0]);\n            } else {\n                fixedPosition = datas.fixedPosition;\n            }\n        }\n        if (!isPinch) {\n            snapDist = checkSnapScale(\n                moveable,\n                dist,\n                direction,\n                isRequest,\n                datas,\n            );\n        }\n\n        if (keepRatio) {\n            if (sizeDirection[0] && sizeDirection[1] && snapDist[0] && snapDist[1]) {\n                if (Math.abs(snapDist[0] * startOffsetWidth) > Math.abs(snapDist[1] * startOffsetHeight)) {\n                    snapDist[1] = 0;\n                } else {\n                    snapDist[0] = 0;\n                }\n            }\n\n            const isNoSnap = !snapDist[0] && !snapDist[1];\n\n            if (isNoSnap) {\n                if (isWidth) {\n                    dist[0] = throttle(dist[0] * startValue[0], throttleScale!) / startValue[0];\n                } else {\n                    dist[1] = throttle(dist[1] * startValue[1], throttleScale!) / startValue[1];\n                }\n            }\n            if (\n                (sizeDirection[0] && !sizeDirection[1])\n                || (snapDist[0] && !snapDist[1])\n                || (isNoSnap && isWidth)\n            ) {\n                dist[0] += snapDist[0];\n                const snapHeight = startOffsetWidth * dist[0] * startValue[0] / ratio;\n\n                dist[1] = snapHeight / startOffsetHeight / startValue[1];\n            } else if (\n                (!sizeDirection[0] && sizeDirection[1])\n                || (!snapDist[0] && snapDist[1])\n                || (isNoSnap && !isWidth)\n            ) {\n                dist[1] += snapDist[1];\n                const snapWidth = startOffsetHeight * dist[1] * startValue[1] * ratio;\n\n                dist[0] = snapWidth / startOffsetWidth / startValue[0];\n            }\n        } else {\n            dist[0] += snapDist[0];\n            dist[1] += snapDist[1];\n            if (!snapDist[0]) {\n                dist[0] = throttle(dist[0] * startValue[0], throttleScale!) / startValue[0];\n            }\n            if (!snapDist[1]) {\n                dist[1] = throttle(dist[1] * startValue[1], throttleScale!) / startValue[1];\n            }\n        }\n\n        if (dist[0] === 0) {\n            dist[0] = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;\n        }\n        if (dist[1] === 0) {\n            dist[1] = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;\n        }\n        const delta = [dist[0] / prevDist[0], dist[1] / prevDist[1]];\n        scale = multiply2(dist, startValue);\n\n        const inverseDist = getScaleDist(moveable, dist, datas.fixedDirection, fixedPosition, datas);\n        const inverseDelta = minus(inverseDist, datas.prevInverseDist || [0, 0]);\n\n        datas.prevDist = dist;\n        datas.prevInverseDist = inverseDist;\n        if (\n            scale[0] === prevDist[0] && scale[1] === prevDist[1]\n            && inverseDelta.every(num => !num)\n            && !parentMoveable\n        ) {\n            return false;\n        }\n\n\n        const nextTransform = convertTransformFormat(\n            datas, `scale(${scale.join(\", \")})`, `scale(${dist.join(\", \")})`);\n        const params = fillParams<OnScale>(moveable, e, {\n            offsetWidth: startOffsetWidth,\n            offsetHeight: startOffsetHeight,\n            direction,\n\n            scale,\n            dist,\n            delta,\n\n            isPinch: !!isPinch,\n            ...fillTransformEvent(\n                moveable,\n                nextTransform,\n                inverseDelta,\n                isPinch,\n                e,\n            ),\n        });\n        triggerEvent(moveable, \"onScale\", params);\n\n        return params;\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<ScalableProps>, e: any) {\n        const { datas, isDrag } = e;\n        if (!datas.isScale) {\n            return false;\n        }\n\n        datas.isScale = false;\n\n        triggerEvent(moveable, \"onScaleEnd\", fillEndParams<OnScaleEnd>(moveable, e, {}));\n        return isDrag;\n    },\n    dragGroupControlCondition: directionCondition,\n    dragGroupControlStart(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas } = e;\n\n        const params = this.dragControlStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n        const originalEvents = fillChildEvents(moveable, \"resizable\", e);\n\n        function setDist(child: MoveableManagerInterface, ev: any) {\n            const fixedDirection = datas.fixedDirection;\n            const fixedPosition = datas.fixedPosition;\n            const startPositions = ev.datas.startPositions || getAbsolutePosesByState(child.state);\n            const pos = getPosByDirection(startPositions, fixedDirection);\n            const [originalX, originalY] = calculate(\n                createRotateMatrix(-moveable.rotation / 180 * Math.PI, 3),\n                [pos[0] - fixedPosition[0], pos[1] - fixedPosition[1], 1],\n                3,\n            );\n            ev.datas.originalX = originalX;\n            ev.datas.originalY = originalY;\n\n            return ev;\n        }\n\n        datas.moveableScale = moveable.scale;\n\n        const events = triggerChildAbles(\n            moveable,\n            this,\n            \"dragControlStart\",\n            e,\n            (child, ev) => {\n                return setDist(child, ev);\n            },\n        );\n\n        const setFixedDirection = (fixedDirection: number[]) => {\n            params.setFixedDirection(fixedDirection);\n            events.forEach((ev, i) => {\n                ev.setFixedDirection(fixedDirection);\n                setDist(ev.moveable, originalEvents[i]);\n            });\n        };\n\n        datas.setFixedDirection = setFixedDirection;\n        const nextParams: OnScaleGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events,\n            setFixedDirection,\n        };\n        const result = triggerEvent(moveable, \"onScaleGroupStart\", nextParams);\n\n        datas.isScale = result !== false;\n        return datas.isScale ? nextParams : false;\n    },\n    dragGroupControl(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas } = e;\n        if (!datas.isScale) {\n            return;\n        }\n\n        catchEvent(moveable, \"onBeforeScale\", parentEvent => {\n            triggerEvent(moveable, \"onBeforeScaleGroup\", fillParams<OnBeforeScaleGroup>(moveable, e, {\n                ...parentEvent,\n                targets: moveable.props.targets!,\n            }, true));\n        });\n\n        const params = this.dragControl(moveable, e);\n        if (!params) {\n            return;\n        }\n\n        const moveableScale = datas.moveableScale;\n        moveable.scale = [\n            params.scale[0] * moveableScale[0],\n            params.scale[1] * moveableScale[1],\n        ];\n        const keepRatio = moveable.props.keepRatio;\n        const { dist, scale } = params;\n\n        const fixedPosition = datas.fixedPosition;\n\n        const events = triggerChildAbles(\n            moveable,\n            this,\n            \"dragControl\",\n            e,\n            (_, ev) => {\n                const [clientX, clientY] = calculate(\n                    createRotateMatrix(moveable.rotation / 180 * Math.PI, 3),\n                    [\n                        ev.datas.originalX * dist[0],\n                        ev.datas.originalY * dist[1],\n                        1,\n                    ],\n                    3,\n                );\n\n                return {\n                    ...ev,\n                    parentDist: null,\n                    parentScale: scale,\n                    parentKeepRatio: keepRatio,\n                    dragClient: plus(fixedPosition, [clientX, clientY]),\n                };\n            },\n        );\n        const nextParams: OnScaleGroup = {\n            targets: moveable.props.targets!,\n            events,\n            ...params,\n        };\n\n        triggerEvent(moveable, \"onScaleGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupControlEnd(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isScale) {\n            return;\n        }\n        this.dragControlEnd(moveable, e);\n        const events = triggerChildAbles(moveable, this, \"dragControlEnd\", e);\n\n        const nextParams = fillEndParams<OnScaleGroupEnd>(moveable, e, {\n            targets: moveable.props.targets!,\n            events,\n        });\n\n        triggerEvent(moveable, \"onScaleGroupEnd\", nextParams);\n        return isDrag;\n    },\n    /**\n     * @method Moveable.Scalable#request\n     * @param {Moveable.Scalable.ScalableRequestParam} e - the Scalable's request parameter\n     * @return {Moveable.Requester} Moveable Requester\n     * @example\n\n     * // Instantly Request (requestStart - request - requestEnd)\n     * moveable.request(\"scalable\", { deltaWidth: 10, deltaHeight: 10 }, true);\n     *\n     * // requestStart\n     * const requester = moveable.request(\"scalable\");\n     *\n     * // request\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     *\n     * // requestEnd\n     * requester.requestEnd();\n     */\n    request() {\n        const datas = {};\n        let distWidth = 0;\n        let distHeight = 0;\n\n        return {\n            isControl: true,\n            requestStart(e: IObject<any>) {\n                return { datas, parentDirection: e.direction || [1, 1] };\n            },\n            request(e: IObject<any>) {\n                distWidth += e.deltaWidth;\n                distHeight += e.deltaHeight;\n\n                return { datas, parentDist: [distWidth, distHeight], parentKeepRatio: e.keepRatio };\n            },\n            requestEnd() {\n                return { datas, isDrag: true };\n            },\n        };\n    },\n};\n\n/**\n * Whether or not target can scaled.\n *\n * @name Moveable.Scalable#scalable\n * @default false\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.scalable = true;\n */\n\n/**\n * throttle of scaleX, scaleY when scale.\n * @name Moveable.Scalable#throttleScale\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.throttleScale = 0.1;\n */\n/**\n * Set directions to show the control box. (default: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"])\n * @name Moveable.Scalable#renderDirections\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     scalable: true,\n *   renderDirections: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"],\n * });\n *\n * moveable.renderDirections = [\"nw\", \"ne\", \"sw\", \"se\"];\n */\n/**\n * When resize or scale, keeps a ratio of the width, height. (default: false)\n * @name Moveable.Scalable#keepRatio\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     scalable: true,\n * });\n *\n * moveable.keepRatio = true;\n */\n/**\n * When the scale starts, the scaleStart event is called.\n * @memberof Moveable.Scalable\n * @event scaleStart\n * @param {Moveable.Scalable.OnScaleStart} - Parameters for the scaleStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { scalable: true });\n * moveable.on(\"scaleStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When scaling, `beforeScale` is called before `scale` occurs. In `beforeScale`, you can get and set the pre-value before scaling.\n * @memberof Moveable.Scalable\n * @event beforeScale\n * @param {Moveable.Scalable.OnBeforeScale} - Parameters for the `beforeScale` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { scalable: true });\n * moveable.on(\"beforeScale\", ({ setFixedDirection }) => {\n *     if (shiftKey) {\n *        setFixedDirection([0, 0]);\n *     }\n * });\n * moveable.on(\"scale\", ({ target, transform, dist }) => {\n *     target.style.transform = transform;\n * });\n */\n\n/**\n * When scaling, the `scale` event is called.\n * @memberof Moveable.Scalable\n * @event scale\n * @param {Moveable.Scalable.OnScale} - Parameters for the `scale` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { scalable: true });\n * moveable.on(\"scale\", ({ target, transform, dist }) => {\n *     target.style.transform = transform;\n * });\n */\n/**\n * When the scale finishes, the `scaleEnd` event is called.\n * @memberof Moveable.Scalable\n * @event scaleEnd\n * @param {Moveable.Scalable.OnScaleEnd} - Parameters for the `scaleEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { scalable: true });\n * moveable.on(\"scaleEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n/**\n* When the group scale starts, the `scaleGroupStart` event is called.\n* @memberof Moveable.Scalable\n* @event scaleGroupStart\n* @param {Moveable.Scalable.OnScaleGroupStart} - Parameters for the `scaleGroupStart` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     scalable: true\n* });\n* moveable.on(\"scaleGroupStart\", ({ targets }) => {\n*     console.log(\"onScaleGroupStart\", targets);\n* });\n*/\n\n/**\n* When the group scale, the `scaleGroup` event is called.\n* @memberof Moveable.Scalable\n* @event scaleGroup\n* @param {Moveable.Scalable.OnScaleGroup} - Parameters for the `scaleGroup` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     scalable: true\n* });\n* moveable.on(\"scaleGroup\", ({ targets, events }) => {\n*     console.log(\"onScaleGroup\", targets);\n*     events.forEach(ev => {\n*         const target = ev.target;\n*         // ev.drag is a drag event that occurs when the group scale.\n*         const left = ev.drag.beforeDist[0];\n*         const top = ev.drag.beforeDist[1];\n*         const scaleX = ev.scale[0];\n*         const scaleY = ev.scale[1];\n*     });\n* });\n*/\n\n/**\n * When the group scale finishes, the `scaleGroupEnd` event is called.\n * @memberof Moveable.Scalable\n * @event scaleGroupEnd\n * @param {Moveable.Scalable.OnScaleGroupEnd} - Parameters for the `scaleGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     scalable: true\n * });\n * moveable.on(\"scaleGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onScaleGroupEnd\", targets, isDrag);\n * });\n */\n","import {\n    prefix, getLineStyle, getDirection, getAbsolutePosesByState,\n    triggerEvent, fillParams, fillEndParams,\n} from \"../utils\";\nimport {\n    convertDimension, invert, multiply,\n    calculate,\n    createIdentityMatrix,\n    ignoreDimension,\n    minus,\n    createWarpMatrix,\n    plus,\n} from \"@scena/matrix\";\nimport { NEARBY_POS } from \"../consts\";\nimport {\n    setDragStart, getDragDist, getPosIndexesByDirection, setDefaultTransformIndex,\n    fillTransformStartEvent, resolveTransformEvent,\n    convertTransformFormat, fillOriginalTransform, getTransfromMatrix,\n} from \"../gesto/GestoUtils\";\nimport {\n    WarpableProps, ScalableProps, ResizableProps,\n    Renderer, SnappableProps, SnappableState,\n    OnWarpStart, OnWarp, OnWarpEnd, MoveableManagerInterface,\n} from \"../types\";\nimport { hasClass, dot, getRad } from \"@daybrush/utils\";\nimport { renderAllDirections } from \"../renderDirections\";\nimport { hasGuidelines } from \"./snappable/utils\";\nimport { checkMoveableSnapBounds } from \"./snappable/snapBounds\";\n\nfunction getMiddleLinePos(pos1: number[], pos2: number[]) {\n    return pos1.map((pos, i) => dot(pos, pos2[i], 1, 2));\n}\n\nfunction getTriangleRad(pos1: number[], pos2: number[], pos3: number[]) {\n    // pos1 Rad\n    const rad1 = getRad(pos1, pos2);\n    const rad2 = getRad(pos1, pos3);\n\n    const rad = rad2 - rad1;\n\n    return rad >= 0 ? rad : rad + 2 * Math.PI;\n}\n\nfunction isValidPos(poses1: number[][], poses2: number[][]) {\n    const rad1 = getTriangleRad(poses1[0], poses1[1], poses1[2]);\n    const rad2 = getTriangleRad(poses2[0], poses2[1], poses2[2]);\n    const pi = Math.PI;\n\n    if ((rad1 >= pi && rad2 <= pi) || (rad1 <= pi && rad2 >= pi)) {\n        return false;\n    }\n    return true;\n}\n\n/**\n * @namespace Moveable.Warpable\n * @description Warpable indicates whether the target can be warped(distorted, bented).\n */\nexport default {\n    name: \"warpable\",\n    ableGroup: \"size\",\n    props: {\n        warpable: Boolean,\n        renderDirections: Array,\n        edge: Boolean,\n    } as const,\n    events: {\n        onWarpStart: \"warpStart\",\n        onWarp: \"warp\",\n        onWarpEnd: \"warpEnd\",\n    } as const,\n    render(moveable: MoveableManagerInterface<ResizableProps & ScalableProps & WarpableProps>, React: Renderer): any[] {\n        const { resizable, scalable, warpable, zoom } = moveable.props;\n\n        if (resizable || scalable || !warpable) {\n            return [];\n        }\n        const { pos1, pos2, pos3, pos4 } = moveable.state;\n\n        const linePosFrom1 = getMiddleLinePos(pos1, pos2);\n        const linePosFrom2 = getMiddleLinePos(pos2, pos1);\n        const linePosFrom3 = getMiddleLinePos(pos1, pos3);\n        const linePosFrom4 = getMiddleLinePos(pos3, pos1);\n        const linePosTo1 = getMiddleLinePos(pos3, pos4);\n        const linePosTo2 = getMiddleLinePos(pos4, pos3);\n        const linePosTo3 = getMiddleLinePos(pos2, pos4);\n        const linePosTo4 = getMiddleLinePos(pos4, pos2);\n\n        return [\n            <div className={prefix(\"line\")}\n                key=\"middeLine1\" style={getLineStyle(linePosFrom1, linePosTo1, zoom)}></div>,\n            <div className={prefix(\"line\")}\n                key=\"middeLine2\" style={getLineStyle(linePosFrom2, linePosTo2, zoom)}></div>,\n            <div className={prefix(\"line\")}\n                key=\"middeLine3\" style={getLineStyle(linePosFrom3, linePosTo3, zoom)}></div>,\n            <div className={prefix(\"line\")}\n                key=\"middeLine4\" style={getLineStyle(linePosFrom4, linePosTo4, zoom)}></div>,\n            ...renderAllDirections(moveable, \"warpable\", React),\n        ];\n    },\n    dragControlCondition(moveable: any, e: any) {\n        if (e.isRequest) {\n            return false;\n        }\n        const target = e.inputEvent.target;\n\n        return hasClass(target, prefix(\"direction\")) && hasClass(target, prefix(\"warpable\"));\n    },\n    dragControlStart(\n        moveable: MoveableManagerInterface<WarpableProps, SnappableState>,\n        e: any,\n    ) {\n        const { datas, inputEvent } = e;\n        const { target } = moveable.props;\n        const { target: inputTarget } = inputEvent;\n        const direction = getDirection(inputTarget);\n\n        if (!direction || !target) {\n            return false;\n        }\n        const state = moveable.state;\n        const {\n            transformOrigin, is3d,\n            targetTransform, targetMatrix,\n            width, height,\n            left, top,\n        } = state;\n\n        datas.datas = {};\n        datas.targetTransform = targetTransform;\n        datas.warpTargetMatrix = is3d ? targetMatrix : convertDimension(targetMatrix, 3, 4);\n        datas.targetInverseMatrix = ignoreDimension(invert(datas.warpTargetMatrix, 4), 3, 4);\n        datas.direction = direction;\n        datas.left = left;\n        datas.top = top;\n        datas.poses = [\n            [0, 0],\n            [width, 0],\n            [0, height],\n            [width, height],\n        ].map(p => minus(p, transformOrigin));\n\n        datas.nextPoses = datas.poses.map(([x, y]: number[]) => calculate(datas.warpTargetMatrix, [x, y, 0, 1], 4));\n        datas.startValue = createIdentityMatrix(4);\n        datas.prevMatrix = createIdentityMatrix(4);\n        datas.absolutePoses = getAbsolutePosesByState(state);\n        datas.posIndexes = getPosIndexesByDirection(direction);\n\n        setDragStart(moveable, e);\n        setDefaultTransformIndex(e, \"matrix3d\");\n\n        state.snapRenderInfo = {\n            request: e.isRequest,\n            direction,\n        };\n\n        const params = fillParams<OnWarpStart>(moveable, e, {\n            set: (matrix: number[]) => {\n                datas.startValue = matrix;\n            },\n            ...fillTransformStartEvent(e),\n        });\n        const result = triggerEvent(moveable, \"onWarpStart\", params);\n        if (result !== false) {\n            datas.isWarp = true;\n        }\n        return datas.isWarp;\n    },\n    dragControl(\n        moveable: MoveableManagerInterface<WarpableProps & SnappableProps, SnappableState>,\n        e: any,\n    ) {\n        const { datas, isRequest } = e;\n        let { distX, distY } = e;\n        const {\n            targetInverseMatrix, prevMatrix, isWarp, startValue,\n            poses,\n            posIndexes,\n            absolutePoses,\n        } = datas;\n\n        if (!isWarp) {\n            return false;\n        }\n        resolveTransformEvent(e, \"matrix3d\");\n        if (hasGuidelines(moveable, \"warpable\")) {\n            const selectedPoses: number[][] = posIndexes.map((index: number) => absolutePoses[index]);\n\n            if (selectedPoses.length > 1) {\n                selectedPoses.push([\n                    (selectedPoses[0][0] + selectedPoses[1][0]) / 2,\n                    (selectedPoses[0][1] + selectedPoses[1][1]) / 2,\n                ]);\n            }\n\n            const {\n                horizontal: horizontalSnapInfo,\n                vertical: verticalSnapInfo,\n            } = checkMoveableSnapBounds(\n                moveable,\n                isRequest,\n                {\n                    horizontal: selectedPoses.map(pos => pos[1] + distY),\n                    vertical: selectedPoses.map(pos => pos[0] + distX),\n                },\n            );\n\n            distY -= horizontalSnapInfo.offset;\n            distX -= verticalSnapInfo.offset;\n        }\n\n        const dist = getDragDist({ datas, distX, distY }, true);\n        const nextPoses = datas.nextPoses.slice();\n\n        posIndexes.forEach((index: number) => {\n            nextPoses[index] = plus(nextPoses[index], dist);\n        });\n\n        if (!NEARBY_POS.every(\n            nearByPoses => isValidPos(nearByPoses.map(i => poses[i]), nearByPoses.map(i => nextPoses[i])),\n        )) {\n            return false;\n        }\n        const h = createWarpMatrix(\n            poses[0],\n            poses[2],\n            poses[1],\n            poses[3],\n            nextPoses[0],\n            nextPoses[2],\n            nextPoses[1],\n            nextPoses[3],\n        );\n\n        if (!h.length) {\n            return false;\n        }\n        // B * A * M\n        const afterMatrix = multiply(targetInverseMatrix, h, 4);\n\n        // B * M * A\n        const matrix = getTransfromMatrix(datas, afterMatrix, true);\n\n        const delta = multiply(invert(prevMatrix, 4), matrix, 4);\n\n        datas.prevMatrix = matrix;\n        const totalMatrix = multiply(startValue, matrix, 4);\n        const nextTransform = convertTransformFormat(\n            datas, `matrix3d(${totalMatrix.join(\", \")})`, `matrix3d(${matrix.join(\", \")})`);\n\n        fillOriginalTransform(e, nextTransform);\n        triggerEvent(moveable, \"onWarp\", fillParams<OnWarp>(moveable, e, {\n            delta,\n            matrix: totalMatrix,\n            dist: matrix,\n            multiply,\n            transform: nextTransform,\n        }));\n        return true;\n    },\n    dragControlEnd(\n        moveable: MoveableManagerInterface<WarpableProps>,\n        e: any,\n    ) {\n        const { datas, isDrag } = e;\n        if (!datas.isWarp) {\n            return false;\n        }\n        datas.isWarp = false;\n\n        triggerEvent(moveable, \"onWarpEnd\", fillEndParams<OnWarpEnd>(moveable, e, {}));\n        return isDrag;\n    },\n};\n\n/**\n * Whether or not target can be warped. (default: false)\n * @name Moveable.Warpable#warpable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.warpable = true;\n */\n\n/**\n* Set directions to show the control box. (default: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"])\n* @name Moveable.Warpable#renderDirections\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     warpable: true,\n*     renderDirections: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"],\n* });\n*\n* moveable.renderDirections = [\"nw\", \"ne\", \"sw\", \"se\"];\n*/\n/**\n* When the warp starts, the warpStart event is called.\n* @memberof Moveable.Warpable\n* @event warpStart\n* @param {Moveable.Warpable.OnWarpStart} - Parameters for the warpStart event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, { warpable: true });\n* moveable.on(\"warpStart\", ({ target }) => {\n*     console.log(target);\n* });\n*/\n/**\n * When warping, the warp event is called.\n * @memberof Moveable.Warpable\n * @event warp\n * @param {Moveable.Warpable.OnWarp} - Parameters for the warp event\n * @example\n * import Moveable from \"moveable\";\n * let matrix = [\n *  1, 0, 0, 0,\n *  0, 1, 0, 0,\n *  0, 0, 1, 0,\n *  0, 0, 0, 1,\n * ];\n * const moveable = new Moveable(document.body, { warpable: true });\n * moveable.on(\"warp\", ({ target, transform, delta, multiply }) => {\n *    // target.style.transform = transform;\n *    matrix = multiply(matrix, delta);\n *    target.style.transform = `matrix3d(${matrix.join(\",\")})`;\n * });\n */\n/**\n * When the warp finishes, the warpEnd event is called.\n * @memberof Moveable.Warpable\n * @event warpEnd\n * @param {Moveable.Warpable.OnWarpEnd} - Parameters for the warpEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { warpable: true });\n * moveable.on(\"warpEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n","import { prefix } from \"./utils\";\n\nexport const AREA_PIECES = /*#__PURE__*/prefix(\"area-pieces\");\nexport const AREA_PIECE = /*#__PURE__*/prefix(\"area-piece\");\nexport const AVOID = /*#__PURE__*/prefix(\"avoid\");\n","import {\n    createWarpMatrix,\n} from \"@scena/matrix\";\nimport { ref } from \"framework-utils\";\nimport { getRect, calculateInversePosition, makeMatrixCSS, prefix } from \"../utils\";\nimport {\n    Renderer, GroupableProps, DragAreaProps, MoveableManagerInterface, MoveableGroupInterface,\n} from \"../types\";\nimport { AREA_PIECE, AVOID, AREA_PIECES } from \"../classNames\";\nimport { addClass, removeClass, requestAnimationFrame } from \"@daybrush/utils\";\n\nfunction restoreStyle(moveable: MoveableManagerInterface) {\n    const el = moveable.areaElement;\n\n    if (!el) {\n        return;\n    }\n    const { width, height } = moveable.state;\n\n    removeClass(el, AVOID);\n\n    el.style.cssText += `left: 0px; top: 0px; width: ${width}px; height: ${height}px`;\n}\n\nfunction renderPieces(React: Renderer): any {\n    return (<div key=\"area_pieces\" className={AREA_PIECES}>\n        <div className={AREA_PIECE}></div>\n        <div className={AREA_PIECE}></div>\n        <div className={AREA_PIECE}></div>\n        <div className={AREA_PIECE}></div>\n    </div>);\n}\nexport default {\n    name: \"dragArea\",\n    props: {\n        dragArea: Boolean,\n        passDragArea: Boolean,\n    } as const,\n    events: {\n        onClick: \"click\",\n        onClickGroup: \"clickGroup\",\n    } as const,\n    render(moveable: MoveableManagerInterface<GroupableProps>, React: Renderer): any[] {\n        const { target, dragArea, groupable, passDragArea } = moveable.props;\n        const { width, height, renderPoses } = moveable.state;\n\n        const className = passDragArea ? prefix(\"area\", \"pass\") : prefix(\"area\");\n        if (groupable) {\n            return [\n                <div key=\"area\" ref={ref(moveable, \"areaElement\")} className={className}></div>,\n                renderPieces(React),\n            ];\n        }\n        if (!target || !dragArea) {\n            return [];\n        }\n        const h = createWarpMatrix(\n            [0, 0],\n            [width, 0],\n            [0, height],\n            [width, height],\n            renderPoses[0],\n            renderPoses[1],\n            renderPoses[2],\n            renderPoses[3],\n        );\n        const transform = h.length ? makeMatrixCSS(h, true) : \"none\";\n\n        return [\n            <div key=\"area\" ref={ref(moveable, \"areaElement\")} className={className} style={{\n                top: \"0px\",\n                left: \"0px\",\n                width: `${width}px`,\n                height: `${height}px`,\n                transformOrigin: \"0 0\",\n                transform,\n            }}></div>,\n            renderPieces(React),\n        ];\n    },\n    dragStart(moveable: MoveableManagerInterface, { datas, clientX, clientY, inputEvent }: any) {\n        if (!inputEvent) {\n            return false;\n        }\n        datas.isDragArea = false;\n        const areaElement = moveable.areaElement;\n        const state = moveable.state;\n        const {\n            moveableClientRect,\n            renderPoses,\n            rootMatrix,\n            is3d,\n        } = state;\n        const { left, top } = moveableClientRect;\n        const {\n            left: relativeLeft,\n            top: relativeTop,\n            width,\n            height,\n        } = getRect(renderPoses);\n        const n = is3d ? 4 : 3;\n        let [posX, posY] = calculateInversePosition(rootMatrix, [clientX - left, clientY - top], n);\n\n        posX -= relativeLeft;\n        posY -= relativeTop;\n        const rects = [\n            { left: relativeLeft, top: relativeTop, width, height: posY - 10 },\n            { left: relativeLeft, top: relativeTop, width: posX - 10, height },\n            { left: relativeLeft, top: relativeTop + posY + 10, width, height: height - posY - 10 },\n            { left: relativeLeft + posX + 10, top: relativeTop, width: width - posX - 10, height },\n        ];\n\n        const children = [].slice.call(areaElement.nextElementSibling!.children) as HTMLElement[];\n        rects.forEach((rect, i) => {\n            children[i].style.cssText\n                = `left: ${rect.left}px;top: ${rect.top}px; width: ${rect.width}px; height: ${rect.height}px;`;\n        });\n        addClass(areaElement, AVOID);\n        state.disableNativeEvent = true;\n        return;\n    },\n    drag(moveable: MoveableManagerInterface, { datas, inputEvent }: any) {\n        this.enableNativeEvent(moveable);\n        if (!inputEvent) {\n            return false;\n        }\n        if (!datas.isDragArea) {\n            datas.isDragArea = true;\n            restoreStyle(moveable);\n        }\n    },\n    dragEnd(moveable: MoveableManagerInterface<DragAreaProps>, e: any) {\n        this.enableNativeEvent(moveable);\n        const { inputEvent, datas } = e;\n        if (!inputEvent) {\n            return false;\n        }\n        if (!datas.isDragArea) {\n            restoreStyle(moveable);\n        }\n    },\n    dragGroupStart(moveable: MoveableGroupInterface, e: any) {\n        return this.dragStart(moveable, e);\n    },\n    dragGroup(moveable: MoveableGroupInterface, e: any) {\n        return this.drag(moveable, e);\n    },\n    dragGroupEnd(\n        moveable: MoveableGroupInterface<DragAreaProps>,\n        e: any,\n    ) {\n        return this.dragEnd(moveable, e);\n    },\n    unset(moveable: MoveableManagerInterface<DragAreaProps>) {\n        restoreStyle(moveable);\n        moveable.state.disableNativeEvent = false;\n    },\n    enableNativeEvent(moveable: MoveableManagerInterface<DragAreaProps>) {\n        const state = moveable.state;\n        if (state.disableNativeEvent) {\n            requestAnimationFrame(() => {\n                state.disableNativeEvent = false;\n            });\n        }\n    },\n};\n\n/**\n * Add an event to the moveable area instead of the target for stopPropagation. (default: false, true in group)\n * @name Moveable#dragArea\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  dragArea: false,\n * });\n */\n/**\n * Set `pointerEvents: none;` css to pass events in dragArea. (default: false)\n * @name Moveable#passDragArea\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  dragArea: false,\n * });\n */\n","import { prefix, getControlTransform } from \"../utils\";\nimport { Renderer, OriginOptions, MoveableManagerInterface } from \"../types\";\nimport { makeAble } from \"./AbleManager\";\n\nexport default makeAble(\"origin\", {\n    render(moveable: MoveableManagerInterface<OriginOptions>, React: Renderer): any[] {\n        const { zoom } = moveable.props;\n        const { beforeOrigin, rotation } = moveable.state;\n\n        return [\n            <div className={prefix(\"control\", \"origin\")}\n                style={getControlTransform(rotation, zoom!, beforeOrigin)} key=\"beforeOrigin\"></div>,\n        ];\n    },\n});\n\n/**\n * Whether or not the origin controlbox will be visible or not (default: true)\n * @name Moveable#origin\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.origin = true;\n */\n","\nimport { ScrollableProps, OnScroll, MoveableManagerInterface, MoveableGroupInterface } from \"../types\";\nimport { triggerEvent, fillParams, getRefTarget } from \"../utils\";\nimport DragScroll from \"@scena/dragscroll\";\n\nfunction getDefaultScrollPosition(e: { scrollContainer: HTMLElement, direction: number[] }) {\n    const scrollContainer = e.scrollContainer;\n\n    return [\n        scrollContainer.scrollLeft,\n        scrollContainer.scrollTop,\n    ];\n}\n/**\n * @namespace Moveable.Scrollable\n * @description Whether or not target can be scrolled to the scroll container (default: false)\n */\nexport default {\n    name: \"scrollable\",\n    canPinch: true,\n    props: {\n        scrollable: Boolean,\n        scrollContainer: Object,\n        scrollThreshold: Number,\n        getScrollPosition: Function,\n    } as const,\n    events: {\n        onScroll: \"scroll\",\n        onScrollGroup: \"scrollGroup\",\n    } as const,\n    dragRelation: \"strong\",\n    dragStart(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        const props = moveable.props;\n        const {\n            scrollContainer = moveable.getContainer() as HTMLElement,\n        } = props;\n\n        const dragScroll = new DragScroll();\n        const scrollContainerElement = getRefTarget<HTMLElement>(scrollContainer, true);\n\n        e.datas.dragScroll = dragScroll;\n\n        const gestoName = e.isControl ? \"controlGesto\" : \"targetGesto\";\n        const targets = e.targets;\n\n        dragScroll.on(\"scroll\", ({ container, direction }) => {\n            const params = fillParams<OnScroll>(moveable, e, {\n                scrollContainer: container,\n                direction,\n            }) as any;\n\n            const eventName = targets ? \"onScrollGroup\" : \"onScroll\" as any;\n            if (targets) {\n                params.targets = targets;\n            }\n            triggerEvent(moveable, eventName, params);\n        }).on(\"move\", ({ offsetX, offsetY }) => {\n            moveable[gestoName].scrollBy(offsetX, offsetY, e.inputEvent, false);\n        });\n        dragScroll.dragStart(e, {\n            container: scrollContainerElement!,\n        });\n    },\n    checkScroll(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        const {\n            dragScroll,\n        } = e.datas;\n        if (!dragScroll) {\n            return;\n        }\n        const {\n            scrollContainer = moveable.getContainer(),\n            scrollThreshold = 0,\n            getScrollPosition = getDefaultScrollPosition,\n        } = moveable.props;\n\n        dragScroll.drag(e, {\n            container: scrollContainer,\n            threshold: scrollThreshold,\n            getScrollPosition: (ev: any) => {\n                return getScrollPosition({ scrollContainer: ev.container, direction: ev.direction });\n            },\n        });\n\n        return true;\n    },\n    drag(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        return this.checkScroll(moveable, e);\n    },\n    dragEnd(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        e.datas.dragScroll.dragEnd();\n        e.datas.dragScroll = null;\n    },\n    dragControlStart(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        return this.dragStart(moveable, { ...e, isControl: true });\n    },\n    dragControl(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        return this.drag(moveable, e);\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        return this.dragEnd(moveable, e);\n    },\n    dragGroupStart(moveable: MoveableGroupInterface, e: any) {\n        return this.dragStart(moveable, { ...e, targets: moveable.props.targets });\n    },\n    dragGroup(moveable: MoveableGroupInterface, e: any) {\n        return this.drag(moveable, { ...e, targets: moveable.props.targets });\n    },\n    dragGroupEnd(moveable: MoveableGroupInterface, e: any) {\n        return this.dragEnd(moveable, { ...e, targets: moveable.props.targets });\n    },\n    dragGroupControlStart(moveable: MoveableGroupInterface, e: any) {\n        return this.dragStart(moveable, { ...e, targets: moveable.props.targets, isControl: true });\n    },\n    dragGroupContro(moveable: MoveableGroupInterface, e: any) {\n        return this.drag(moveable, { ...e, targets: moveable.props.targets });\n    },\n    dragGroupControEnd(moveable: MoveableGroupInterface, e: any) {\n        return this.dragEnd(moveable, { ...e, targets: moveable.props.targets });\n    },\n};\n\n/**\n * Whether or not target can be scrolled to the scroll container (default: false)\n * @name Moveable.Scrollable#scrollable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   scrollable: true,\n *   scrollContainer: document.body,\n *   scrollThreshold: 0,\n *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),\n * });\n *\n * moveable.scrollable = true;\n */\n\n/**\n * The container to which scroll is applied (default: container)\n * @name Moveable.Scrollable#scrollContainer\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   scrollable: true,\n *   scrollContainer: document.body,\n *   scrollThreshold: 0,\n *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),\n * });\n */\n/**\n * Expand the range of the scroll check area. (default: 0)\n * @name Moveable.Scrollable#scrollThreshold\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   scrollable: true,\n *   scrollContainer: document.body,\n *   scrollThreshold: 0,\n *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),\n * });\n */\n\n/**\n * Sets a function to get the scroll position. (default: Function)\n * @name Moveable.Scrollable#getScrollPosition\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   scrollable: true,\n *   scrollContainer: document.body,\n *   scrollThreshold: 0,\n *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),\n * });\n *\n */\n\n/**\n * When the drag cursor leaves the scrollContainer, the `scroll` event occur to scroll.\n * @memberof Moveable.Scrollable\n * @event scroll\n * @param {Moveable.Scrollable.OnScroll} - Parameters for the `scroll` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"scroll\", ({ scrollContainer, direction }) => {\n *   scrollContainer.scrollLeft += direction[0] * 10;\n *   scrollContainer.scrollTop += direction[1] * 10;\n * });\n */\n\n/**\n * When the drag cursor leaves the scrollContainer, the `scrollGroup` event occur to scroll in group.\n * @memberof Moveable.Scrollable\n * @event scrollGroup\n * @param {Moveable.Scrollable.OnScrollGroup} - Parameters for the `scrollGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"scroll\", ({ scrollContainer, direction }) => {\n *   scrollContainer.scrollLeft += direction[0] * 10;\n *   scrollContainer.scrollTop += direction[1] * 10;\n * });\n */\n","export default {\n    name: \"\",\n    props: {\n        target: Object,\n        dragTarget: Object,\n        container: Object,\n        portalContainer: Object,\n        rootContainer: Object,\n        useResizeObserver: Boolean,\n        zoom: Number,\n        transformOrigin: Array,\n        edge: Object,\n        ables: Array,\n        className: String,\n        pinchThreshold: Number,\n        pinchOutside: Boolean,\n        triggerAblesSimultaneously: Boolean,\n        checkInput: Boolean,\n        cspNonce: String,\n        translateZ: Number,\n        hideDefaultLines: Boolean,\n        props: Object,\n        flushSync: Function,\n        stopPropagation: Boolean,\n        preventClickEventOnDrag: Boolean,\n        preventClickDefault: Boolean,\n    } as const,\n    events: {} as const,\n};\n","import { prefix, makeMatrixCSS } from \"../utils\";\nimport { Renderer, MoveableManagerInterface } from \"../types\";\nimport { createWarpMatrix } from \"@scena/matrix\";\nimport { makeAble } from \"./AbleManager\";\n\nexport default makeAble(\"padding\", {\n    render(moveable: MoveableManagerInterface, React: Renderer): any[] {\n        const props = moveable.props;\n        if (props.dragArea) {\n            return [];\n        }\n        const padding = props.padding || {};\n        const {\n            left = 0,\n            top = 0,\n            right = 0,\n            bottom = 0,\n        } = padding;\n        const {\n            renderPoses,\n            pos1,\n            pos2,\n            pos3,\n            pos4,\n        } = moveable.state;\n\n        const poses = [pos1, pos2, pos3, pos4];\n        const paddingDirections: number[][] = [];\n\n        if (left > 0) {\n            paddingDirections.push([0, 2]);\n        }\n        if (top > 0) {\n            paddingDirections.push([0, 1]);\n        }\n        if (right > 0) {\n            paddingDirections.push([1, 3]);\n        }\n        if (bottom > 0) {\n            paddingDirections.push([2, 3]);\n        }\n        return paddingDirections.map(([dir1, dir2], i) => {\n            const paddingPos1 = poses[dir1];\n            const paddingPos2 = poses[dir2];\n            const paddingPos3 = renderPoses[dir1];\n            const paddingPos4 = renderPoses[dir2];\n\n            const h = createWarpMatrix(\n                [0, 0],\n                [100, 0],\n                [0, 100],\n                [100, 100],\n                paddingPos1,\n                paddingPos2,\n                paddingPos3,\n                paddingPos4,\n            );\n            if (!h.length) {\n                return undefined;\n            }\n            return (<div key={`padding${i}`} className={prefix(\"padding\")} style={{\n                transform: makeMatrixCSS(h, true),\n            }}></div>);\n        });\n    },\n});\n\n/**\n * Add padding around the target to increase the drag area.\n * @name Moveable#padding\n * @default null\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  target: document.querySelector(\".target\"),\n *  padding: { left: 0, top: 0, right: 0, bottom: 0 },\n * });\n * moveable.padding = { left: 10, top: 10, right: 10, bottom: 10 },\n * moveable.updateRect();\n */\n","import { convertCSSSize } from \"../../utils\";\nimport { ControlPose } from \"../../types\";\nimport { convertUnitSize } from \"@daybrush/utils\";\n\nconst RADIUS_DIRECTIONS = [\"nw\", \"ne\", \"se\", \"sw\"] as const;\n\nfunction calculateRatio(values: number[], size: number) {\n    const sumSize = values[0] + values[1];\n    const sumRatio = sumSize > size ? size / sumSize : 1;\n\n    values[0] *= sumRatio;\n    values[1] = size - values[1] * sumRatio;\n\n    return values;\n}\nexport const HORIZONTAL_RADIUS_ORDER = [1, 2, 5, 6];\nexport const VERTICAL_RADIUS_ORDER = [0, 3, 4, 7];\nexport const HORIZONTAL_RADIUS_DIRECTIONS = [1, -1, -1, 1] as const;\nexport const VERTICAL_RADIUS_DIRECTIONS = [1, 1, -1, -1] as const;\n\nexport function getRadiusStyles(\n    poses: number[][], controlPoses: ControlPose[],\n    isRelative: boolean,\n    width: number,\n    height: number,\n    left = 0,\n    top = 0,\n    right: number = width,\n    bottom: number = height,\n) {\n    const clipStyles: string[] = [];\n    let isVertical = false;\n\n    const raws = poses.map((pos, i) => {\n        const { horizontal, vertical } = controlPoses[i];\n        if (vertical && !isVertical) {\n            isVertical = true;\n            clipStyles.push(\"/\");\n        }\n\n        if (isVertical) {\n            const rawPos = Math.max(0, vertical === 1 ? pos[1] - top : bottom - pos[1]);\n            clipStyles.push(convertCSSSize(rawPos, height, isRelative));\n\n            return rawPos;\n        } else {\n            const rawPos = Math.max(0, horizontal === 1 ? pos[0] - left : right - pos[0]);\n            clipStyles.push(convertCSSSize(rawPos, width, isRelative));\n\n            return rawPos;\n        }\n    });\n\n    return {\n        styles: clipStyles,\n        raws,\n    };\n}\nexport function getRadiusRange(controlPoses: ControlPose[]) {\n    // [start, length]\n    const horizontalRange = [0, 0];\n    const verticalRange = [0, 0];\n    const length = controlPoses.length;\n\n    for (let i = 0; i < length; ++i) {\n        const clipPose = controlPoses[i];\n\n        if (!clipPose.sub) {\n            continue;\n        }\n        if (clipPose.horizontal) {\n            if (horizontalRange[1] === 0) {\n                horizontalRange[0] = i;\n            }\n            horizontalRange[1] = i - horizontalRange[0] + 1;\n            verticalRange[0] = i + 1;\n        }\n        if (clipPose.vertical) {\n            if (verticalRange[1] === 0) {\n                verticalRange[0] = i;\n            }\n            verticalRange[1] = i - verticalRange[0] + 1;\n        }\n    }\n\n    return {\n        horizontalRange,\n        verticalRange,\n    };\n}\nexport function getRadiusValues(\n    values: string[],\n    width: number,\n    height: number,\n    left: number,\n    top: number,\n    minCounts: number[] = [0, 0],\n): ControlPose[] {\n    const splitIndex = values.indexOf(\"/\");\n    const splitLength = (splitIndex > -1 ? values.slice(0, splitIndex) : values).length;\n    const horizontalValues = values.slice(0, splitLength);\n    const verticalValues = values.slice(splitLength + 1);\n    const [\n        nwValue = \"0px\",\n        neValue = nwValue,\n        seValue = nwValue,\n        swValue = neValue,\n    ] = horizontalValues;\n    const [\n        wnValue = nwValue,\n        enValue = wnValue,\n        esValue = wnValue,\n        wsValue = enValue,\n    ] = verticalValues;\n\n    const horizontalRawPoses = [nwValue, neValue, seValue, swValue].map(pos => convertUnitSize(pos, width));\n    const verticalRawPoses = [wnValue, enValue, esValue, wsValue].map(pos => convertUnitSize(pos, height));\n    const horizontalPoses = horizontalRawPoses.slice();\n    const verticalPoses = verticalRawPoses.slice();\n\n    [horizontalPoses[0], horizontalPoses[1]] = calculateRatio([horizontalPoses[0], horizontalPoses[1]], width);\n    [horizontalPoses[3], horizontalPoses[2]] = calculateRatio([horizontalPoses[3], horizontalPoses[2]], width);\n    [verticalPoses[0], verticalPoses[3]] = calculateRatio([verticalPoses[0], verticalPoses[3]], height);\n    [verticalPoses[1], verticalPoses[2]] = calculateRatio([verticalPoses[1], verticalPoses[2]], height);\n\n    const nextHorizontalPoses\n        = horizontalPoses.slice(0, Math.max(minCounts[0], horizontalValues.length));\n    const nextVerticalPoses\n        = verticalPoses.slice(0, Math.max(minCounts[1], verticalValues.length));\n    return [\n        ...nextHorizontalPoses.map((pos, i) => {\n            const direction = RADIUS_DIRECTIONS[i];\n\n            return {\n                horizontal: HORIZONTAL_RADIUS_DIRECTIONS[i],\n                vertical: 0,\n                pos: [left + pos, top + (VERTICAL_RADIUS_DIRECTIONS[i] === -1 ? height : 0)],\n                sub: true,\n                raw: horizontalRawPoses[i],\n                direction,\n            };\n        }),\n        ...nextVerticalPoses.map((pos, i) => {\n            const direction = RADIUS_DIRECTIONS[i];\n\n            return {\n                horizontal: 0,\n                vertical: VERTICAL_RADIUS_DIRECTIONS[i],\n                pos: [left + (HORIZONTAL_RADIUS_DIRECTIONS[i] === -1 ? width : 0), top + pos],\n                sub: true,\n                raw: verticalRawPoses[i],\n                direction,\n            };\n        }),\n    ];\n}\nexport function removeRadiusPos(\n    controlPoses: ControlPose[],\n    poses: number[][],\n    index: number,\n    startIndex: number,\n    length: number = poses.length,\n) {\n    const {\n        horizontalRange,\n        verticalRange,\n    } = getRadiusRange(controlPoses.slice(startIndex));\n    const radiuslIndex = index - startIndex;\n    let deleteCount = 0;\n\n    if (radiuslIndex === 0) {\n        deleteCount = length;\n    } else if (radiuslIndex > 0 && radiuslIndex < horizontalRange[1]) {\n        deleteCount = horizontalRange[1] - radiuslIndex;\n    } else if (radiuslIndex >= verticalRange[0]) {\n        deleteCount = verticalRange[0] + verticalRange[1] - radiuslIndex;\n    } else {\n        return;\n    }\n    controlPoses.splice(index, deleteCount);\n    poses.splice(index, deleteCount);\n}\nexport function addRadiusPos(\n    controlPoses: ControlPose[],\n    poses: number[][],\n    startIndex: number,\n    horizontalIndex: number,\n    verticalIndex: number,\n    distX: number,\n    distY: number,\n    right: number,\n    bottom: number,\n    left = 0,\n    top = 0,\n) {\n    const {\n        horizontalRange,\n        verticalRange,\n    } = getRadiusRange(controlPoses.slice(startIndex));\n    if (horizontalIndex > -1) {\n        const radiusX = HORIZONTAL_RADIUS_DIRECTIONS[horizontalIndex] === 1\n            ? distX - left\n            : right - distX;\n        for (let i = horizontalRange[1]; i <= horizontalIndex; ++i) {\n            const y = VERTICAL_RADIUS_DIRECTIONS[i] === 1 ? top : bottom;\n            let x = 0;\n            if (horizontalIndex === i) {\n                x = distX;\n            } else if (i === 0) {\n                x = left + radiusX;\n            } else if (HORIZONTAL_RADIUS_DIRECTIONS[i] === -1) {\n                x = right - (poses[startIndex][0] - left);\n            }\n            controlPoses.splice(startIndex + i, 0, {\n                horizontal: HORIZONTAL_RADIUS_DIRECTIONS[i],\n                vertical: 0,\n                pos: [x, y],\n            });\n            poses.splice(startIndex + i, 0, [x, y]);\n\n            if (i === 0) {\n                break;\n            }\n        }\n    } else if (verticalIndex > - 1) {\n        const radiusY = VERTICAL_RADIUS_DIRECTIONS[verticalIndex] === 1\n            ? distY - top\n            : bottom - distY;\n        if (horizontalRange[1] === 0 && verticalRange[1] === 0) {\n            const pos = [\n                left + radiusY,\n                top,\n            ];\n            controlPoses.push({\n                horizontal: HORIZONTAL_RADIUS_DIRECTIONS[0],\n                vertical: 0,\n                pos,\n            });\n            poses.push(pos);\n        }\n\n        const startVerticalIndex = verticalRange[0];\n        for (let i = verticalRange[1]; i <= verticalIndex; ++i) {\n            const x = HORIZONTAL_RADIUS_DIRECTIONS[i] === 1 ? left : right;\n            let y = 0;\n            if (verticalIndex === i) {\n                y = distY;\n            } else if (i === 0) {\n                y = top + radiusY;\n            } else if (VERTICAL_RADIUS_DIRECTIONS[i] === 1) {\n                y = poses[startIndex + startVerticalIndex][1];\n            } else if (VERTICAL_RADIUS_DIRECTIONS[i] === -1) {\n                y = bottom - (poses[startIndex + startVerticalIndex][1] - top);\n            }\n            controlPoses.push({\n                horizontal: 0,\n                vertical: VERTICAL_RADIUS_DIRECTIONS[i],\n                pos: [x, y],\n            });\n            poses.push([x, y]);\n            if (i === 0) {\n                break;\n            }\n        }\n    }\n}\nexport function splitRadiusPoses(\n    controlPoses: ControlPose[],\n    raws: number[] = controlPoses.map(pos => pos.raw!),\n) {\n    const horizontals = controlPoses\n        .map((pos, i) => pos.horizontal ? raws[i] : null).filter(pos => pos != null) as number[];\n    const verticals = controlPoses\n        .map((pos, i) => pos.vertical ? raws[i] : null).filter(pos => pos != null) as number[];\n\n    return {\n        horizontals,\n        verticals,\n    };\n}\n","import {\n    Renderer, ClippableProps, OnClip,\n    ClippableState, OnClipEnd, OnClipStart,\n    ControlPose, MoveableManagerInterface, DraggableProps,\n} from \"../types\";\nimport { splitBracket, splitComma, splitUnit, splitSpace, convertUnitSize, getRad } from \"@daybrush/utils\";\nimport {\n    prefix, calculatePosition, getDiagonalSize,\n    fillParams, triggerEvent,\n    makeMatrixCSS, getRect, fillEndParams,\n    convertCSSSize,\n    getComputedStyle,\n    getSizeDistByDist,\n    getProps,\n} from \"../utils\";\nimport { plus, minus, multiply } from \"@scena/matrix\";\nimport { getDragDist, calculatePointerDist, setDragStart } from \"../gesto/GestoUtils\";\nimport {\n    getRadiusValues,\n    HORIZONTAL_RADIUS_ORDER, VERTICAL_RADIUS_ORDER, getRadiusStyles, addRadiusPos, removeRadiusPos,\n} from \"./roundable/borderRadius\";\nimport { renderLine } from \"../renderDirections\";\nimport { checkSnapBoundPriority } from \"./snappable/snap\";\nimport { checkSnapBounds } from \"./snappable/snapBounds\";\nimport { getDefaultGuidelines } from \"./snappable/getTotalGuidelines\";\n\n\nconst CLIP_DIRECTIONS = [\n    [0, -1, \"n\"],\n    [1, 0, \"e\"],\n] as const;\nconst CLIP_RECT_DIRECTIONS = [\n    [-1, -1, \"nw\"],\n    [0, -1, \"n\"],\n    [1, -1, \"ne\"],\n    [1, 0, \"e\"],\n    [1, 1, \"se\"],\n    [0, 1, \"s\"],\n    [-1, 1, \"sw\"],\n    [-1, 0, \"w\"],\n] as const;\n\n// 1 2 5 6 0 3 4 7\n// 0 1 2 3 4 5 6 7\n\nfunction getClipStyles(\n    moveable: MoveableManagerInterface<ClippableProps>,\n    clipPath: ReturnType<typeof getClipPath>,\n    poses: number[][],\n) {\n    const {\n        clipRelative,\n    } = moveable.props;\n    const {\n        width,\n        height,\n    } = moveable.state;\n    const {\n        type: clipType,\n        poses: clipPoses,\n    } = clipPath!;\n\n    const isRect = clipType === \"rect\";\n    const isCircle = clipType === \"circle\";\n    if (clipType === \"polygon\") {\n        return poses.map(pos => `${convertCSSSize(pos[0], width, clipRelative)} ${convertCSSSize(pos[1], height, clipRelative)}`);\n    } else if (isRect || clipType === \"inset\") {\n        const top = poses[1][1];\n        const right = poses[3][0];\n        const left = poses[7][0];\n        const bottom = poses[5][1];\n\n        if (isRect) {\n            return [\n                top,\n                right,\n                bottom,\n                left,\n            ].map(pos => `${pos}px`);\n        }\n        const clipStyles\n            = [top, width - right, height - bottom, left]\n                .map((pos, i) => convertCSSSize(pos, i % 2 ? width : height, clipRelative));\n\n        if (poses.length > 8) {\n            const [subWidth, subHeight] = minus(poses[4], poses[0]);\n\n            clipStyles.push(\"round\", ...getRadiusStyles(\n                poses.slice(8),\n                clipPoses.slice(8),\n                clipRelative!,\n                subWidth,\n                subHeight,\n                left, top, right, bottom,\n            ).styles);\n        }\n        return clipStyles;\n    } else if (isCircle || clipType === \"ellipse\") {\n        const center = poses[0];\n        const ry = convertCSSSize(\n            Math.abs(poses[1][1] - center[1]),\n            isCircle ? Math.sqrt((width * width + height * height) / 2) : height,\n            clipRelative,\n        );\n\n        const clipStyles = isCircle ? [ry]\n            : [convertCSSSize(Math.abs(poses[2][0] - center[0]), width, clipRelative), ry];\n\n        clipStyles.push(\n            \"at\", convertCSSSize(center[0], width, clipRelative),\n            convertCSSSize(center[1], height, clipRelative));\n\n        return clipStyles;\n    }\n}\n\nfunction getRectPoses(top: number, right: number, bottom: number, left: number): ControlPose[] {\n    const xs = [left, (left + right) / 2, right];\n    const ys = [top, (top + bottom) / 2, bottom];\n\n    return CLIP_RECT_DIRECTIONS.map(([dirx, diry, dir]) => {\n        const x = xs[dirx + 1];\n        const y = ys[diry + 1];\n        return {\n            vertical: Math.abs(diry),\n            horizontal: Math.abs(dirx),\n            direction: dir,\n            pos: [x, y],\n        };\n    });\n}\n\nexport function getControlSize(\n    controlPoses: ControlPose[],\n) {\n    const xRange = [Infinity, -Infinity];\n    const yRange = [Infinity, -Infinity];\n\n    controlPoses.forEach(({ pos }) => {\n        xRange[0] = Math.min(xRange[0], pos[0]);\n        xRange[1] = Math.max(xRange[1], pos[0]);\n        yRange[0] = Math.min(yRange[0], pos[1]);\n        yRange[1] = Math.max(yRange[1], pos[1]);\n    });\n\n    return [\n        Math.abs(xRange[1] - xRange[0]),\n        Math.abs(yRange[1] - yRange[0]),\n    ];\n}\n\nexport function moveControlPos(\n    controlPoses: ControlPose[],\n    index: number,\n    dist: number[],\n    isRect?: boolean,\n    keepRatio?: boolean,\n) {\n    const { direction, sub } = controlPoses[index];\n    const dists = controlPoses.map(() => [0, 0]);\n    const directions = direction ? direction.split(\"\") : [];\n\n    if (isRect && index < 8) {\n        const verticalDirections = directions.filter(dir => dir === \"w\" || dir === \"e\");\n        const horizontalDirections = directions.filter(dir => dir === \"n\" || dir === \"s\");\n\n        const verticalDirection = verticalDirections[0];\n        const horizontalDirection = horizontalDirections[0];\n\n        dists[index] = dist;\n        const [width, height] = getControlSize(controlPoses);\n        const ratio = width && height ? width / height : 0;\n\n        if (ratio && keepRatio) {\n            // 0 1 2\n            // 7   3\n            // 6 5 4\n\n            const fixedIndex = (index + 4) % 8;\n            const fixedPosition = controlPoses[fixedIndex].pos;\n            const sizeDirection = [0, 0];\n\n            if (direction!.indexOf(\"w\") > -1) {\n                sizeDirection[0] = -1;\n            } else if (direction!.indexOf(\"e\") > -1) {\n                sizeDirection[0] = 1;\n            }\n            if (direction!.indexOf(\"n\") > -1) {\n                sizeDirection[1] = -1;\n            } else if (direction!.indexOf(\"s\") > -1) {\n                sizeDirection[1] = 1;\n            }\n\n\n            const nextDist = getSizeDistByDist(\n                [width, height],\n                dist,\n                ratio,\n                sizeDirection,\n                true,\n            );\n            const nextWidth = width + nextDist[0];\n            const nextHeight = height + nextDist[1];\n            let top = fixedPosition[1];\n            let bottom = fixedPosition[1];\n            let left = fixedPosition[0];\n            let right = fixedPosition[0];\n\n            if (sizeDirection[0] === -1) {\n                left = right - nextWidth;\n            } else if (sizeDirection[0] === 1) {\n                right = left + nextWidth;\n            } else {\n                left = left - nextWidth / 2;\n                right = right + nextWidth / 2;\n            }\n            if (sizeDirection[1] === -1) {\n                top = bottom - nextHeight;\n            } else if (sizeDirection[1] === 1) {\n                bottom = top + nextHeight;\n            } else {\n                top = bottom - nextHeight / 2;\n                bottom = top + nextHeight;\n            }\n\n            const nextControlPoses = getRectPoses(top, right, bottom, left);\n\n            controlPoses.forEach((controlPose, i) => {\n                dists[i][0] = nextControlPoses[i].pos[0] - controlPose.pos[0];\n                dists[i][1] = nextControlPoses[i].pos[1] - controlPose.pos[1];\n            });\n        } else {\n            controlPoses.forEach((controlPose, i) => {\n                const {\n                    direction: controlDir,\n                } = controlPose;\n\n                if (!controlDir) {\n                    return;\n                }\n                if (controlDir.indexOf(verticalDirection) > -1) {\n                    dists[i][0] = dist[0];\n                }\n                if (controlDir.indexOf(horizontalDirection) > -1) {\n                    dists[i][1] = dist[1];\n                }\n            });\n            if (verticalDirection) {\n                dists[1][0] = dist[0] / 2;\n                dists[5][0] = dist[0] / 2;\n            }\n            if (horizontalDirection) {\n                dists[3][1] = dist[1] / 2;\n                dists[7][1] = dist[1] / 2;\n            }\n        }\n    } else if (direction && !sub) {\n        directions.forEach(dir => {\n            const isVertical = dir === \"n\" || dir === \"s\";\n\n            controlPoses.forEach((controlPose, i) => {\n                const {\n                    direction: dirDir,\n                    horizontal: dirHorizontal,\n                    vertical: dirVertical,\n                } = controlPose;\n\n                if (!dirDir || dirDir.indexOf(dir) === -1) {\n                    return;\n                }\n                dists[i] = [\n                    isVertical || !dirHorizontal ? 0 : dist[0],\n                    !isVertical || !dirVertical ? 0 : dist[1],\n                ];\n            });\n        });\n    } else {\n        dists[index] = dist;\n    }\n\n    return dists;\n}\nfunction getClipPath(\n    target: HTMLElement | SVGElement,\n    width: number,\n    height: number,\n    defaultClip?: string,\n    customClip?: string,\n) {\n    let clipText: string | undefined = customClip;\n\n    if (!clipText) {\n        const style = getComputedStyle(target!);\n        const clipPath = style.clipPath!;\n\n        clipText = clipPath !== \"none\" ? clipPath : style.clip!;\n    }\n    if (!clipText || clipText === \"none\" || clipText === \"auto\") {\n        clipText = defaultClip;\n\n        if (!clipText) {\n            return;\n        }\n    }\n    const {\n        prefix: clipPrefix = clipText,\n        value = \"\",\n    } = splitBracket(clipText);\n    const isCircle = clipPrefix === \"circle\";\n    let splitter = \" \";\n\n    if (clipPrefix === \"polygon\") {\n        const values = splitComma(value! || `0% 0%, 100% 0%, 100% 100%, 0% 100%`);\n        splitter = \",\";\n\n        const poses: ControlPose[] = values.map(pos => {\n            const [xPos, yPos] = pos.split(\" \");\n\n            return {\n                vertical: 1,\n                horizontal: 1,\n                pos: [\n                    convertUnitSize(xPos, width),\n                    convertUnitSize(yPos, height),\n                ],\n            };\n        });\n\n        return {\n            type: clipPrefix,\n            clipText,\n            poses,\n            splitter,\n        } as const;\n    } else if (isCircle || clipPrefix === \"ellipse\") {\n        let xPos = \"\";\n        let yPos = \"\";\n        let radiusX = 0;\n        let radiusY = 0;\n        const values = splitSpace(value!);\n\n        if (isCircle) {\n            let radius = \"\";\n            [radius = \"50%\", , xPos = \"50%\", yPos = \"50%\"] = values;\n\n            radiusX = convertUnitSize(radius, Math.sqrt((width * width + height * height) / 2));\n            radiusY = radiusX;\n        } else {\n            let xRadius = \"\";\n            let yRadius = \"\";\n            [xRadius = \"50%\", yRadius = \"50%\", , xPos = \"50%\", yPos = \"50%\"] = values;\n\n            radiusX = convertUnitSize(xRadius, width);\n            radiusY = convertUnitSize(yRadius, height);\n        }\n        const centerPos = [\n            convertUnitSize(xPos, width),\n            convertUnitSize(yPos, height),\n        ];\n        const poses: ControlPose[] = [\n            {\n                vertical: 1,\n                horizontal: 1,\n                pos: centerPos,\n                direction: \"nesw\",\n            },\n            ...CLIP_DIRECTIONS.slice(0, isCircle ? 1 : 2).map(dir => ({\n                vertical: Math.abs(dir[1]),\n                horizontal: dir[0],\n                direction: dir[2],\n                sub: true,\n                pos: [\n                    centerPos[0] + dir[0] * radiusX,\n                    centerPos[1] + dir[1] * radiusY,\n                ],\n            })),\n        ];\n        return {\n            type: clipPrefix as \"circle\" | \"ellipse\",\n            clipText,\n            radiusX,\n            radiusY,\n            left: centerPos[0] - radiusX,\n            top: centerPos[1] - radiusY,\n            poses,\n            splitter,\n        } as const;\n    } else if (clipPrefix === \"inset\") {\n        const values = splitSpace(value! || \"0 0 0 0\");\n        const roundIndex = values.indexOf(\"round\");\n\n        const rectLength = (roundIndex > -1 ? values.slice(0, roundIndex) : values).length;\n        const radiusValues = values.slice(rectLength + 1);\n        const [\n            topValue,\n            rightValue = topValue,\n            bottomValue = topValue,\n            leftValue = rightValue,\n        ] = values.slice(0, rectLength);\n        const [top, bottom] = [topValue, bottomValue].map(pos => convertUnitSize(pos, height));\n        const [left, right] = [leftValue, rightValue].map(pos => convertUnitSize(pos, width));\n        const nextRight = width - right;\n        const nextBottom = height - bottom;\n        const radiusPoses = getRadiusValues(\n            radiusValues,\n            nextRight - left,\n            nextBottom - top,\n            left,\n            top,\n        );\n        const poses: ControlPose[] = [\n            ...getRectPoses(top, nextRight, nextBottom, left),\n            ...radiusPoses,\n        ];\n\n        return {\n            type: \"inset\",\n            clipText,\n            poses,\n            top,\n            left,\n            right: nextRight,\n            bottom: nextBottom,\n            radius: radiusValues,\n            splitter,\n        } as const;\n    } else if (clipPrefix === \"rect\") {\n        // top right bottom left\n        const values = splitComma(value! || `0px, ${width}px, ${height}px, 0px`);\n\n        splitter = \",\";\n        const [top, right, bottom, left] = values.map(pos => {\n            const { value: posValue } = splitUnit(pos);\n\n            return posValue;\n        });\n        const poses = getRectPoses(top, right, bottom, left);\n\n        return {\n            type: \"rect\",\n            clipText,\n            poses,\n            top,\n            right,\n            bottom,\n            left,\n            values,\n            splitter,\n        } as const;\n    }\n    return;\n}\nfunction addClipPath(moveable: MoveableManagerInterface<ClippableProps>, e: any) {\n    const [distX, distY] = calculatePointerDist(moveable, e);\n    const { clipPath, clipIndex } = e.datas;\n    const {\n        type: clipType,\n        poses: clipPoses,\n        splitter,\n    } = (clipPath as ReturnType<typeof getClipPath>)!;\n    const poses = clipPoses.map(pos => pos.pos);\n    if (clipType === \"polygon\") {\n        poses.splice(clipIndex, 0, [distX, distY]);\n    } else if (clipType === \"inset\") {\n        const horizontalIndex = HORIZONTAL_RADIUS_ORDER.indexOf(clipIndex);\n        const verticalIndex = VERTICAL_RADIUS_ORDER.indexOf(clipIndex);\n        const length = clipPoses.length;\n\n        addRadiusPos(\n            clipPoses,\n            poses,\n            8,\n            horizontalIndex,\n            verticalIndex,\n            distX,\n            distY,\n            poses[4][0],\n            poses[4][1],\n            poses[0][0],\n            poses[0][1],\n        );\n\n        if (length === clipPoses.length) {\n            return;\n        }\n    } else {\n        return;\n    }\n    const clipStyles = getClipStyles(moveable, clipPath, poses)!;\n    triggerEvent(moveable, \"onClip\", fillParams<OnClip>(moveable, e, {\n        clipEventType: \"added\",\n        clipType,\n        poses,\n        clipStyles,\n        clipStyle: `${clipType}(${clipStyles.join(splitter)})`,\n        distX: 0,\n        distY: 0,\n    }));\n}\nfunction removeClipPath(moveable: MoveableManagerInterface<ClippableProps>, e: any) {\n    const { clipPath, clipIndex } = e.datas;\n    const {\n        type: clipType,\n        poses: clipPoses,\n        splitter,\n    } = (clipPath as ReturnType<typeof getClipPath>)!;\n    const poses = clipPoses.map(pos => pos.pos);\n    const length = poses.length;\n    if (clipType === \"polygon\") {\n        clipPoses.splice(clipIndex, 1);\n        poses.splice(clipIndex, 1);\n    } else if (clipType === \"inset\") {\n        if (clipIndex < 8) {\n            return;\n        }\n        removeRadiusPos(clipPoses, poses, clipIndex, 8, length);\n\n        if (length === clipPoses.length) {\n            return;\n        }\n    } else {\n        return;\n    }\n    const clipStyles = getClipStyles(moveable, clipPath, poses)!;\n    triggerEvent(moveable, \"onClip\", fillParams<OnClip>(moveable, e, {\n        clipEventType: \"removed\",\n        clipType,\n        poses,\n        clipStyles,\n        clipStyle: `${clipType}(${clipStyles.join(splitter)})`,\n        distX: 0,\n        distY: 0,\n    }));\n}\n/**\n * @namespace Moveable.Clippable\n * @description Whether to clip the target.\n */\n\nexport default {\n    name: \"clippable\",\n    props: {\n        clippable: Boolean,\n        defaultClipPath: String,\n        customClipPath: String,\n        keepRatio: Boolean,\n        clipRelative: Boolean,\n        clipArea: Boolean,\n        dragWithClip: Boolean,\n        clipTargetBounds: Boolean,\n        clipVerticalGuidelines: Array,\n        clipHorizontalGuidelines: Array,\n        clipSnapThreshold: Boolean,\n    } as const,\n    events: {\n        onClipStart: \"clipStart\",\n        onClip: \"clip\",\n        onClipEnd: \"clipEnd\",\n    } as const,\n    css: [\n        `.control.clip-control {\n    background: #6d6;\n    cursor: pointer;\n}\n.control.clip-control.clip-radius {\n    background: #d66;\n}\n.line.clip-line {\n    background: #6e6;\n    cursor: move;\n    z-index: 1;\n}\n.clip-area {\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.clip-ellipse {\n    position: absolute;\n    cursor: move;\n    border: 1px solid #6d6;\n    border: var(--zoompx) solid #6d6;\n    border-radius: 50%;\n    transform-origin: 0px 0px;\n}`,\n        `:host {\n    --bounds-color: #d66;\n}`,\n        `.guideline {\n    pointer-events: none;\n    z-index: 2;\n}`,\n        `.line.guideline.bounds {\n    background: #d66;\n    background: var(--bounds-color);\n}`,\n    ],\n    render(moveable: MoveableManagerInterface<ClippableProps, ClippableState>, React: Renderer): any[] {\n        const {\n            customClipPath,\n            defaultClipPath,\n            clipArea, zoom,\n        } = moveable.props;\n        const {\n            target, width, height, allMatrix, is3d, left, top,\n            pos1, pos2, pos3, pos4,\n            clipPathState,\n            snapBoundInfos,\n            rotation: rotationRad,\n        } = moveable.state;\n\n        if (!target) {\n            return [];\n        }\n\n        const clipPath = getClipPath(\n            target, width, height, defaultClipPath || \"inset\", clipPathState || customClipPath);\n\n        if (!clipPath) {\n            return [];\n        }\n        const n = is3d ? 4 : 3;\n        const type = clipPath.type;\n        const clipPoses = clipPath.poses;\n        const poses = clipPoses.map(pos => {\n            // return [x, y];\n            const calculatedPos = calculatePosition(allMatrix, pos.pos, n);\n\n            return [\n                calculatedPos[0] - left,\n                calculatedPos[1] - top,\n            ];\n        });\n\n        let controls: any[] = [];\n        let lines: any[] = [];\n\n        const isRect = type === \"rect\";\n        const isInset = type === \"inset\";\n        const isPolygon = type === \"polygon\";\n\n        if (isRect || isInset || isPolygon) {\n            const linePoses = isInset ? poses.slice(0, 8) : poses;\n\n            lines = linePoses.map((to, i) => {\n                const from = i === 0 ? linePoses[linePoses.length - 1] : linePoses[i - 1];\n\n                const rad = getRad(from, to);\n                const dist = getDiagonalSize(from, to);\n                return <div key={`clipLine${i}`} className={prefix(\"line\", \"clip-line\", \"snap-control\")}\n                    data-clip-index={i}\n                    style={{\n                        width: `${dist}px`,\n                        transform: `translate(${from[0]}px, ${from[1]}px) rotate(${rad}rad) scaleY(${zoom})`,\n                    }}></div>;\n            });\n        }\n        controls = poses.map((pos, i) => {\n            return <div key={`clipControl${i}`}\n                className={prefix(\"control\", \"clip-control\", \"snap-control\")}\n                data-clip-index={i}\n                style={{\n                    transform: `translate(${pos[0]}px, ${pos[1]}px) rotate(${rotationRad}rad) scale(${zoom})`,\n                }}></div>;\n        });\n\n        if (isInset) {\n            controls.push(...poses.slice(8).map((pos, i) => {\n                return <div key={`clipRadiusControl${i}`}\n                    className={prefix(\"control\", \"clip-control\", \"clip-radius\", \"snap-control\")}\n                    data-clip-index={8 + i}\n                    style={{\n                        transform: `translate(${pos[0]}px, ${pos[1]}px) rotate(${rotationRad}rad) scale(${zoom})`,\n                    }}></div>;\n            }));\n        }\n        if (type === \"circle\" || type === \"ellipse\") {\n            const {\n                left: clipLeft,\n                top: clipTop,\n                radiusX,\n                radiusY,\n            } = clipPath;\n\n            const [distLeft, distTop] = minus(\n                calculatePosition(allMatrix, [clipLeft!, clipTop!], n),\n                calculatePosition(allMatrix, [0, 0], n),\n            );\n            let ellipseClipPath = \"none\";\n\n            if (!clipArea) {\n                const piece = Math.max(10, radiusX! / 5, radiusY! / 5);\n                const areaPoses: number[][] = [];\n\n                for (let i = 0; i <= piece; ++i) {\n                    const rad = Math.PI * 2 / piece * i;\n                    areaPoses.push([\n                        radiusX! + (radiusX! - zoom!) * Math.cos(rad),\n                        radiusY! + (radiusY! - zoom!) * Math.sin(rad),\n                    ]);\n                }\n                areaPoses.push([radiusX!, -2]);\n                areaPoses.push([-2, -2]);\n                areaPoses.push([-2, radiusY! * 2 + 2]);\n                areaPoses.push([radiusX! * 2 + 2, radiusY! * 2 + 2]);\n                areaPoses.push([radiusX! * 2 + 2, -2]);\n                areaPoses.push([radiusX!, -2]);\n\n                ellipseClipPath = `polygon(${areaPoses.map(pos => `${pos[0]}px ${pos[1]}px`).join(\", \")})`;\n            }\n            controls.push(<div key=\"clipEllipse\" className={prefix(\"clip-ellipse\", \"snap-control\")} style={{\n                width: `${radiusX! * 2}px`,\n                height: `${radiusY! * 2}px`,\n                clipPath: ellipseClipPath,\n                transform: `translate(${-left + distLeft}px, ${-top + distTop}px) ${makeMatrixCSS(allMatrix)}`,\n            }}></div>);\n        }\n        if (clipArea) {\n            const {\n                width: allWidth,\n                height: allHeight,\n                left: allLeft,\n                top: allTop,\n            } = getRect([pos1, pos2, pos3, pos4, ...poses]);\n            if (isPolygon || isRect || isInset) {\n                const areaPoses = isInset ? poses.slice(0, 8) : poses;\n                controls.push(<div key=\"clipArea\" className={prefix(\"clip-area\", \"snap-control\")} style={{\n                    width: `${allWidth}px`,\n                    height: `${allHeight}px`,\n                    transform: `translate(${allLeft}px, ${allTop}px)`,\n                    clipPath: `polygon(${areaPoses.map(pos => `${pos[0] - allLeft}px ${pos[1] - allTop}px`).join(\", \")})`,\n                }}></div>);\n            }\n        }\n        if (snapBoundInfos) {\n            ([\"vertical\", \"horizontal\"] as const).forEach(directionType => {\n                const info = snapBoundInfos[directionType];\n                const isHorizontal = directionType === \"horizontal\";\n\n                if (info.isSnap) {\n                    lines.push(...info.snap.posInfos.map(({ pos }, i) => {\n                        const snapPos1 = minus(calculatePosition(\n                            allMatrix, isHorizontal ? [0, pos] : [pos, 0], n), [left, top]);\n                        const snapPos2 = minus(calculatePosition(\n                            allMatrix, isHorizontal ? [width, pos] : [pos, height], n), [left, top]);\n\n                        return renderLine(\n                            React, \"\", snapPos1, snapPos2, zoom!,\n                            `clip${directionType}snap${i}`, \"guideline\");\n                    }));\n                }\n                if (info.isBound) {\n                    lines.push(...info.bounds.map(({ pos }, i) => {\n                        const snapPos1 = minus(calculatePosition(\n                            allMatrix, isHorizontal ? [0, pos] : [pos, 0], n), [left, top]);\n                        const snapPos2 = minus(calculatePosition(\n                            allMatrix, isHorizontal ? [width, pos] : [pos, height], n), [left, top]);\n\n                        return renderLine(\n                            React, \"\", snapPos1, snapPos2, zoom!,\n                            `clip${directionType}bounds${i}`, \"guideline\", \"bounds\", \"bold\");\n                    }));\n                }\n            });\n        }\n        return [\n            ...controls,\n            ...lines,\n        ];\n    },\n    dragControlCondition(moveable: any, e: any) {\n        return e.inputEvent && (e.inputEvent.target.getAttribute(\"class\") || \"\").indexOf(\"clip\") > -1;\n    },\n    dragStart(moveable: MoveableManagerInterface<ClippableProps, ClippableState>, e: any) {\n        const props = moveable.props;\n        const {\n            dragWithClip = true,\n        } = props;\n\n        if (dragWithClip) {\n            return false;\n        }\n\n        return this.dragControlStart(moveable, e);\n    },\n    drag(moveable: MoveableManagerInterface<ClippableProps, ClippableState>, e: any) {\n        return this.dragControl(moveable, {...e, isDragTarget: true });\n    },\n    dragEnd(moveable: MoveableManagerInterface<ClippableProps, ClippableState>, e: any) {\n        return this.dragControlEnd(moveable, e);\n    },\n    dragControlStart(moveable: MoveableManagerInterface<ClippableProps, ClippableState>, e: any) {\n        const state = moveable.state;\n        const { defaultClipPath, customClipPath } = moveable.props;\n        const { target, width, height } = state;\n        const inputTarget = e.inputEvent ? e.inputEvent.target : null;\n        const className = (inputTarget && inputTarget.getAttribute(\"class\")) || \"\";\n        const datas = e.datas;\n        const clipPath = getClipPath(target!, width, height, defaultClipPath || \"inset\", customClipPath);\n\n        if (!clipPath) {\n            return false;\n        }\n        const { clipText, type, poses } = clipPath;\n        const result = triggerEvent(moveable, \"onClipStart\", fillParams<OnClipStart>(moveable, e, {\n            clipType: type,\n            clipStyle: clipText,\n            poses: poses.map(pos => pos.pos),\n        }));\n\n        if (result === false) {\n            datas.isClipStart = false;\n            return false;\n        }\n        datas.isControl = className && className.indexOf(\"clip-control\") > -1;\n        datas.isLine = className.indexOf(\"clip-line\") > -1;\n        datas.isArea = className.indexOf(\"clip-area\") > -1 || className.indexOf(\"clip-ellipse\") > -1;\n        datas.clipIndex = inputTarget ? parseInt(inputTarget.getAttribute(\"data-clip-index\"), 10) : -1;\n        datas.clipPath = clipPath;\n        datas.isClipStart = true;\n        state.clipPathState = clipText;\n        setDragStart(moveable, e);\n\n        return true;\n    },\n    dragControl(moveable: MoveableManagerInterface<ClippableProps & DraggableProps, ClippableState>, e: any) {\n        const { datas, originalDatas, isDragTarget } = e;\n\n        if (!datas.isClipStart) {\n            return false;\n        }\n        const { isControl, isLine, isArea, clipIndex, clipPath } = datas as {\n            clipPath: ReturnType<typeof getClipPath>,\n            [key: string]: any,\n        };\n        if (!clipPath) {\n            return false;\n        }\n        const props = getProps(moveable.props, \"clippable\");\n\n        const { keepRatio } = props;\n        let distX = 0;\n        let distY = 0;\n\n        const originalDraggable = originalDatas.draggable;\n        const originalDist = getDragDist(e);\n\n        if (isDragTarget && originalDraggable) {\n            [distX, distY] = originalDraggable.prevBeforeDist;\n        } else {\n            [distX, distY] = originalDist;\n        }\n\n        const firstDist = [distX, distY];\n\n        const state = moveable.state;\n        const { width, height } = state;\n        const isDragWithTarget = !isArea && !isControl && !isLine;\n        const {\n            type: clipType,\n            poses: clipPoses,\n            splitter,\n        } = clipPath;\n        const poses = clipPoses.map(pos => pos.pos);\n\n        if (isDragWithTarget) {\n            distX = -distX;\n            distY = -distY;\n        }\n        const isAll = !isControl || clipPoses[clipIndex].direction === \"nesw\";\n        const isRect = clipType === \"inset\" || clipType === \"rect\";\n        let dists = clipPoses.map(() => [0, 0]);\n\n        if (isControl && !isAll) {\n            const { horizontal, vertical } = clipPoses[clipIndex];\n            const dist = [\n                distX * Math.abs(horizontal),\n                distY * Math.abs(vertical),\n            ];\n            dists = moveControlPos(clipPoses, clipIndex, dist, isRect, keepRatio);\n        } else if (isAll) {\n            dists = poses.map(() => [distX, distY]);\n        }\n        const nextPoses: number[][] = poses.map((pos, i) => plus(pos, dists[i]));\n        const guidePoses = [...nextPoses];\n\n        state.snapBoundInfos = null;\n        const isCircle = clipPath.type === \"circle\";\n        const isEllipse = clipPath.type === \"ellipse\";\n\n        if (isCircle || isEllipse) {\n            const guideRect = getRect(nextPoses);\n            const ry = Math.abs(guideRect.bottom - guideRect.top);\n            const rx = Math.abs(isEllipse ? guideRect.right - guideRect.left : ry);\n            const bottom = nextPoses[0][1] + ry;\n            const left = nextPoses[0][0] - rx;\n            const right = nextPoses[0][0] + rx;\n\n            // right\n            if (isCircle) {\n                guidePoses.push([right, guideRect.bottom]);\n                dists.push([1, 0]);\n            }\n            // bottom\n            guidePoses.push([guideRect.left, bottom]);\n            dists.push([0, 1]);\n            // left\n            guidePoses.push([left, guideRect.bottom]);\n            dists.push([1, 0]);\n        }\n\n        const guidelines = getDefaultGuidelines(\n            (props.clipHorizontalGuidelines || []).map(v => convertUnitSize(`${v}`, height)),\n            (props.clipVerticalGuidelines || []).map(v => convertUnitSize(`${v}`, width)),\n            width!, height!,\n        );\n        let guideXPoses: number[] = [];\n        let guideYPoses: number[] = [];\n\n        if (isCircle || isEllipse) {\n            guideXPoses = [guidePoses[4][0], guidePoses[2][0]];\n            guideYPoses = [guidePoses[1][1], guidePoses[3][1]];\n        } else if (isRect) {\n            const rectPoses = [guidePoses[0], guidePoses[2], guidePoses[4], guidePoses[6]];\n            const rectDists = [dists[0], dists[2], dists[4], dists[6]];\n\n            guideXPoses = rectPoses.filter((_, i) => rectDists[i][0]).map(pos => pos[0]);\n            guideYPoses = rectPoses.filter((_, i) => rectDists[i][1]).map(pos => pos[1]);\n        } else {\n            guideXPoses = guidePoses.filter((_, i) => dists[i][0]).map(pos => pos[0]);\n            guideYPoses = guidePoses.filter((_, i) => dists[i][1]).map(pos => pos[1]);\n        }\n        const boundDelta = [0, 0];\n        const {\n            horizontal: horizontalSnapInfo,\n            vertical: verticalSnapInfo,\n        } = checkSnapBounds(\n            guidelines,\n            props.clipTargetBounds && { left: 0, top: 0, right: width, bottom: height },\n            guideXPoses,\n            guideYPoses,\n            5,\n        );\n        let snapOffsetY = horizontalSnapInfo.offset;\n        let snapOffsetX = verticalSnapInfo.offset;\n\n        if (horizontalSnapInfo.isBound) {\n            boundDelta[1] += snapOffsetY;\n        }\n        if (verticalSnapInfo.isBound) {\n            boundDelta[0] += snapOffsetX;\n        }\n        if ((isEllipse || isCircle) && dists[0][0] === 0 && dists[0][1] === 0) {\n            const guideRect = getRect(nextPoses);\n            let cy = guideRect.bottom - guideRect.top;\n            let cx = isEllipse ? guideRect.right - guideRect.left : cy;\n\n\n            const distSnapX = verticalSnapInfo.isBound\n                ? Math.abs(snapOffsetX)\n                : (verticalSnapInfo.snapIndex === 0 ? -snapOffsetX : snapOffsetX);\n            const distSnapY = horizontalSnapInfo.isBound\n                ? Math.abs(snapOffsetY)\n                : (horizontalSnapInfo.snapIndex === 0 ? -snapOffsetY : snapOffsetY);\n            cx -= distSnapX;\n            cy -= distSnapY;\n\n            if (isCircle) {\n                cy = checkSnapBoundPriority(verticalSnapInfo, horizontalSnapInfo) > 0 ? cy : cx;\n                cx = cy;\n            }\n            const center = guidePoses[0];\n\n            guidePoses[1][1] = center[1] - cy;\n            guidePoses[2][0] = center[0] + cx;\n            guidePoses[3][1] = center[1] + cy;\n            guidePoses[4][0] = center[0] - cx;\n        } else if (isRect && keepRatio && isControl) {\n            const [width, height] = getControlSize(clipPoses);\n            const ratio = width && height ? width / height : 0;\n            const clipPose = clipPoses[clipIndex];\n            const direction = clipPose.direction! || \"\";\n            let top = guidePoses[1][1];\n            let bottom = guidePoses[5][1];\n            let left = guidePoses[7][0];\n            let right = guidePoses[3][0];\n\n\n            if (snapOffsetY <= snapOffsetX) {\n                snapOffsetY = snapOffsetX / ratio;\n            } else {\n                snapOffsetX = snapOffsetY * ratio;\n            }\n            if (direction!.indexOf(\"w\") > -1) {\n                left -= snapOffsetX;\n            } else if (direction!.indexOf(\"e\") > -1) {\n                right -= snapOffsetX;\n            } else {\n                left += snapOffsetX / 2;\n                right -= snapOffsetX / 2;\n            }\n            if (direction!.indexOf(\"n\") > -1) {\n                top -= snapOffsetY;\n            } else if (direction!.indexOf(\"s\") > -1) {\n                bottom -= snapOffsetY;\n            } else {\n                top += snapOffsetY / 2;\n                bottom -= snapOffsetY / 2;\n            }\n\n            const nextControlPoses = getRectPoses(top, right, bottom, left);\n\n            guidePoses.forEach((pos, i) => {\n                [pos[0], pos[1]] = nextControlPoses[i].pos;\n            });\n        } else {\n            guidePoses.forEach((pos, j) => {\n                const dist = dists[j];\n\n                if (dist[0]) {\n                    pos[0] -= snapOffsetX;\n                }\n                if (dist[1]) {\n                    pos[1] -= snapOffsetY;\n                }\n            });\n        }\n        const nextClipStyles = getClipStyles(moveable, clipPath, nextPoses)!;\n        const clipStyle = `${clipType}(${nextClipStyles.join(splitter)})`;\n\n        state.clipPathState = clipStyle;\n\n        if (isCircle || isEllipse) {\n            guideXPoses = [guidePoses[4][0], guidePoses[2][0]];\n            guideYPoses = [guidePoses[1][1], guidePoses[3][1]];\n        } else if (isRect) {\n            const rectPoses = [guidePoses[0], guidePoses[2], guidePoses[4], guidePoses[6]];\n\n            guideXPoses = rectPoses.map(pos => pos[0]);\n            guideYPoses = rectPoses.map(pos => pos[1]);\n        } else {\n            guideXPoses = guidePoses.map(pos => pos[0]);\n            guideYPoses = guidePoses.map(pos => pos[1]);\n        }\n        state.snapBoundInfos = checkSnapBounds(\n            guidelines,\n            props.clipTargetBounds && { left: 0, top: 0, right: width, bottom: height },\n            guideXPoses,\n            guideYPoses,\n            1,\n        );\n\n        if (originalDraggable) {\n            const {\n                is3d,\n                allMatrix,\n            } = state;\n            const n = is3d ? 4 : 3;\n\n            let dragDist = boundDelta;\n\n            if (isDragTarget) {\n                dragDist = [\n                    firstDist[0] + boundDelta[0] - originalDist[0],\n                    firstDist[1] + boundDelta[1] - originalDist[1],\n                ];\n            }\n            originalDraggable.deltaOffset = multiply(allMatrix, [dragDist[0], dragDist[1], 0, 0], n);\n        }\n        triggerEvent(moveable, \"onClip\", fillParams<OnClip>(moveable, e, {\n            clipEventType: \"changed\",\n            clipType,\n            poses: nextPoses,\n            clipStyle,\n            clipStyles: nextClipStyles,\n            distX,\n            distY,\n        }));\n\n        return true;\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<ClippableProps, ClippableState>, e: any) {\n        this.unset(moveable);\n        const { isDrag, datas, isDouble } = e;\n        const { isLine, isClipStart, isControl } = datas;\n\n        if (!isClipStart) {\n            return false;\n        }\n        triggerEvent(moveable, \"onClipEnd\", fillEndParams<OnClipEnd>(moveable, e, {}));\n        if (isDouble) {\n            if (isControl) {\n                removeClipPath(moveable, e);\n            } else if (isLine) {\n                // add\n                addClipPath(moveable, e);\n            }\n        }\n        return isDouble || isDrag;\n    },\n    unset(moveable: MoveableManagerInterface<ClippableProps, ClippableState>) {\n        moveable.state.clipPathState = \"\";\n        moveable.state.snapBoundInfos = null;\n    },\n};\n\n/**\n * Whether to clip the target. (default: false)\n * @name Moveable.Clippable#clippable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n *  If clippath is not set, the default value can be set. (defaultClipPath < style < customClipPath < dragging clipPath)\n * @name Moveable.Clippable#defaultClipPath\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * % Can be used instead of the absolute px (`rect` not possible) (default: false)\n * @name Moveable.Clippable#clipRelative\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * You can force the custom clipPath. (defaultClipPath < style < customClipPath < dragging clipPath)\n * @name Moveable.Clippable#customClipPath\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * When dragging the target, the clip also moves. (default: true)\n * @name Moveable.Clippable#dragWithClip\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * You can drag the clip by setting clipArea.\n * @name Moveable.Clippable#clipArea\n * @default false\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n* Whether the clip is bound to the target.\n* @name Moveable.Clippable#clipTargetBounds\n* @default false\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     clippable: true,\n*     defaultClipPath: \"inset\",\n*     customClipPath: \"\",\n*     clipRelative: false,\n*     clipArea: false,\n*     dragWithClip: true,\n*     clipTargetBounds: true,\n* });\n* moveable.on(\"clipStart\", e => {\n*     console.log(e);\n* }).on(\"clip\", e => {\n*     if (e.clipType === \"rect\") {\n*         e.target.style.clip = e.clipStyle;\n*     } else {\n*         e.target.style.clipPath = e.clipStyle;\n*     }\n* }).on(\"clipEnd\", e => {\n*     console.log(e);\n* });\n*/\n\n/**\n * Add clip guidelines in the vertical direction.\n * @name Moveable.Clippable#clipVerticalGuidelines\n * @default 0\n * @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     clippable: true,\n*     defaultClipPath: \"inset\",\n*     customClipPath: \"\",\n*     clipRelative: false,\n*     clipArea: false,\n*     dragWithClip: true,\n*     clipVerticalGuidelines: [0, 100, 200],\n*     clipHorizontalGuidelines: [0, 100, 200],\n*     clipSnapThreshold: 5,\n* });\n*/\n\n/**\n* Add clip guidelines in the horizontal direction.\n* @name Moveable.Clippable#clipHorizontalGuidelines\n* @default []\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     clippable: true,\n*     defaultClipPath: \"inset\",\n*     customClipPath: \"\",\n*     clipRelative: false,\n*     clipArea: false,\n*     dragWithClip: true,\n*     clipVerticalGuidelines: [0, 100, 200],\n*     clipHorizontalGuidelines: [0, 100, 200],\n*     clipSnapThreshold: 5,\n* });\n*/\n/**\n* istance value that can snap to clip guidelines.\n* @name Moveable.Clippable#clipSnapThreshold\n* @default 5\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     clippable: true,\n*     defaultClipPath: \"inset\",\n*     customClipPath: \"\",\n*     clipRelative: false,\n*     clipArea: false,\n*     dragWithClip: true,\n*     clipVerticalGuidelines: [0, 100, 200],\n*     clipHorizontalGuidelines: [0, 100, 200],\n*     clipSnapThreshold: 5,\n* });\n*/\n/**\n * When drag start the clip area or controls, the `clipStart` event is called.\n * @memberof Moveable.Clippable\n * @event clipStart\n * @param {Moveable.Clippable.OnClipStart} - Parameters for the `clipStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n * When drag the clip area or controls, the `clip` event is called.\n * @memberof Moveable.Clippable\n * @event clip\n * @param {Moveable.Clippable.OnClip} - Parameters for the `clip` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n * When drag end the clip area or controls, the `clipEnd` event is called.\n * @memberof Moveable.Clippable\n * @event clipEnd\n * @param {Moveable.Clippable.OnClipEnd} - Parameters for the `clipEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n","import {\n    prefix, triggerEvent,\n    fillParams, calculatePoses, getRect, fillEndParams, convertCSSSize,\n} from \"../utils\";\nimport {\n    OnDragOriginStart, OnDragOrigin,\n    OnDragOriginEnd, MoveableManagerInterface, DraggableProps, OriginDraggableProps, MoveableGroupInterface,\n} from \"../types\";\nimport { hasClass, IObject } from \"@daybrush/utils\";\nimport { setDragStart, getDragDist, getNextMatrix } from \"../gesto/GestoUtils\";\nimport { minus, plus } from \"@scena/matrix\";\nimport Draggable from \"./Draggable\";\nimport CustomGesto, { setCustomDrag } from \"../gesto/CustomGesto\";\n\n/**\n * @namespace OriginDraggable\n * @memberof Moveable\n * @description Whether to drag origin (default: false)\n */\nexport default {\n    name: \"originDraggable\",\n    props: {\n        originDraggable: Boolean,\n        originRelative: Boolean,\n    } as const,\n    events: {\n        onDragOriginStart: \"dragOriginStart\",\n        onDragOrigin: \"dragOrigin\",\n        onDragOriginEnd: \"dragOriginEnd\",\n    } as const,\n    css: [\n        `:host[data-able-origindraggable] .control.origin {\n    pointer-events: auto;\n}`,\n    ],\n    dragControlCondition(_: any, e: any) {\n        if (e.isRequest) {\n            return e.requestAble === \"originDraggable\";\n        }\n        return hasClass(e.inputEvent.target, prefix(\"origin\"));\n    },\n    dragControlStart(moveable: MoveableManagerInterface<OriginDraggableProps & DraggableProps>, e: any) {\n        const { datas } = e;\n\n        setDragStart(moveable, e);\n\n        const params = fillParams<OnDragOriginStart>(moveable, e, {\n            dragStart: Draggable.dragStart(\n                moveable,\n                new CustomGesto().dragStart([0, 0], e),\n            ),\n        });\n        const result = triggerEvent(moveable, \"onDragOriginStart\", params);\n\n        datas.startOrigin = moveable.state.transformOrigin;\n        datas.startTargetOrigin = moveable.state.targetOrigin;\n        datas.prevOrigin = [0, 0];\n        datas.isDragOrigin = true;\n\n        if (result === false) {\n            datas.isDragOrigin = false;\n            return false;\n        }\n\n        return params;\n    },\n    dragControl(moveable: MoveableManagerInterface<OriginDraggableProps & DraggableProps>, e: any) {\n        const { datas, isPinch, isRequest } = e;\n\n        if (!datas.isDragOrigin) {\n            return false;\n        }\n        const [distX, distY] = getDragDist(e);\n        const state = moveable.state;\n        const {\n            width,\n            height,\n            offsetMatrix,\n            targetMatrix,\n            is3d,\n        } = state;\n        const {\n            originRelative = true,\n        } = moveable.props;\n        const n = is3d ? 4 : 3;\n        let dist = [distX, distY];\n\n        if (isRequest) {\n            const distOrigin = e.distOrigin;\n            if (distOrigin[0] || distOrigin[1]) {\n                dist = distOrigin;\n            }\n        }\n        const origin = plus(datas.startOrigin, dist);\n        const targetOrigin = plus(datas.startTargetOrigin, dist);\n        const delta = minus(dist, datas.prevOrigin);\n\n        const nextMatrix = getNextMatrix(\n            offsetMatrix,\n            targetMatrix,\n            origin,\n            n,\n        );\n\n        const rect = moveable.getRect();\n        const nextRect = getRect(calculatePoses(nextMatrix, width, height, n));\n\n        const dragDelta = [\n            rect.left - nextRect.left,\n            rect.top - nextRect.top,\n        ];\n\n        datas.prevOrigin = dist;\n        const transformOrigin = [\n            convertCSSSize(targetOrigin[0], width, originRelative),\n            convertCSSSize(targetOrigin[1], height, originRelative),\n        ].join(\" \");\n        const params = fillParams<OnDragOrigin>(moveable, e, {\n            width,\n            height,\n            origin,\n            dist,\n            delta,\n            transformOrigin,\n            drag: Draggable.drag(\n                moveable,\n                setCustomDrag(e, moveable.state, dragDelta, !!isPinch, false),\n            )!,\n        });\n        triggerEvent(moveable, \"onDragOrigin\", params);\n        return params;\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<OriginDraggableProps>, e: any) {\n        const { datas } = e;\n\n        if (!datas.isDragOrigin) {\n            return false;\n        }\n        triggerEvent(moveable, \"onDragOriginEnd\",\n            fillEndParams<OnDragOriginEnd>(moveable, e, {}));\n        return true;\n    },\n    dragGroupControlCondition(moveable: any, e: any) {\n        return this.dragControlCondition(moveable, e);\n    },\n    dragGroupControlStart(moveable: MoveableGroupInterface<OriginDraggableProps>, e: any) {\n        const params = this.dragControlStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n\n        return true;\n    },\n    dragGroupControl(moveable: MoveableGroupInterface<OriginDraggableProps>, e: any) {\n        const params = this.dragControl(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n        moveable.transformOrigin = params.transformOrigin;\n\n        return true;\n    },\n    /**\n    * @method Moveable.OriginDraggable#request\n    * @param {object} e - the OriginDraggable's request parameter\n    * @param {number} [e.x] - x position\n    * @param {number} [e.y] - y position\n    * @param {number} [e.deltaX] - x number to move\n    * @param {number} [e.deltaY] - y number to move\n    * @param {array} [e.deltaOrigin] - left, top number to move transform-origin\n    * @param {array} [e.origin] - transform-origin position\n    * @param {number} [e.isInstant] - Whether to execute the request instantly\n    * @return {Moveable.Requester} Moveable Requester\n    * @example\n\n    * // Instantly Request (requestStart - request - requestEnd)\n    * // Use Relative Value\n    * moveable.request(\"originDraggable\", { deltaX: 10, deltaY: 10 }, true);\n    * // Use Absolute Value\n    * moveable.request(\"originDraggable\", { x: 200, y: 100 }, true);\n    * // Use Transform Value\n    * moveable.request(\"originDraggable\", { deltaOrigin: [10, 0] }, true);\n    * moveable.request(\"originDraggable\", { origin: [100, 0] }, true);\n    * // requestStart\n    * const requester = moveable.request(\"originDraggable\");\n    *\n    * // request\n    * // Use Relative Value\n    * requester.request({ deltaX: 10, deltaY: 10 });\n    * requester.request({ deltaX: 10, deltaY: 10 });\n    * requester.request({ deltaX: 10, deltaY: 10 });\n    * // Use Absolute Value\n    * moveable.request(\"originDraggable\", { x: 200, y: 100 });\n    * moveable.request(\"originDraggable\", { x: 220, y: 100 });\n    * moveable.request(\"originDraggable\", { x: 240, y: 100 });\n    *\n    * // requestEnd\n    * requester.requestEnd();\n    */\n    request(moveable: MoveableManagerInterface<any, any>) {\n        const datas = {};\n        const rect = moveable.getRect();\n        let distX = 0;\n        let distY = 0;\n\n        const transformOrigin = rect.transformOrigin;\n        const distOrigin = [0, 0];\n\n        return {\n            isControl: true,\n            requestStart() {\n                return { datas };\n            },\n            request(e: IObject<any>) {\n                if (\"deltaOrigin\" in e) {\n                    distOrigin[0] += e.deltaOrigin[0];\n                    distOrigin[1] += e.deltaOrigin[1];\n                } else if (\"origin\" in e) {\n                    distOrigin[0] = e.origin[0] - transformOrigin[0];\n                    distOrigin[1] = e.origin[1] - transformOrigin[1];\n                } else {\n                    if (\"x\" in e) {\n                        distX = e.x - rect.left;\n                    } else if (\"deltaX\" in e) {\n                        distX += e.deltaX;\n                    }\n                    if (\"y\" in e) {\n                        distY = e.y - rect.top;\n                    } else if (\"deltaY\" in e) {\n                        distY += e.deltaY;\n                    }\n                }\n\n                return { datas, distX, distY, distOrigin };\n            },\n            requestEnd() {\n                return { datas, isDrag: true };\n            },\n        };\n    },\n};\n/**\n * Whether to drag origin (default: false)\n * @name Moveable.OriginDraggable#originDraggable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     originDraggable: true,\n * });\n * let translate = [0, 0];\n * moveable.on(\"dragOriginStart\", e => {\n *     e.dragStart && e.dragStart.set(translate);\n * }).on(\"dragOrigin\", e => {\n *     translate = e.drag.beforeTranslate;\n *     e.target.style.cssText\n *         = `transform-origin: ${e.transformOrigin};`\n *         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\n * }).on(\"dragOriginEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * % Can be used instead of the absolute px (default: true)\n * @name Moveable.OriginDraggable#originRelative\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     originDraggable: true,\n *     originRelative: false,\n * });\n * moveable.originRelative = true;\n */\n\n/**\n* When drag start the origin, the `dragOriginStart` event is called.\n* @memberof Moveable.OriginDraggable\n* @event dragOriginStart\n* @param {Moveable.OriginDraggable.OnDragOriginStart} - Parameters for the `dragOriginStart` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     originDraggable: true,\n* });\n* let translate = [0, 0];\n* moveable.on(\"dragOriginStart\", e => {\n*     e.dragStart && e.dragStart.set(translate);\n* }).on(\"dragOrigin\", e => {\n*     translate = e.drag.beforeTranslate;\n*     e.target.style.cssText\n*         = `transform-origin: ${e.transformOrigin};`\n*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\n* }).on(\"dragOriginEnd\", e => {\n*     console.log(e);\n* });\n*/\n\n/**\n* When drag the origin, the `dragOrigin` event is called.\n* @memberof Moveable.OriginDraggable\n* @event dragOrigin\n* @param {Moveable.OriginDraggable.OnDragOrigin} - Parameters for the `dragOrigin` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     originDraggable: true,\n* });\n* let translate = [0, 0];\n* moveable.on(\"dragOriginStart\", e => {\n*     e.dragStart && e.dragStart.set(translate);\n* }).on(\"dragOrigin\", e => {\n*     translate = e.drag.beforeTranslate;\n*     e.target.style.cssText\n*         = `transform-origin: ${e.transformOrigin};`\n*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\n* }).on(\"dragOriginEnd\", e => {\n*     console.log(e);\n* });\n*/\n\n/**\n* When drag end the origin, the `dragOriginEnd` event is called.\n* @memberof Moveable.OriginDraggable\n* @event dragOriginEnd\n* @param {Moveable.OriginDraggable.OnDragOriginEnd} - Parameters for the `dragOriginEnd` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     originDraggable: true,\n* });\n* let translate = [0, 0];\n* moveable.on(\"dragOriginStart\", e => {\n*     e.dragStart && e.dragStart.set(translate);\n* }).on(\"dragOrigin\", e => {\n*     translate = e.drag.beforeTranslate;\n*     e.target.style.cssText\n*         = `transform-origin: ${e.transformOrigin};`\n*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\n* }).on(\"dragOriginEnd\", e => {\n*     console.log(e);\n* });\n*/\n","import {\n    prefix, triggerEvent,\n    fillParams, fillEndParams, calculatePosition,\n    getComputedStyle,\n} from \"../utils\";\nimport {\n    Renderer, RoundableProps, OnRoundStart, RoundableState, OnRound, ControlPose, OnRoundEnd, MoveableManagerInterface,\n} from \"../types\";\nimport { splitSpace } from \"@daybrush/utils\";\nimport { setDragStart, getDragDist, calculatePointerDist } from \"../gesto/GestoUtils\";\nimport { minus, plus } from \"@scena/matrix\";\nimport {\n    getRadiusValues, getRadiusStyles, removeRadiusPos,\n    addRadiusPos, splitRadiusPoses,\n} from \"./roundable/borderRadius\";\n\nfunction addBorderRadius(\n    controlPoses: ControlPose[],\n    poses: number[][],\n    lineIndex: number,\n    distX: number,\n    distY: number,\n    width: number,\n    height: number,\n) {\n    const {\n        horizontals,\n        verticals,\n    } = splitRadiusPoses(controlPoses);\n    const horizontalsLength = horizontals.length;\n    const verticalsLength = verticals.length;\n    // lineIndex\n    // 0 top\n    // 1 right\n    // 2 left\n    // 3 bottom\n\n    // 0 top - left\n    // 1 top - right\n    // 2 bottom - right\n    // 3 bottom - left\n    // 0 left - top\n    // 1 right - top\n    // 2 right - bottom\n    // 3 left - bottom\n    let horizontalIndex = -1;\n    let verticalIndex = -1;\n\n    if (lineIndex === 0) {\n        if (horizontalsLength === 0) {\n            horizontalIndex = 0;\n        } else if (horizontalsLength === 1) {\n            horizontalIndex = 1;\n        }\n    } else if (lineIndex === 3) {\n        if (horizontalsLength <= 2) {\n            horizontalIndex = 2;\n        } else if (horizontalsLength <= 3) {\n            horizontalIndex = 3;\n        }\n    }\n    if (lineIndex === 2) {\n        if (verticalsLength === 0) {\n            verticalIndex = 0;\n        } else if (verticalsLength < 4) {\n            verticalIndex = 3;\n        }\n    } else if (lineIndex === 1) {\n        if (verticalsLength <= 1) {\n            verticalIndex = 1;\n        } else if (verticalsLength <= 2) {\n            verticalIndex = 2;\n        }\n    }\n\n    addRadiusPos(\n        controlPoses, poses, 0,\n        horizontalIndex, verticalIndex,\n        distX, distY, width, height,\n    );\n}\nfunction getBorderRadius(\n    target: HTMLElement | SVGElement,\n    width: number, height: number,\n    minCounts: number[] = [0, 0],\n    state?: string,\n) {\n    let borderRadius: string;\n    let values: string[] = [];\n\n    if (!state) {\n        const style = getComputedStyle(target);\n\n        borderRadius = (style && style.borderRadius) || \"\";\n    } else {\n        borderRadius = state;\n    }\n    if (!borderRadius || (!state && borderRadius === \"0px\")) {\n        values = [];\n    } else {\n        values = splitSpace(borderRadius);\n    }\n\n    return getRadiusValues(values, width, height, 0, 0, minCounts);\n}\n\nfunction triggerRoundEvent(\n    moveable: MoveableManagerInterface<RoundableProps, RoundableState>,\n    e: any,\n    dist: number[],\n    delta: number[],\n    controlPoses: ControlPose[],\n    nextPoses: number[][],\n) {\n    const state = moveable.state;\n    const {\n        width,\n        height,\n    } = state;\n    const {\n        raws,\n        styles,\n    } = getRadiusStyles(\n        nextPoses,\n        controlPoses,\n        moveable.props.roundRelative!,\n        width,\n        height,\n    );\n    const {\n        horizontals,\n        verticals,\n    } = splitRadiusPoses(controlPoses, raws);\n    const borderRadius = styles.join(\" \");\n\n    state.borderRadiusState = borderRadius;\n    triggerEvent(moveable, \"onRound\", fillParams<OnRound>(moveable, e, {\n        horizontals,\n        verticals,\n        borderRadius,\n        width,\n        height,\n        delta,\n        dist,\n    }));\n}\n\n/**\n * @namespace Moveable.Roundable\n * @description Whether to show and drag or double click border-radius\n */\n\nexport default {\n    name: \"roundable\",\n    props: {\n        roundable: Boolean,\n        roundRelative: Boolean,\n        minRoundControls: Array,\n        maxRoundControls: Array,\n        roundClickable: Boolean,\n    } as const,\n    events: {\n        onRoundStart: \"roundStart\",\n        onRound: \"round\",\n        onRoundEnd: \"roundEnd\",\n    } as const,\n    css: [\n        `.control.border-radius {\n    background: #d66;\n    cursor: pointer;\n}`,\n        `:host[data-able-roundable] .line.direction {\n    cursor: pointer;\n}`,\n    ],\n    render(moveable: MoveableManagerInterface<RoundableProps, RoundableState>, React: Renderer): any {\n        const {\n            target,\n            width,\n            height,\n            allMatrix,\n            is3d,\n            left,\n            top,\n            borderRadiusState,\n        } = moveable.state;\n        const {\n            minRoundControls = [0, 0],\n            maxRoundControls = [4, 4],\n            zoom,\n        } = moveable.props;\n\n        if (!target) {\n            return null;\n        }\n\n        const n = is3d ? 4 : 3;\n        const radiusValues = getBorderRadius(\n            target, width, height, minRoundControls, borderRadiusState);\n\n        if (!radiusValues) {\n            return null;\n        }\n        let verticalCount = 0;\n        let horizontalCount = 0;\n\n        return radiusValues.map((v, i) => {\n            horizontalCount += Math.abs(v.horizontal);\n            verticalCount += Math.abs(v.vertical);\n            const pos = minus(calculatePosition(allMatrix, v.pos, n), [left, top]);\n            const isDisplay = v.vertical\n                ? verticalCount <= maxRoundControls[1]\n                : horizontalCount <= maxRoundControls[0];\n\n            return <div key={`borderRadiusControl${i}`}\n                className={prefix(\"control\", \"border-radius\")}\n                data-radius-index={i}\n                style={{\n                    display: isDisplay ? \"block\" : \"none\",\n                    transform: `translate(${pos[0]}px, ${pos[1]}px) scale(${zoom})`,\n                }}></div>;\n        });\n    },\n    dragControlCondition(moveable: any, e: any) {\n        if (!e.inputEvent || e.isRequest) {\n            return false;\n        }\n        const className = (e.inputEvent.target.getAttribute(\"class\") || \"\");\n\n        return className.indexOf(\"border-radius\") > -1\n            || (className.indexOf(\"moveable-line\") > -1 && className.indexOf(\"moveable-direction\") > -1);\n    },\n    dragControlStart(moveable: MoveableManagerInterface<RoundableProps, RoundableState>, e: any) {\n        const { inputEvent, datas } = e;\n        const inputTarget = inputEvent.target;\n        const className = (inputTarget.getAttribute(\"class\") || \"\");\n        const isControl = className.indexOf(\"border-radius\") > -1;\n        const isLine = className.indexOf(\"moveable-line\") > -1 && className.indexOf(\"moveable-direction\") > -1;\n        const controlIndex = isControl ? parseInt(inputTarget.getAttribute(\"data-radius-index\"), 10) : -1;\n        const lineIndex = isLine ? parseInt(inputTarget.getAttribute(\"data-line-index\"), 10) : -1;\n\n        if (!isControl && !isLine) {\n            return false;\n        }\n\n        const result = triggerEvent(\n            moveable, \"onRoundStart\", fillParams<OnRoundStart>(moveable, e, {}));\n\n        if (result === false) {\n            return false;\n        }\n\n        datas.lineIndex = lineIndex;\n        datas.controlIndex = controlIndex;\n        datas.isControl = isControl;\n        datas.isLine = isLine;\n\n        setDragStart(moveable, e);\n\n        const {\n            roundRelative,\n            minRoundControls = [0, 0],\n        } = moveable.props;\n        const state = moveable.state;\n        const {\n            target,\n            width,\n            height,\n        } = state;\n\n        datas.isRound = true;\n        datas.prevDist = [0, 0];\n        const controlPoses = getBorderRadius(target!, width, height, minRoundControls) || [];\n\n        datas.controlPoses = controlPoses;\n\n        state.borderRadiusState = getRadiusStyles(\n            controlPoses.map(pos => pos.pos), controlPoses, roundRelative!, width, height).styles.join(\" \");\n        return true;\n    },\n    dragControl(moveable: MoveableManagerInterface<RoundableProps, RoundableState>, e: any) {\n        const { datas } = e;\n\n        if (!datas.isRound || !datas.isControl || !datas.controlPoses.length) {\n            return false;\n        }\n        const index = datas.controlIndex as number;\n        const controlPoses = datas.controlPoses as ControlPose[];\n        const [distX, distY] = getDragDist(e);\n        const dist = [distX, distY];\n        const delta = minus(dist, datas.prevDist);\n        const {\n            maxRoundControls = [4, 4],\n        } = moveable.props;\n        const { width, height } = moveable.state;\n        const selectedControlPose = controlPoses[index];\n        const selectedVertical = selectedControlPose.vertical;\n        const selectedHorizontal = selectedControlPose.horizontal;\n\n        // 0: [0, 1, 2, 3] maxCount === 1\n        // 0: [0, 2] maxCount === 2\n        // 1: [1, 3] maxCount === 2\n\n        // 0: [0] maxCount === 3\n        // 1: [1, 3] maxCount === 3\n\n        const dists = controlPoses.map(pose => {\n            const { horizontal, vertical } = pose;\n            const poseDist = [\n                horizontal * selectedHorizontal * dist[0],\n                vertical * selectedVertical * dist[1],\n            ];\n            if (horizontal) {\n                if (maxRoundControls[0] === 1) {\n                    return poseDist;\n                } else if (maxRoundControls[0] < 4 && horizontal !== selectedHorizontal) {\n                    return poseDist;\n                }\n            } else if (maxRoundControls[1] === 0) {\n                poseDist[1] = vertical * selectedHorizontal * dist[0] / width * height;\n\n                return poseDist;\n            } else if (selectedVertical) {\n                if (maxRoundControls[1] === 1) {\n                    return poseDist;\n                } else if (maxRoundControls[1] < 4 && vertical !== selectedVertical) {\n                    return poseDist;\n                }\n            }\n            return [0, 0];\n        });\n        dists[index] = dist;\n        const nextPoses = controlPoses.map((pos, i) => plus(pos.pos, dists[i]));\n\n        datas.prevDist = [distX, distY];\n\n        triggerRoundEvent(\n            moveable,\n            e,\n            dist,\n            delta,\n            controlPoses,\n            nextPoses,\n        );\n        return true;\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<RoundableProps, RoundableState>, e: any) {\n        const state = moveable.state;\n\n        state.borderRadiusState = \"\";\n        const { datas, isDouble } = e;\n        if (!datas.isRound) {\n            return false;\n        }\n        const {\n            width,\n            height,\n        } = state;\n        const {\n            isControl,\n            controlIndex,\n            isLine,\n            lineIndex,\n        } = datas;\n        const controlPoses = datas.controlPoses as ControlPose[];\n        const poses = controlPoses.map(pos => pos.pos);\n        const length = poses.length;\n        const {\n            roundClickable = true,\n        } = moveable.props;\n\n        if (isDouble && roundClickable) {\n            if (isControl) {\n                removeRadiusPos(controlPoses, poses, controlIndex, 0);\n            } else if (isLine) {\n                const [distX, distY] = calculatePointerDist(moveable, e);\n\n                addBorderRadius(controlPoses, poses, lineIndex, distX, distY, width, height);\n            }\n            if (length !== controlPoses.length) {\n                triggerRoundEvent(\n                    moveable,\n                    e,\n                    [0, 0],\n                    [0, 0],\n                    controlPoses,\n                    poses,\n                );\n            }\n        }\n        triggerEvent(moveable, \"onRoundEnd\",\n            fillEndParams<OnRoundEnd>(moveable, e, {}));\n        state.borderRadiusState = \"\";\n        return true;\n    },\n    unset(moveable: MoveableManagerInterface<RoundableProps, RoundableState>) {\n        moveable.state.borderRadiusState = \"\";\n    },\n};\n/**\n * Whether to show and drag or double click border-radius, (default: false)\n * @name Moveable.Roundable#roundable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n * % Can be used instead of the absolute px\n * @name Moveable.Roundable#roundRelative\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n * Minimum number of round controls. It moves in proportion by control. [horizontal, vertical] (default: [0, 0])\n * @name Moveable.Roundable#minRoundControls\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n *     minRoundControls: [0, 0],\n * });\n * moveable.maxRoundControls = [1, 0];\n */\n/**\n * Maximum number of round controls. It moves in proportion by control. [horizontal, vertical] (default: [4, 4])\n * @name Moveable.Roundable#maxRoundControls\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n *     maxRoundControls: [4, 4],\n * });\n * moveable.maxRoundControls = [1, 0];\n */\n/**\n * @property - Whether you can add/delete round controls by double-clicking a line or control. (default: true)\n * @name Moveable.Roundable#roundClickable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n *     roundClickable: true,\n * });\n * moveable.roundClickable = false;\n */\n\n/**\n * When drag start the clip area or controls, the `roundStart` event is called.\n * @memberof Moveable.Roundable\n * @event roundStart\n * @param {Moveable.Roundable.OnRoundStart} - Parameters for the `roundStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n * When drag or double click the border area or controls, the `round` event is called.\n * @memberof Moveable.Roundable\n * @event round\n * @param {Moveable.Roundable.OnRound} - Parameters for the `round` event\n * @example\n  * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n * When drag end the border area or controls, the `roundEnd` event is called.\n * @memberof Moveable.Roundable\n * @event roundEnd\n * @param {Moveable.Roundable.onRoundEnd} - Parameters for the `roundEnd` event\n * @example\n  * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n","import {\n    MoveableManagerInterface, BeforeRenderableProps,\n    OnBeforeRenderStart, OnBeforeRender, OnBeforeRenderEnd,\n    MoveableGroupInterface, OnBeforeRenderGroupStart,\n    OnBeforeRenderGroup, OnBeforeRenderGroupEnd,\n} from \"../types\";\nimport { fillParams, triggerEvent } from \"../utils\";\nimport { convertMatrixtoCSS, createIdentityMatrix } from \"@scena/matrix\";\nimport { isArray, splitSpace } from \"@daybrush/utils\";\nimport { fillChildEvents } from \"../groupUtils\";\n\n\nfunction isIdentityMatrix(matrix: string, is3d?: boolean) {\n    const n = is3d ? 4 : 3;\n    const identityMatrix = createIdentityMatrix(n);\n    const value = `matrix${is3d ? \"3d\" : \"\"}(${identityMatrix.join(\",\")})`;\n\n    return matrix === value || matrix === `matrix(1,0,0,1,0,0)`;\n}\nexport default {\n    isPinch: true,\n    name: \"beforeRenderable\",\n    props: {\n    } as const,\n    events: {\n        onBeforeRenderStart: \"beforeRenderStart\",\n        onBeforeRender: \"beforeRender\",\n        onBeforeRenderEnd: \"beforeRenderEnd\",\n        onBeforeRenderGroupStart: \"beforeRenderGroupStart\",\n        onBeforeRenderGroup: \"beforeRenderGroup\",\n        onBeforeRenderGroupEnd: \"beforeRenderGroupEnd\",\n    } as const,\n    dragRelation: \"weak\",\n    setTransform(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        const {\n            is3d,\n            target,\n            targetMatrix,\n        } = moveable.state;\n        const transform = target?.style.transform;\n        const cssMatrix = is3d\n            ? `matrix3d(${targetMatrix.join(\",\")})`\n            : `matrix(${convertMatrixtoCSS(targetMatrix, true)})`;\n        const startTransform = !transform || transform === \"none\" ? cssMatrix : transform;\n\n        e.datas.startTransforms = isIdentityMatrix(startTransform, is3d) ? [] : splitSpace(startTransform);\n    },\n    resetStyle(e: any) {\n        const datas = e.datas;\n\n        datas.nextStyle = {};\n        datas.nextTransforms = e.datas.startTransforms;\n        datas.nextTransformAppendedIndexes = [];\n    },\n    fillDragStartParams(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        return fillParams<OnBeforeRenderStart>(moveable, e, {\n            setTransform: (transform: string | string[]) => {\n                e.datas.startTransforms = isArray(transform) ? transform : splitSpace(transform);\n            },\n            isPinch: !!e.isPinch,\n        });\n    },\n    fillDragParams(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        return fillParams<OnBeforeRender>(moveable, e, {\n            isPinch: !!e.isPinch,\n        });\n    },\n    dragStart(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        this.setTransform(moveable, e);\n\n        triggerEvent(moveable, `onBeforeRenderStart`, this.fillDragStartParams(moveable, e));\n    },\n    drag(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        this.resetStyle(e);\n        const datas = e.datas;\n\n        datas.nextStyle = {};\n        triggerEvent(moveable, `onBeforeRender`, fillParams<OnBeforeRender>(moveable, e, {\n            isPinch: !!e.isPinch,\n        }));\n    },\n    dragEnd(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        triggerEvent(moveable, `onBeforeRenderEnd`, fillParams<OnBeforeRenderEnd>(moveable, e, {\n            isPinch: !!e.isPinch,\n            isDrag: e.isDrag,\n        }));\n    },\n    dragGroupStart(moveable: MoveableGroupInterface<BeforeRenderableProps>, e: any) {\n        this.dragStart(moveable, e);\n\n        const events = fillChildEvents(moveable, \"beforeRenderable\", e);\n        const moveables = moveable.moveables;\n        const params = events.map((childEvent, i) => {\n            const childMoveable = moveables[i];\n\n            this.setTransform(childMoveable, childEvent);\n            return this.fillDragStartParams(childMoveable, childEvent);\n        });\n        triggerEvent(moveable, `onBeforeRenderGroupStart`, fillParams<OnBeforeRenderGroupStart>(moveable, e, {\n            isPinch: !!e.isPinch,\n            targets: moveable.props.targets,\n            setTransform() { },\n            events: params,\n        }));\n    },\n    dragGroup(moveable: MoveableGroupInterface<BeforeRenderableProps>, e: any) {\n        this.drag(moveable, e);\n\n        const events = fillChildEvents(moveable, \"beforeRenderable\", e);\n        const moveables = moveable.moveables;\n        const params = events.map((childEvent, i) => {\n            const childMoveable = moveables[i];\n\n            this.resetStyle(childEvent);\n            const datas = e.datas;\n\n            datas.nextStyle = {};\n            return this.fillDragParams(childMoveable, childEvent);\n        });\n        triggerEvent(moveable, `onBeforeRenderGroup`, fillParams<OnBeforeRenderGroup>(moveable, e, {\n            isPinch: !!e.isPinch,\n            targets: moveable.props.targets,\n            events: params,\n        }));\n    },\n    dragGroupEnd(moveable: MoveableGroupInterface<BeforeRenderableProps>, e: any) {\n        this.dragEnd(moveable, e);\n\n        triggerEvent(moveable, `onBeforeRenderGroupEnd`, fillParams<OnBeforeRenderGroupEnd>(moveable, e, {\n            isPinch: !!e.isPinch,\n            isDrag: e.isDrag,\n            targets: moveable.props.targets,\n        }));\n    },\n    dragControlStart(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        return this.dragStart(moveable, e);\n    },\n    dragControl(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        return this.drag(moveable, e);\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        return this.dragEnd(moveable, e);\n    },\n    dragGroupControlStart(moveable: MoveableGroupInterface<BeforeRenderableProps>, e: any) {\n        return this.dragGroupStart(moveable, e);\n    },\n    dragGroupControl(moveable: MoveableGroupInterface<BeforeRenderableProps>, e: any) {\n        return this.dragGroup(moveable, e);\n    },\n    dragGroupControlEnd(moveable: MoveableGroupInterface<BeforeRenderableProps>, e: any) {\n        return this.dragGroupEnd(moveable, e);\n    },\n} as const;\n","import { getNextStyle, getNextTransformText } from \"../gesto/GestoUtils\";\nimport { fillChildEvents } from \"../groupUtils\";\nimport {\n    MoveableManagerInterface, RenderableProps, OnRenderStart, OnRender,\n    OnRenderEnd, MoveableGroupInterface,\n    OnRenderGroupStart, OnRenderGroup, OnRenderGroupEnd,\n} from \"../types\";\nimport { triggerEvent, fillParams, fillCSSObject } from \"../utils\";\n\nexport default {\n    name: \"renderable\",\n    props: {\n    } as const,\n    events: {\n        onRenderStart: \"renderStart\",\n        onRender: \"render\",\n        onRenderEnd: \"renderEnd\",\n        onRenderGroupStart: \"renderGroupStart\",\n        onRenderGroup: \"renderGroup\",\n        onRenderGroupEnd: \"renderGroupEnd\",\n    } as const,\n    dragRelation: \"weak\",\n    dragStart(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        triggerEvent(moveable, `onRenderStart`, fillParams<OnRenderStart>(moveable, e, {\n            isPinch: !!e.isPinch,\n        }));\n    },\n    drag(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        triggerEvent(moveable, `onRender`, this.fillDragParams(moveable, e));\n    },\n    dragAfter(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        if (e.resultCount) {\n            return this.drag(moveable, e);\n        }\n    },\n    dragEnd(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        triggerEvent(moveable, `onRenderEnd`, this.fillDragEndParams(moveable, e));\n    },\n    dragGroupStart(moveable: MoveableGroupInterface<RenderableProps>, e: any) {\n        triggerEvent(moveable, `onRenderGroupStart`, fillParams<OnRenderGroupStart>(moveable, e, {\n            isPinch: !!e.isPinch,\n            targets: moveable.props.targets,\n        }));\n    },\n    dragGroup(moveable: MoveableGroupInterface<RenderableProps>, e: any) {\n        const events = fillChildEvents(moveable, \"beforeRenderable\", e);\n        const moveables = moveable.moveables;\n        const params = events.map((childEvent, i) => {\n            const childMoveable = moveables[i];\n\n            return this.fillDragParams(childMoveable, childEvent);\n        });\n\n        triggerEvent(moveable, `onRenderGroup`, fillParams<OnRenderGroup>(moveable, e, {\n            isPinch: !!e.isPinch,\n            targets: moveable.props.targets,\n            transform: getNextTransformText(e),\n            ...fillCSSObject(getNextStyle(e)),\n            events: params,\n        },));\n    },\n    dragGroupEnd(moveable: MoveableGroupInterface<RenderableProps>, e: any) {\n        const events = fillChildEvents(moveable, \"beforeRenderable\", e);\n        const moveables = moveable.moveables;\n        const params = events.map((childEvent, i) => {\n            const childMoveable = moveables[i];\n\n            return this.fillDragEndParams(childMoveable, childEvent);\n        });\n\n        triggerEvent(moveable, `onRenderGroupEnd`, fillParams<OnRenderGroupEnd>(moveable, e, {\n            isPinch: !!e.isPinch,\n            isDrag: e.isDrag,\n            targets: moveable.props.targets,\n            events: params,\n        }));\n    },\n    dragControlStart(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        return this.dragStart(moveable, e);\n    },\n    dragControl(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        return this.drag(moveable, e);\n    },\n    dragControlAfter(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        return this.dragAfter(moveable, e);\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        return this.dragEnd(moveable, e);\n    },\n    dragGroupControlStart(moveable: MoveableGroupInterface<RenderableProps>, e: any) {\n        return this.dragGroupStart(moveable, e);\n    },\n    dragGroupControl(moveable: MoveableGroupInterface<RenderableProps>, e: any) {\n        return this.dragGroup(moveable, e);\n    },\n    dragGroupControlEnd(moveable: MoveableGroupInterface<RenderableProps>, e: any) {\n        return this.dragGroupEnd(moveable, e);\n    },\n    fillDragParams(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        return fillParams<OnRender>(moveable, e, {\n            isPinch: !!e.isPinch,\n            transform: getNextTransformText(e),\n            ...fillCSSObject(getNextStyle(e)),\n        });\n    },\n    fillDragEndParams(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        return fillParams<OnRenderEnd>(moveable, e, {\n            isPinch: !!e.isPinch,\n            isDrag: e.isDrag,\n        });\n    },\n} as const;\n","import { Able, MoveableManagerInterface, MoveableGroupInterface } from \"../types\";\nimport { hasClass, IObject } from \"@daybrush/utils\";\nimport { convertDragDist, defaultSync } from \"../utils\";\nimport Gesto, { GestoOptions } from \"gesto\";\nimport BeforeRenderable from \"../ables/BeforeRenderable\";\nimport Renderable from \"../ables/Renderable\";\n\nexport function triggerAble(\n    moveable: MoveableManagerInterface,\n    ableType: string,\n    eventOperation: string,\n    eventAffix: string,\n    eventType: any,\n    e: any,\n    requestInstant?: boolean,\n) {\n    const isStart = eventType === \"Start\";\n    const target = moveable.state.target;\n    const isRequest = e.isRequest;\n\n    if (\n        !target\n        || (isStart && eventAffix.indexOf(\"Control\") > -1\n            && !isRequest && moveable.areaElement === e.inputEvent.target)\n    ) {\n        return false;\n    }\n    // \"drag\" \"Control\" \"After\"\n    const eventName = `${eventOperation}${eventAffix}${eventType}`;\n    const conditionName = `${eventOperation}${eventAffix}Condition`;\n    const isEnd = eventType === \"End\";\n    const isAfter = eventType === \"After\";\n    const isFirstStart = isStart && (\n        !moveable.targetGesto || !moveable.controlGesto\n        || (!moveable.targetGesto.isFlag() || !moveable.controlGesto.isFlag())\n    );\n\n    if (isFirstStart) {\n        moveable.updateRect(eventType, true, false);\n    }\n    if (eventType === \"\" && !isRequest) {\n        convertDragDist(moveable.state, e);\n    }\n    // const isGroup = eventAffix.indexOf(\"Group\") > -1;\n    const ables: Able[] = [...(moveable as any)[ableType]];\n\n    if (isRequest) {\n        const requestAble = e.requestAble;\n\n        if (!ables.some(able => able.name === requestAble)) {\n            ables.push(...moveable.props.ables!.filter(able => able.name === requestAble));\n        }\n    }\n    if (!ables.length) {\n        return false;\n    }\n    const eventAbles: Able[] = [BeforeRenderable, ...ables, Renderable].filter((able: any) => able[eventName]);\n    const datas = e.datas;\n\n    if (isFirstStart) {\n        eventAbles.forEach(able => {\n            able.unset && able.unset(moveable);\n        });\n    }\n\n    const inputEvent = e.inputEvent;\n    let inputTarget: Element;\n\n    if (isEnd && inputEvent) {\n        inputTarget = document.elementFromPoint(e.clientX, e.clientY) || inputEvent.target;\n    }\n    let resultCount = 0;\n    const results = eventAbles.filter((able: any) => {\n        const ableName = able.name;\n        const nextDatas = datas[ableName] || (datas[ableName] = {});\n\n        if (isStart) {\n            nextDatas.isEventStart = !able[conditionName] || able[conditionName](moveable, e);\n        }\n\n        if (nextDatas.isEventStart) {\n            const result = able[eventName](moveable, {\n                ...e,\n                resultCount,\n                datas: nextDatas,\n                originalDatas: datas,\n                inputTarget,\n            });\n\n            (moveable as any)._emitter.off();\n            if (isStart && result === false) {\n                nextDatas.isEventStart = false;\n            }\n            resultCount += result ? 1 : 0;\n            return result;\n        }\n        return false;\n    });\n\n    const isUpdate = results.length;\n    let isForceEnd = false;\n\n    // end ables\n    if (isStart && eventAbles.length && !isUpdate) {\n        isForceEnd = eventAbles.filter(able => {\n            const ableName = able.name;\n            const nextDatas = datas[ableName];\n\n            if (nextDatas.isEventStart) {\n                if (able.dragRelation === \"strong\") {\n                    // cancel drag\n                    nextDatas.isEventStart = false;\n\n                    return false;\n                }\n                // start drag\n                return true;\n            }\n            // cancel event\n            return false;\n        }).length === 0;\n    }\n    if (isEnd || isForceEnd) {\n        moveable.state.gestos = {};\n\n        if ((moveable as MoveableGroupInterface).moveables) {\n            (moveable as MoveableGroupInterface).moveables.forEach(childMoveable => {\n                childMoveable.state.gestos = {};\n            });\n        }\n    }\n    if (isFirstStart && isForceEnd) {\n        eventAbles.forEach(able => {\n            able.unset && able.unset(moveable);\n        });\n    }\n    if (isStart && !isRequest && isUpdate) {\n        e?.preventDefault();\n    }\n    if (moveable.isUnmounted || isForceEnd) {\n        return false;\n    }\n    if ((!isStart && isUpdate && !requestInstant) || isEnd) {\n        const flushSync = moveable.props.flushSync || defaultSync;\n\n        flushSync(() => {\n            moveable.updateRect(isEnd ? eventType : \"\", true, false);\n            moveable.forceUpdate();\n        });\n\n    }\n    if (!isStart && !isEnd && !isAfter && isUpdate && !requestInstant) {\n        triggerAble(moveable, ableType, eventOperation, eventAffix, eventType + \"After\", e);\n    }\n    return true;\n}\n\nexport function getTargetAbleGesto(\n    moveable: MoveableManagerInterface,\n    moveableTarget: HTMLElement | SVGElement,\n    eventAffix: string,\n) {\n    const controlBox = moveable.controlBox.getElement();\n    const targets: Array<HTMLElement | SVGElement> = [];\n\n    targets.push(controlBox);\n\n    if (!moveable.props.dragArea || moveable.props.dragTarget) {\n        targets.push(moveableTarget);\n    }\n\n    const startFunc = (e: any) => {\n        const eventTarget = e.inputEvent.target;\n        const areaElement = moveable.areaElement;\n\n        return eventTarget === areaElement\n            || (!moveable.isMoveableElement(eventTarget) && !moveable.controlBox.getElement().contains(eventTarget))\n            || hasClass(eventTarget, \"moveable-area\")\n            || hasClass(eventTarget, \"moveable-padding\");\n    };\n\n    return getAbleGesto(moveable, targets, \"targetAbles\", eventAffix, {\n        dragStart: startFunc,\n        pinchStart: startFunc,\n    });\n}\nexport function getAbleGesto(\n    moveable: MoveableManagerInterface,\n    target: HTMLElement | SVGElement | Array<HTMLElement | SVGElement>,\n    ableType: string,\n    eventAffix: string,\n    conditionFunctions: IObject<any> = {},\n) {\n    const isTargetAbles = ableType === \"targetAbles\";\n    const {\n        pinchOutside,\n        pinchThreshold,\n        preventClickEventOnDrag,\n        preventClickDefault,\n        checkInput,\n    } = moveable.props;\n    const options: GestoOptions = {\n        preventDefault: false,\n        preventRightClick: true,\n        preventWheelClick: true,\n        container: window,\n        pinchThreshold,\n        pinchOutside,\n        preventClickEventOnDrag: isTargetAbles ? preventClickEventOnDrag : false,\n        preventClickEventOnDragStart: isTargetAbles ? preventClickDefault : false,\n        checkInput: isTargetAbles ? checkInput : false,\n    };\n    const gesto = new Gesto(target!, options);\n\n    const isControl = eventAffix === \"Control\";\n\n    [\"drag\", \"pinch\"].forEach(eventOperation => {\n        [\"Start\", \"\", \"End\"].forEach(eventType => {\n            gesto.on(`${eventOperation}${eventType}` as any, e => {\n                const eventName = e.eventType;\n\n                if (conditionFunctions[eventName] && !conditionFunctions[eventName](e)) {\n                    e.stop();\n                    return;\n                }\n                const result = triggerAble(moveable, ableType, eventOperation, eventAffix, eventType, e);\n\n                if (!result) {\n                    e.stop();\n                } else if (moveable.props.stopPropagation || (eventType === \"Start\" && isControl)) {\n                    e?.inputEvent?.stopPropagation();\n                }\n            });\n        });\n    });\n\n    return gesto;\n}\n","import { Able, MoveableManagerInterface } from \"./types\";\n\nexport default class EventManager {\n    private ables: Able[] = [];\n    constructor(\n        private target: HTMLElement | SVGElement | null,\n        private moveable: MoveableManagerInterface | null,\n        private eventName: string,\n    ) {\n        target!.addEventListener(eventName.toLowerCase(), this._onEvent);\n    }\n    public setAbles(ables: Able[]) {\n        this.ables = ables;\n    }\n    public destroy() {\n        this.target!.removeEventListener(this.eventName.toLowerCase(), this._onEvent);\n        this.target = null;\n        this.moveable = null;\n    }\n    private _onEvent = (e: Event) => {\n        const eventName = this.eventName;\n        const moveable = this.moveable!;\n\n        if (moveable.state.disableNativeEvent) {\n            return;\n        }\n        this.ables.forEach(able => {\n            (able as any)[eventName](moveable, {\n                inputEvent: e,\n            });\n        });\n    }\n}\n","import { createIdentityMatrix, convertDimension, multiply, createOriginMatrix, ignoreDimension } from \"@scena/matrix\";\nimport { getMatrixStackInfo, convert3DMatrixes, getOffsetInfo, getSVGOffset, makeMatrixCSS } from \"../utils\";\n\nexport interface MoveableElementMatrixInfo {\n    hasFixed: boolean;\n    rootMatrix: number[];\n    beforeMatrix: number[];\n    offsetMatrix: number[];\n    allMatrix: number[];\n    targetMatrix: number[];\n    transformOrigin: number[];\n    targetOrigin: number[];\n    is3d: boolean;\n    targetTransform: string;\n    offsetContainer: HTMLElement | null,\n    offsetRootContainer: HTMLElement | null,\n}\n\nexport function calculateMatrixStack(\n    target: SVGElement | HTMLElement,\n    container?: SVGElement | HTMLElement | null,\n    rootContainer: SVGElement | HTMLElement | null | undefined = container,\n    isAbsolute3d?: boolean,\n    // prevMatrix?: number[],\n    // prevRootMatrix?: number[],\n    // prevN?: number,\n): MoveableElementMatrixInfo {\n    const {\n        matrixes,\n        is3d,\n        targetMatrix: prevTargetMatrix,\n        transformOrigin,\n        targetOrigin,\n        offsetContainer,\n        hasFixed,\n    } = getMatrixStackInfo(target, container); // prevMatrix\n    const {\n        matrixes: rootMatrixes,\n        is3d: isRoot3d,\n        offsetContainer: offsetRootContainer,\n    } = getMatrixStackInfo(offsetContainer, rootContainer, true); // prevRootMatrix\n\n    // if (rootContainer === document.body) {\n    //     console.log(offsetContainer, rootContainer, rootMatrixes);\n    // }\n    const isNext3d = isAbsolute3d || isRoot3d || is3d;\n    const n = isNext3d ? 4 : 3;\n    const isSVGGraphicElement = target.tagName.toLowerCase() !== \"svg\" && \"ownerSVGElement\" in target;\n    let targetMatrix = prevTargetMatrix;\n    // let allMatrix = prevMatrix ? convertDimension(prevMatrix, prevN!, n) : createIdentityMatrix(n);\n    // let rootMatrix = prevRootMatrix ? convertDimension(prevRootMatrix, prevN!, n) : createIdentityMatrix(n);\n    // let beforeMatrix = prevMatrix ? convertDimension(prevMatrix, prevN!, n) : createIdentityMatrix(n);\n    let allMatrix = createIdentityMatrix(n);\n    let rootMatrix = createIdentityMatrix(n);\n    let beforeMatrix = createIdentityMatrix(n);\n    let offsetMatrix = createIdentityMatrix(n);\n    const length = matrixes.length;\n\n    rootMatrixes.reverse();\n    matrixes.reverse();\n\n    if (!is3d && isNext3d) {\n        targetMatrix = convertDimension(targetMatrix, 3, 4);\n\n        convert3DMatrixes(matrixes);\n    }\n    if (!isRoot3d && isNext3d) {\n        convert3DMatrixes(rootMatrixes);\n    }\n\n    // rootMatrix = (...) -> container -> offset -> absolute -> offset -> absolute(targetMatrix)\n    // rootMatrixBeforeOffset = lastOffsetMatrix -> (...) -> container\n    // beforeMatrix = (... -> container -> offset -> absolute) -> offset -> absolute(targetMatrix)\n    // offsetMatrix = (... -> container -> offset -> absolute -> offset) -> absolute(targetMatrix)\n\n    rootMatrixes.forEach(info => {\n        rootMatrix = multiply(rootMatrix, info.matrix!, n);\n    });\n    const originalRootContainer = rootContainer || document.body;\n    const endContainer = rootMatrixes[0]?.target\n        || getOffsetInfo(originalRootContainer, originalRootContainer, true).offsetParent;\n    const rootMatrixBeforeOffset = rootMatrixes.slice(1).reduce((matrix, info) => {\n        return multiply(matrix, info.matrix!, n);\n    }, createIdentityMatrix(n));\n    matrixes.forEach((info, i) => {\n        if (length - 2 === i) {\n            // length - 3\n            beforeMatrix = allMatrix.slice();\n        }\n        if (length - 1 === i) {\n            // length - 2\n            offsetMatrix = allMatrix.slice();\n        }\n\n        // calculate for SVGElement\n        if (!info.matrix) {\n            const nextInfo = matrixes[i + 1];\n            const offset = getSVGOffset(\n                info,\n                nextInfo,\n                endContainer,\n                n,\n                multiply(rootMatrixBeforeOffset, allMatrix, n),\n            );\n            info.matrix = createOriginMatrix(offset, n);\n        }\n        allMatrix = multiply(allMatrix, info.matrix!, n);\n    });\n    const isMatrix3d = !isSVGGraphicElement && is3d;\n\n    if (!targetMatrix) {\n        targetMatrix = createIdentityMatrix(isMatrix3d ? 4 : 3);\n    }\n    const targetTransform = makeMatrixCSS(\n        isSVGGraphicElement && targetMatrix.length === 16\n            ? convertDimension(targetMatrix, 4, 3) : targetMatrix,\n        isMatrix3d,\n    );\n\n    rootMatrix = ignoreDimension(rootMatrix, n, n);\n\n    return {\n        hasFixed,\n        rootMatrix,\n        beforeMatrix,\n        offsetMatrix,\n        allMatrix,\n        targetMatrix,\n        targetTransform,\n        transformOrigin,\n        targetOrigin,\n        is3d: isNext3d,\n        offsetContainer,\n        offsetRootContainer,\n    };\n}\n","import { createIdentityMatrix } from \"@scena/matrix\";\nimport { ElementSizes, MoveablePosition } from \"../types\";\nimport { calculateMoveablePosition, getSize, getRotationRad } from \"../utils\";\nimport { calculateMatrixStack, MoveableElementMatrixInfo } from \"./calculateMatrixStack\";\n\nexport interface MoveableElementInfo extends MoveableElementMatrixInfo, MoveablePosition, ElementSizes {\n    width: number;\n    height: number;\n    rotation: number;\n}\n\nexport function calculateElementInfo(\n    target?: SVGElement | HTMLElement | null,\n    container?: SVGElement | HTMLElement | null,\n    rootContainer: HTMLElement | SVGElement | null | undefined = container,\n    isAbsolute3d?: boolean,\n): MoveableElementInfo {\n    let width = 0;\n    let height = 0;\n    let rotation = 0;\n    let allResult: {} = {};\n\n    const sizes = getSize(target);\n\n    if (target) {\n        width = sizes.offsetWidth;\n        height = sizes.offsetHeight;\n    }\n\n    if (target) {\n        const result = calculateMatrixStack(\n            target,\n            container,\n            rootContainer,\n            isAbsolute3d,\n            // prevMatrix, prevRootMatrix, prevN,\n        );\n\n        const position = calculateMoveablePosition(\n            result.allMatrix,\n            result.transformOrigin,\n            width, height,\n        );\n        allResult = {\n            ...result,\n            ...position,\n        };\n        const rotationPosition = calculateMoveablePosition(\n            result.allMatrix, [50, 50], 100, 100,\n        );\n        rotation = getRotationRad([rotationPosition.pos1, rotationPosition.pos2], rotationPosition.direction);\n    }\n    const n = isAbsolute3d ? 4 : 3;\n\n    return {\n        width,\n        height,\n        rotation,\n        ...sizes,\n        rootMatrix: createIdentityMatrix(n),\n        beforeMatrix: createIdentityMatrix(n),\n        offsetMatrix: createIdentityMatrix(n),\n        allMatrix: createIdentityMatrix(n),\n        targetMatrix: createIdentityMatrix(n),\n        targetTransform: \"\",\n        transformOrigin: [0, 0],\n        targetOrigin: [0, 0],\n        is3d: !!isAbsolute3d,\n        left: 0,\n        top: 0,\n        right: 0,\n        bottom: 0,\n        origin: [0, 0],\n        pos1: [0, 0],\n        pos2: [0, 0],\n        pos3: [0, 0],\n        pos4: [0, 0],\n        direction: 1,\n        hasFixed: false,\n        offsetContainer: null,\n        offsetRootContainer: null,\n        ...allResult,\n    };\n}\n\n\nexport function getElementInfo(\n    target: SVGElement | HTMLElement,\n    container?: SVGElement | HTMLElement | null,\n    rootContainer: SVGElement | HTMLElement | null | undefined = container,\n) {\n    return calculateElementInfo(target, container, rootContainer, true);\n}\n","import { plus, getOrigin } from \"@scena/matrix\";\nimport { MoveableClientRect } from \"../types\";\nimport {\n    calculateMoveablePosition,\n    getClientRect, getOffsetInfo, resetClientRect,\n} from \"../utils\";\nimport { calculateElementInfo, MoveableElementInfo } from \"./getElementInfo\";\n\n\nexport interface MoveableTargetInfo extends MoveableElementInfo {\n    targetClientRect: MoveableClientRect;\n    containerClientRect: MoveableClientRect;\n    moveableClientRect: MoveableClientRect;\n    rootContainerClientRect: MoveableClientRect;\n    beforeDirection: 1 | -1;\n    beforeOrigin: number[];\n    originalBeforeOrigin: number[];\n    target: HTMLElement | SVGElement | null | undefined;\n}\n\nexport function getMoveableTargetInfo(\n    moveableElement?: HTMLElement | null,\n    target?: HTMLElement | SVGElement | null,\n    container?: HTMLElement | SVGElement | null,\n    parentContainer?: HTMLElement | SVGElement | null,\n    rootContainer?: HTMLElement | SVGElement | null,\n    // state?: Partial<MoveableManagerState> | false | undefined,\n): MoveableTargetInfo {\n    let beforeDirection: 1 | -1 = 1;\n    let beforeOrigin = [0, 0];\n    let targetClientRect = resetClientRect();\n    let moveableClientRect = resetClientRect();\n    let containerClientRect = resetClientRect();\n    let rootContainerClientRect = resetClientRect();\n\n    const result = calculateElementInfo(\n        target, container!, rootContainer!,\n        true,\n    );\n    if (target) {\n        const n = result.is3d ? 4 : 3;\n        const beforePosition = calculateMoveablePosition(\n            result.offsetMatrix,\n            plus(result.transformOrigin, getOrigin(result.targetMatrix, n)),\n            result.width, result.height,\n        );\n        beforeDirection = beforePosition.direction;\n        beforeOrigin = plus(\n            beforePosition.origin,\n            [beforePosition.left - result.left, beforePosition.top - result.top],\n        );\n\n        targetClientRect = getClientRect(target);\n        const offsetContainer = getOffsetInfo(parentContainer, parentContainer, true).offsetParent\n            || result.offsetRootContainer!;\n        containerClientRect = getClientRect(offsetContainer, true);\n        rootContainerClientRect = getClientRect(result.offsetRootContainer!);\n        if (moveableElement) {\n            moveableClientRect = getClientRect(moveableElement);\n        }\n    }\n\n    return {\n        targetClientRect,\n        containerClientRect,\n        moveableClientRect,\n        rootContainerClientRect,\n        beforeDirection,\n        beforeOrigin,\n        originalBeforeOrigin: beforeOrigin,\n        target,\n        ...result,\n    };\n}\n","import * as React from \"react\";\nimport { createElement } from \"react\";\nimport { PREFIX } from \"./consts\";\nimport {\n    prefix,\n    unset,\n    getAbsolutePosesByState,\n    getRect,\n    filterAbles,\n    equals,\n    flat,\n    groupByMap,\n    calculatePadding,\n    getAbsoluteRotation,\n    defaultSync,\n} from \"./utils\";\nimport Gesto from \"gesto\";\nimport { ref } from \"framework-utils\";\nimport {\n    MoveableManagerProps, MoveableManagerState, Able,\n    RectInfo, Requester, PaddingBox, HitRect, MoveableManagerInterface,\n    MoveableDefaultOptions,\n    GroupableProps,\n} from \"./types\";\nimport { triggerAble, getTargetAbleGesto, getAbleGesto } from \"./gesto/getAbleGesto\";\nimport { plus } from \"@scena/matrix\";\nimport { cancelAnimationFrame, find, getKeys, IObject, requestAnimationFrame } from \"@daybrush/utils\";\nimport { renderLine } from \"./renderDirections\";\nimport { fitPoints, getAreaSize, getOverlapSize, isInside } from \"overlap-area\";\nimport EventManager from \"./EventManager\";\nimport styled from \"react-css-styled\";\nimport EventEmitter from \"@scena/event-emitter\";\nimport { getMoveableTargetInfo } from \"./utils/getMoveableTargetInfo\";\n\nexport default class MoveableManager<T = {}>\n    extends React.PureComponent<MoveableManagerProps<T>, MoveableManagerState> {\n    public static defaultProps: Required<MoveableManagerProps> = {\n        target: null,\n        dragTarget: null,\n        container: null,\n        rootContainer: null,\n        origin: true,\n        parentMoveable: null,\n        wrapperMoveable: null,\n        parentPosition: null,\n        portalContainer: null,\n        useResizeObserver: false,\n        ables: [],\n        pinchThreshold: 20,\n        dragArea: false,\n        passDragArea: false,\n        transformOrigin: \"\",\n        className: \"\",\n        zoom: 1,\n        triggerAblesSimultaneously: false,\n        padding: {},\n        pinchOutside: true,\n        checkInput: false,\n        groupable: false,\n        hideDefaultLines: false,\n        cspNonce: \"\",\n        translateZ: 0,\n        cssStyled: null,\n        customStyledMap: {},\n        props: {},\n        stopPropagation: false,\n        preventClickDefault: false,\n        preventClickEventOnDrag: true,\n        flushSync: defaultSync,\n    };\n    public state: MoveableManagerState = {\n        container: null,\n        gestos: {},\n        renderPoses: [[0, 0], [0, 0], [0, 0], [0, 0]],\n        disableNativeEvent: false,\n        ...getMoveableTargetInfo(null),\n    };\n    public renderState: Record<string, any> = {};\n    public enabledAbles: Able[] = [];\n    public targetAbles: Able[] = [];\n    public controlAbles: Able[] = [];\n    public controlBox!: { getElement(): HTMLElement };\n    public areaElement!: HTMLElement;\n    public targetGesto!: Gesto;\n    public controlGesto!: Gesto;\n    public rotation = 0;\n    public scale: number[] = [1, 1];\n    public isUnmounted = false;\n    public events: Record<string, EventManager | null> = {\n        \"mouseEnter\": null,\n        \"mouseLeave\": null,\n    };\n\n    protected _emitter: EventEmitter = new EventEmitter();\n    protected _prevTarget: HTMLElement | SVGElement | null | undefined = null;\n    protected _prevDragArea = false;\n\n    private _observer: ResizeObserver | null = null;\n    private _observerId = 0;\n\n    public render() {\n        const props = this.props;\n        const state = this.state;\n        const {\n            parentPosition, className,\n            target: propsTarget,\n            zoom, cspNonce,\n            translateZ,\n            cssStyled: ControlBoxElement,\n            portalContainer,\n        } = props;\n\n        this.checkUpdate();\n        this.updateRenderPoses();\n\n        const { left: parentLeft, top: parentTop } = parentPosition! || { left: 0, top: 0 };\n        const {\n            left,\n            top,\n            target: stateTarget,\n            direction,\n            hasFixed,\n        } = state;\n        const groupTargets = (props as any).targets;\n        const isDisplay = ((groupTargets && groupTargets.length) || propsTarget) && stateTarget;\n        const isDragging = this.isDragging();\n        const ableAttributes: IObject<boolean> = {};\n        this.getEnabledAbles().forEach(able => {\n            ableAttributes[`data-able-${able.name.toLowerCase()}`] = true;\n        });\n        return (\n            <ControlBoxElement\n                cspNonce={cspNonce}\n                ref={ref(this, \"controlBox\")}\n                className={`${prefix(\"control-box\", direction === -1\n                    ? \"reverse\" : \"\", isDragging ? \"dragging\" : \"\")} ${className}`}\n                {...ableAttributes}\n                onClick={this.onPreventClick}\n                portalContainer={portalContainer}\n                style={{\n                    \"position\": hasFixed ? \"fixed\" : \"absolute\",\n                    \"display\": isDisplay ? \"block\" : \"none\",\n                    \"transform\": `translate3d(${left - parentLeft}px, ${top - parentTop}px, ${translateZ})`,\n                    \"--zoom\": zoom,\n                    \"--zoompx\": `${zoom}px`,\n                }}>\n                {this.renderAbles()}\n                {this._renderLines()}\n            </ControlBoxElement>\n        );\n    }\n    public componentDidMount() {\n        this.isUnmounted = false;\n        this.controlBox.getElement();\n        const props = this.props;\n        const { parentMoveable, container, wrapperMoveable } = props;\n\n        this._updateTargets();\n        this._updateNativeEvents();\n        this._updateEvents();\n\n        if (!container && !parentMoveable && !wrapperMoveable) {\n            this.updateRect(\"\", false, true);\n        }\n        this.updateCheckInput();\n        this._updateObserver(this.props);\n    }\n    public componentDidUpdate(prevProps: any) {\n        this._updateNativeEvents();\n        this._updateEvents();\n        this._updateTargets();\n        this.updateCheckInput();\n        this._updateObserver(prevProps);\n    }\n    public componentWillUnmount() {\n        this.isUnmounted = true;\n        this._emitter.off();\n        unset(this, \"targetGesto\");\n        unset(this, \"controlGesto\");\n\n        const events = this.events;\n        for (const name in events) {\n            const manager = events[name];\n            manager && manager.destroy();\n        }\n    }\n    /**\n     * Get the able used in MoveableManager.\n     * @method Moveable#getAble\n     * @param - able name\n     */\n    public getAble<T extends Able>(ableName: string): T | undefined {\n        const ables: Able[] = this.props.ables || [];\n\n        return find(ables, able => able.name === ableName) as T;\n    }\n    public getContainer(): HTMLElement | SVGElement {\n        const { parentMoveable, wrapperMoveable, container } = this.props;\n\n        return container!\n            || (wrapperMoveable && wrapperMoveable.getContainer())\n            || (parentMoveable && parentMoveable.getContainer())\n            || this.controlBox.getElement().parentElement!;\n    }\n    /**\n     * Check if the target is an element included in the moveable.\n     * @method Moveable#isMoveableElement\n     * @param - the target\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * window.addEventListener(\"click\", e => {\n     *     if (!moveable.isMoveableElement(e.target)) {\n     *         moveable.target = e.target;\n     *     }\n     * });\n     */\n    public isMoveableElement(target: Element) {\n        return target && (target.getAttribute(\"class\") || \"\").indexOf(PREFIX) > -1;\n    }\n    /**\n     * You can drag start the Moveable through the external `MouseEvent`or `TouchEvent`. (Angular: ngDragStart)\n     * @method Moveable#dragStart\n     * @param - external `MouseEvent`or `TouchEvent`\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * document.body.addEventListener(\"mousedown\", e => {\n     *     if (!moveable.isMoveableElement(e.target)) {\n     *          moveable.dragStart(e);\n     *     }\n     * });\n     */\n    public dragStart(e: MouseEvent | TouchEvent) {\n        const targetGesto = this.targetGesto;\n\n        if (targetGesto && !targetGesto.isFlag()) {\n            targetGesto.triggerDragStart(e);\n        }\n        return this;\n    }\n    /**\n     * Hit test an element or rect on a moveable target.\n     * @method Moveable#hitTest\n     * @param - element or rect to test\n     * @return - Get hit test rate (rate > 0 is hitted)\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * document.body.addEventListener(\"mousedown\", e => {\n     *     if (moveable.hitTest(e.target) > 0) {\n     *          console.log(\"hiited\");\n     *     }\n     * });\n     */\n    public hitTest(el: Element | HitRect): number {\n        const { target, pos1, pos2, pos3, pos4, targetClientRect } = this.state;\n\n        if (!target) {\n            return 0;\n        }\n        let rect: Required<HitRect>;\n\n        if (el instanceof Element) {\n            const clientRect = el.getBoundingClientRect();\n\n            rect = {\n                left: clientRect.left,\n                top: clientRect.top,\n                width: clientRect.width,\n                height: clientRect.height,\n            };\n        } else {\n            rect = { width: 0, height: 0, ...el };\n        }\n\n        const {\n            left: rectLeft,\n            top: rectTop,\n            width: rectWidth,\n            height: rectHeight,\n        } = rect;\n        const points = fitPoints([pos1, pos2, pos4, pos3], targetClientRect);\n        const size = getOverlapSize(points, [\n            [rectLeft, rectTop],\n            [rectLeft + rectWidth, rectTop],\n            [rectLeft + rectWidth, rectTop + rectHeight],\n            [rectLeft, rectTop + rectHeight],\n        ]);\n        const totalSize = getAreaSize(points);\n\n        if (!size || !totalSize) {\n            return 0;\n        }\n\n        return Math.min(100, size / totalSize * 100);\n    }\n    /**\n     * Whether the coordinates are inside Moveable\n     * @method Moveable#isInside\n     * @param - x coordinate\n     * @param - y coordinate\n     * @return - True if the coordinate is in moveable or false\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * document.body.addEventListener(\"mousedown\", e => {\n     *     if (moveable.isInside(e.clientX, e.clientY)) {\n     *          console.log(\"inside\");\n     *     }\n     * });\n     */\n    public isInside(clientX: number, clientY: number) {\n        const { target, pos1, pos2, pos3, pos4, targetClientRect } = this.state;\n\n        if (!target) {\n            return false;\n        }\n        return isInside([clientX, clientY], fitPoints([pos1, pos2, pos4, pos3], targetClientRect));\n    }\n    /**\n     * If the width, height, left, and top of all elements change, update the shape of the moveable.\n     * @method Moveable#updateRect\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * window.addEventListener(\"resize\", e => {\n     *     moveable.updateRect();\n     * });\n     */\n    public updateRect(type?: \"Start\" | \"\" | \"End\", isTarget?: boolean, isSetState: boolean = true) {\n        const props = this.props;\n        const parentMoveable = props.parentMoveable;\n        const state = this.state;\n        const target = (state.target || this.props.target) as HTMLElement | SVGElement;\n        const container = this.getContainer();\n        const rootContainer = parentMoveable\n            ? parentMoveable.props.rootContainer\n            : props.rootContainer;\n        this.updateState(\n            getMoveableTargetInfo(this.controlBox && this.controlBox.getElement(),\n                target,\n                container,\n                container,\n                rootContainer || container,\n                // isTarget ? state : undefined\n            ),\n            parentMoveable ? false : isSetState,\n        );\n    }\n    /**\n     * Check if the moveable state is being dragged.\n     * @method Moveable#isDragging\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * // false\n     * console.log(moveable.isDragging());\n     *\n     * moveable.on(\"drag\", () => {\n     *   // true\n     *   console.log(moveable.isDragging());\n     * });\n     */\n    public isDragging() {\n        return (this.targetGesto ? this.targetGesto.isFlag() : false)\n            || (this.controlGesto ? this.controlGesto.isFlag() : false);\n    }\n    /**\n     * If the width, height, left, and top of the only target change, update the shape of the moveable.\n     * @method Moveable#updateTarget\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * moveable.updateTarget();\n     */\n    public updateTarget(type?: \"Start\" | \"\" | \"End\") {\n        this.updateRect(type, true);\n    }\n    /**\n     * You can get the vertex information, position and offset size information of the target based on the container.\n     * @method Moveable#getRect\n     * @return - The Rect Info\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * const rectInfo = moveable.getRect();\n     */\n    public getRect(): RectInfo {\n        const state = this.state;\n        const poses = getAbsolutePosesByState(this.state);\n        const [pos1, pos2, pos3, pos4] = poses;\n        const rect = getRect(poses);\n        const {\n            width: offsetWidth,\n            height: offsetHeight,\n        } = state;\n        const {\n            width,\n            height,\n            left,\n            top,\n        } = rect;\n        const statePos = [state.left, state.top];\n        const origin = plus(statePos, state.origin);\n        const beforeOrigin = plus(statePos, state.beforeOrigin);\n        const transformOrigin = state.transformOrigin;\n\n        return {\n            width,\n            height,\n            left,\n            top,\n            pos1,\n            pos2,\n            pos3,\n            pos4,\n            offsetWidth,\n            offsetHeight,\n            beforeOrigin,\n            origin,\n            transformOrigin,\n            rotation: this.getRotation(),\n        };\n    }\n    /**\n     * Get a manager that manages the moveable's state and props.\n     * @method Moveable#getManager\n     * @return - The Rect Info\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * const manager = moveable.getManager(); // real moveable class instance\n     */\n    public getManager(): MoveableManagerInterface<any, any> {\n        return this as any;\n    }\n    public getRotation() {\n        const {\n            pos1,\n            pos2,\n            direction,\n        } = this.state;\n\n        return getAbsoluteRotation(pos1, pos2, direction);\n    }\n    /**\n     * Request able through a method rather than an event.\n     * At the moment of execution, requestStart is executed,\n     * and then request and requestEnd can be executed through Requester.\n     * @method Moveable#request\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Draggable.html#request|Draggable Requester}\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Resizable.html#request|Resizable Requester}\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Scalable.html#request|Scalable Requester}\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Rotatable.html#request|Rotatable Requester}\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.OriginDraggable.html#request|OriginDraggable Requester}\n     * @param - ableName\n     * @param - request to be able params.\n     * @param - If isInstant is true, request and requestEnd are executed immediately.\n     * @return - Able Requester. If there is no request in able, nothing will work.\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * // Instantly Request (requestStart - request - requestEnd)\n     * moveable.request(\"draggable\", { deltaX: 10, deltaY: 10 }, true);\n     *\n     * // Start move\n     * const requester = moveable.request(\"draggable\");\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.requestEnd();\n     */\n    public request(ableName: string, param: IObject<any> = {}, isInstant?: boolean): Requester {\n        const { ables, groupable } = this.props as any;\n        const requsetAble: Able = ables!.filter((able: Able) => able.name === ableName)[0];\n\n        if (this.isDragging() || !requsetAble || !requsetAble.request) {\n            return {\n                request() {\n                    return this;\n                },\n                requestEnd() {\n                    return this;\n                },\n            };\n        }\n        const self = this;\n        const ableRequester = requsetAble.request(this);\n\n        const requestInstant = isInstant || param.isInstant;\n        const ableType = ableRequester.isControl ? \"controlAbles\" : \"targetAbles\";\n        const eventAffix = `${(groupable ? \"Group\" : \"\")}${ableRequester.isControl ? \"Control\" : \"\"}`;\n\n        const requester = {\n            request(ableParam: IObject<any>) {\n                triggerAble(self, ableType, \"drag\", eventAffix, \"\", {\n                    ...ableRequester.request(ableParam),\n                    requestAble: ableName,\n                    isRequest: true,\n                }, requestInstant);\n                return this;\n            },\n            requestEnd() {\n                triggerAble(self, ableType, \"drag\", eventAffix, \"End\", {\n                    ...ableRequester.requestEnd(),\n                    requestAble: ableName,\n                    isRequest: true,\n                }, requestInstant);\n                return this;\n            },\n        };\n\n        triggerAble(self, ableType, \"drag\", eventAffix, \"Start\", {\n            ...ableRequester.requestStart(param),\n            requestAble: ableName,\n            isRequest: true,\n        }, requestInstant);\n\n        return requestInstant ? requester.request(param).requestEnd() : requester;\n    }\n    /**\n     * Remove the Moveable object and the events.\n     * @method Moveable#destroy\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * moveable.destroy();\n     */\n    public destroy(): void {\n        this.componentWillUnmount();\n    }\n    public updateRenderPoses() {\n        const state = this.state;\n        const props = this.props;\n        const {\n            originalBeforeOrigin, transformOrigin,\n            allMatrix, is3d,\n            pos1, pos2, pos3, pos4,\n            left: stateLeft, top: stateTop,\n        } = state;\n        const {\n            left = 0,\n            top = 0,\n            bottom = 0,\n            right = 0,\n        } = (props.padding || {}) as PaddingBox;\n        const n = is3d ? 4 : 3;\n        const absoluteOrigin = (props as any).groupable\n            ? originalBeforeOrigin : plus(originalBeforeOrigin, [stateLeft, stateTop]);\n\n        state.renderPoses = [\n            plus(pos1, calculatePadding(allMatrix, [-left, -top], transformOrigin, absoluteOrigin, n)),\n            plus(pos2, calculatePadding(allMatrix, [right, -top], transformOrigin, absoluteOrigin, n)),\n            plus(pos3, calculatePadding(allMatrix, [-left, bottom], transformOrigin, absoluteOrigin, n)),\n            plus(pos4, calculatePadding(allMatrix, [right, bottom], transformOrigin, absoluteOrigin, n)),\n        ];\n    }\n    public checkUpdate() {\n        const { target, container, parentMoveable } = this.props;\n        const {\n            target: stateTarget,\n            container: stateContainer,\n        } = this.state;\n\n        if (!stateTarget && !target) {\n            return;\n        }\n        this.updateAbles();\n\n        const isChanged = !equals(stateTarget, target) || !equals(stateContainer, container);\n\n        if (!isChanged) {\n            return;\n        }\n        const moveableContainer = container || this.controlBox;\n\n        if (moveableContainer) {\n            this.unsetAbles();\n        }\n        this.updateState({ target, container });\n\n        if (!parentMoveable && moveableContainer) {\n            this.updateRect(\"End\", false, false);\n        }\n    }\n    public triggerEvent(name: string, e: any): any {\n        this._emitter.trigger(name, e);\n        const callback = (this.props as any)[name];\n\n        return callback && callback(e);\n    }\n    public useCSS(tag: string, css: string) {\n        const customStyleMap = this.props.customStyledMap as Record<string, any>;\n\n        const key = tag + css;\n\n        if (!customStyleMap[key]) {\n            customStyleMap[key] = styled(tag, css);\n        }\n        return customStyleMap[key];\n    }\n    public onPreventClick = (e: any) => {\n        e.stopPropagation();\n        e.preventDefault();\n        // removeEvent(window, \"click\", this.onPreventClick, true);\n    }\n    public checkUpdateRect = () => {\n        if (this.isDragging()) {\n            return;\n        }\n        const parentMoveable = this.props.parentMoveable;\n\n        if (parentMoveable) {\n            (parentMoveable as MoveableManager).checkUpdateRect();\n            return;\n        }\n        cancelAnimationFrame(this._observerId);\n        this._observerId = requestAnimationFrame(() => {\n            if (this.isDragging()) {\n                return;\n            }\n            this.updateRect();\n        });\n    }\n    protected unsetAbles() {\n        this.targetAbles.forEach(able => {\n            if (able.unset) {\n                able.unset(this);\n            }\n        });\n    }\n    protected updateAbles(\n        ables: Able[] = this.props.ables!,\n        eventAffix: string = \"\",\n    ) {\n        const props = this.props as any;\n        const triggerAblesSimultaneously = props.triggerAblesSimultaneously;\n        const enabledAbles = ables!.filter(able => able && (\n            (able.always && props[able.name] !== false)\n            || props[able.name]));\n\n        const dragStart = `drag${eventAffix}Start` as \"dragStart\";\n        const pinchStart = `pinch${eventAffix}Start` as \"pinchStart\";\n        const dragControlStart = `drag${eventAffix}ControlStart` as \"dragControlStart\";\n\n        const targetAbles = filterAbles(enabledAbles, [dragStart, pinchStart], triggerAblesSimultaneously);\n        const controlAbles = filterAbles(enabledAbles, [dragControlStart], triggerAblesSimultaneously);\n\n        this.enabledAbles = enabledAbles;\n        this.targetAbles = targetAbles;\n        this.controlAbles = controlAbles;\n    }\n    protected updateState(nextState: any, isSetState?: boolean) {\n        if (isSetState) {\n            if (this.isUnmounted) {\n                return;\n            }\n            this.setState(nextState);\n        } else {\n            const state = this.state;\n\n            for (const name in nextState) {\n                (state as any)[name] = nextState[name];\n            }\n        }\n    }\n    protected getEnabledAbles() {\n        const props = this.props as any;\n        const ables: Able[] = props.ables!;\n        return ables.filter(able => able && props[able.name]);\n    }\n    protected renderAbles() {\n        const props = this.props as any;\n        const triggerAblesSimultaneously = props.triggerAblesSimultaneously;\n        const Renderer = {\n            createElement,\n        };\n\n        this.renderState = {};\n\n        return groupByMap(flat<any>(\n            filterAbles(this.getEnabledAbles(), [\"render\"], triggerAblesSimultaneously).map(({ render }) => {\n                return render!(this, Renderer) || [];\n            })).filter(el => el), ({ key }) => key).map(group => group[0]);\n    }\n    protected updateCheckInput() {\n        this.targetGesto && (this.targetGesto.options.checkInput = this.props.checkInput);\n    }\n    protected _updateObserver(prevProps: MoveableDefaultOptions) {\n        const props = this.props;\n        const target = props.target;\n\n        if (!window.ResizeObserver || !target || !props.useResizeObserver) {\n            this._observer?.disconnect();\n            return;\n        }\n\n        if (prevProps.target === target && this._observer) {\n            return;\n        }\n\n        const observer = new ResizeObserver(this.checkUpdateRect);\n\n        observer.observe(target!, {\n            box: \"border-box\",\n        });\n        this._observer = observer;\n\n        return;\n    }\n    protected _updateEvents() {\n        const controlBoxElement = this.controlBox.getElement();\n        const hasTargetAble = this.targetAbles.length;\n        const hasControlAble = this.controlAbles.length;\n        const props = this.props;\n        const target = props.dragTarget || props.target;\n        const isUnset = (!hasTargetAble && this.targetGesto)\n            || this._isTargetChanged(true);\n\n        if (isUnset) {\n            unset(this, \"targetGesto\");\n            this.updateState({ gesto: null });\n        }\n        if (!hasControlAble) {\n            unset(this, \"controlGesto\");\n        }\n\n        if (target && hasTargetAble && !this.targetGesto) {\n            this.targetGesto = getTargetAbleGesto(this, target!, \"\");\n        }\n        if (!this.controlGesto && hasControlAble) {\n            this.controlGesto = getAbleGesto(this, controlBoxElement, \"controlAbles\", \"Control\");\n        }\n    }\n    protected _updateTargets() {\n        const props = this.props;\n\n        this._prevTarget = props.dragTarget || props.target;\n        this._prevDragArea = props.dragArea!;\n    }\n    private _renderLines() {\n        const props = this.props;\n        const {\n            zoom,\n            hideDefaultLines,\n            hideChildMoveableDefaultLines,\n            parentMoveable,\n        } = props as MoveableManagerProps<GroupableProps>;\n\n        if (hideDefaultLines || (parentMoveable && hideChildMoveableDefaultLines)) {\n            return [];\n        }\n        const renderPoses = this.state.renderPoses;\n        const Renderer = {\n            createElement,\n        };\n\n        return [\n            [0, 1],\n            [1, 3],\n            [3, 2],\n            [2, 0],\n        ].map(([from, to], i) => {\n            return renderLine(Renderer, \"\", renderPoses[from], renderPoses[to], zoom!, i);\n        });\n    }\n    private _isTargetChanged(useDragArea?: boolean) {\n        const props = this.props;\n        const target = props.dragTarget || props.target;\n        const prevTarget = this._prevTarget;\n        const prevDragArea = this._prevDragArea;\n        const dragArea = props.dragArea;\n\n        // check target without dragArea\n        const isTargetChanged = !dragArea && prevTarget !== target;\n        const isDragAreaChanged = (useDragArea || dragArea) && prevDragArea !== dragArea;\n\n        return isTargetChanged || isDragAreaChanged;\n    }\n    private _updateNativeEvents() {\n        const props = this.props;\n        const target = props.dragArea ? this.areaElement : this.state.target;\n        const events = this.events;\n        const eventKeys = getKeys(events);\n\n        if (this._isTargetChanged()) {\n            for (const eventName in events) {\n                const manager = events[eventName];\n                manager && manager.destroy();\n                events[eventName] = null;\n            }\n        }\n        if (!target) {\n            return;\n        }\n        const enabledAbles = this.enabledAbles;\n        eventKeys.forEach(eventName => {\n            const ables = filterAbles(enabledAbles, [eventName] as any);\n            const hasAbles = ables.length > 0;\n            let manager = events[eventName];\n\n            if (!hasAbles) {\n                if (manager) {\n                    manager.destroy();\n                    events[eventName] = null;\n                }\n                return;\n            }\n            if (!manager) {\n                manager = new EventManager(target, this, eventName);\n                events[eventName] = manager;\n            }\n            manager.setAbles(ables);\n        });\n    }\n}\n\n/**\n * The target to indicate Moveable Control Box.\n * @name Moveable#target\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.target = document.querySelector(\".target\");\n */\n/**\n * Zooms in the elements of a moveable.\n * @name Moveable#zoom\n * @default 1\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.zoom = 2;\n */\n\n/**\n * Whether the target size is detected and updated whenever it changes.\n * @name Moveable#useResizeObserver\n * @default false\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.useResizeObserver = true;\n */\n\n/**\n * Resize, Scale Events at edges\n * @name Moveable#edge\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.edge = true;\n */\n\n/**\n * You can specify the className of the moveable controlbox.\n * @name Moveable#className\n * @default \"\"\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   className: \"\",\n * });\n *\n * moveable.className = \"moveable1\";\n */\n\n/**\n * The target(s) to drag Moveable target(s)\n * @name Moveable#dragTarget\n * @default target\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.target = document.querySelector(\".target\");\n * moveable.dragTarget = document.querySelector(\".dragTarget\");\n */\n\n/**\n * `renderStart` event occurs at the first start of all events.\n * @memberof Moveable\n * @event renderStart\n * @param {Moveable.OnRenderStart} - Parameters for the `renderStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"renderStart\", ({ target }) => {\n *     console.log(\"onRenderStart\", target);\n * });\n */\n\n/**\n * `render` event occurs before the target is drawn on the screen.\n * @memberof Moveable\n * @event render\n * @param {Moveable.OnRender} - Parameters for the `render` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"render\", ({ target }) => {\n *     console.log(\"onRender\", target);\n * });\n */\n\n/**\n * `renderEnd` event occurs at the end of all events.\n * @memberof Moveable\n * @event renderEnd\n * @param {Moveable.OnRenderEnd} - Parameters for the `renderEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"renderEnd\", ({ target }) => {\n *     console.log(\"onRenderEnd\", target);\n * });\n */\n\n/**\n * `renderGroupStart` event occurs at the first start of all events in group.\n * @memberof Moveable\n * @event renderGroupStart\n * @param {Moveable.OnRenderGroupStart} - Parameters for the `renderGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"renderGroupStart\", ({ targets }) => {\n *     console.log(\"onRenderGroupStart\", targets);\n * });\n */\n\n/**\n * `renderGroup` event occurs before the target is drawn on the screen in group.\n * @memberof Moveable\n * @event renderGroup\n * @param {Moveable.OnRenderGroup} - Parameters for the `renderGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"renderGroup\", ({ targets }) => {\n *     console.log(\"onRenderGroup\", targets);\n * });\n */\n\n/**\n * `renderGroupEnd` event occurs at the end of all events in group.\n * @memberof Moveable\n * @event renderGroupEnd\n * @param {Moveable.OnRenderGroupEnd} - Parameters for the `renderGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"renderGroupEnd\", ({ targets }) => {\n *     console.log(\"onRenderGroupEnd\", targets);\n * });\n */\n","import { refs } from \"framework-utils\";\nimport MoveableManager from \"../MoveableManager\";\nimport { Renderer, MoveableGroupInterface, GroupableProps } from \"../types\";\n\nexport default {\n    name: \"groupable\",\n    props: {\n        defaultGroupRotate: Number,\n        defaultGroupOrigin: String,\n        groupable: Boolean,\n        hideChildMoveableDefaultLines: Boolean,\n    } as const,\n    events: {} as const,\n    render(moveable: MoveableGroupInterface<GroupableProps>, React: Renderer): any[] {\n        const targets = moveable.props.targets || [];\n\n        moveable.moveables = [];\n        const { left, top } = moveable.state;\n        const position = { left, top };\n        const props = moveable.props;\n\n        return targets.map((target, i) => {\n            return <MoveableManager<GroupableProps>\n                key={\"moveable\" + i}\n                ref={refs(moveable, \"moveables\", i)}\n                target={target}\n                origin={false}\n                cssStyled={props.cssStyled}\n                customStyledMap={props.customStyledMap}\n                useResizeObserver={props.useResizeObserver}\n                hideChildMoveableDefaultLines={props.hideChildMoveableDefaultLines}\n                parentMoveable={moveable}\n                parentPosition={position}\n            />;\n        });\n    },\n};\n","import {\n    MoveableManagerInterface, MoveableGroupInterface,\n    ClickableProps, OnClick, OnClickGroup,\n} from \"../types\";\nimport { triggerEvent, fillParams } from \"../utils\";\nimport { findIndex } from \"@daybrush/utils\";\nimport { makeAble } from \"./AbleManager\";\n\nexport default makeAble(\"clickable\", {\n    props: {\n        clickable: Boolean,\n    },\n    events: {\n        onClick: \"click\",\n        onClickGroup: \"clickGroup\",\n    } as const,\n    always: true,\n    dragRelation: \"weak\",\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    dragStart() {\n        return;\n    },\n    dragControlStart() {\n        this.dragStart();\n    },\n    dragGroupStart(moveable: MoveableManagerInterface<ClickableProps>, e: any) {\n        e.datas.inputTarget = e.inputEvent && e.inputEvent.target;\n    },\n    dragEnd(moveable: MoveableManagerInterface<ClickableProps>, e: any) {\n        const target = moveable.state.target!;\n        const inputEvent = e.inputEvent;\n        const inputTarget = e.inputTarget;\n        const isMoveableElement = moveable.isMoveableElement(inputTarget);\n        const containsElement = !isMoveableElement && moveable.controlBox.getElement().contains(inputTarget);\n\n        if (\n            !inputEvent || !inputTarget || e.isDrag\n            || moveable.isMoveableElement(inputTarget)\n            || containsElement\n            // External event duplicate target or dragAreaElement\n        ) {\n            return;\n        }\n        const containsTarget = target.contains(inputTarget);\n\n        triggerEvent(moveable, \"onClick\", fillParams<OnClick>(moveable, e, {\n            isDouble: e.isDouble,\n            inputTarget,\n            isTarget: target === inputTarget,\n            containsTarget,\n        }));\n    },\n    dragGroupEnd(moveable: MoveableGroupInterface<ClickableProps>, e: any) {\n        const inputEvent = e.inputEvent;\n        const inputTarget = e.inputTarget;\n\n        if (\n            !inputEvent || !inputTarget || e.isDrag\n            || moveable.isMoveableElement(inputTarget)\n            // External event duplicate target or dragAreaElement\n            || e.datas.inputTarget === inputTarget\n        ) {\n            return;\n        }\n        const targets = moveable.props.targets!;\n        let targetIndex = targets.indexOf(inputTarget);\n        const isTarget = targetIndex > -1;\n        let containsTarget = false;\n\n        if (targetIndex === -1) {\n            targetIndex = findIndex(targets, parentTarget => parentTarget.contains(inputTarget));\n            containsTarget = targetIndex > -1;\n        }\n\n        triggerEvent(moveable, \"onClickGroup\", fillParams<OnClickGroup>(moveable, e, {\n            isDouble: e.isDouble,\n            targets,\n            inputTarget,\n            targetIndex,\n            isTarget,\n            containsTarget,\n        }));\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<ClickableProps>, e: any) {\n        this.dragEnd(moveable, e);\n    },\n    dragGroupControlEnd(moveable: MoveableManagerInterface<ClickableProps>, e: any) {\n        this.dragEnd(moveable, e);\n    },\n});\n\n/**\n * When you click on the element, the `click` event is called.\n * @memberof Moveable\n * @event click\n * @param {Moveable.OnClick} - Parameters for the `click` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"click\", ({ hasTarget, containsTarget, targetIndex }) => {\n *     // If you click on an element other than the target and not included in the target, index is -1.\n *     console.log(\"onClickGroup\", target, hasTarget, containsTarget, targetIndex);\n * });\n */\n\n/**\n * When you click on the element inside the group, the `clickGroup` event is called.\n * @memberof Moveable\n * @event clickGroup\n * @param {Moveable.OnClickGroup} - Parameters for the `clickGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"clickGroup\", ({ inputTarget, isTarget, containsTarget, targetIndex }) => {\n *     // If you click on an element other than the target and not included in the target, index is -1.\n *     console.log(\"onClickGroup\", inputTarget, isTarget, containsTarget, targetIndex);\n * });\n */\n","import { hasClass } from \"@daybrush/utils\";\nimport { DraggableProps, MoveableGroupInterface, MoveableManagerInterface, Renderer } from \"../types\";\nimport { prefix } from \"../utils\";\nimport Draggable from \"./Draggable\";\nimport { makeAble } from \"./AbleManager\";\nimport { renderEdgeLines } from \"../renderDirections\";\n\nfunction getDraggableEvent(e: any) {\n    let datas = e.originalDatas.draggable;\n    if (!datas) {\n        e.originalDatas.draggable = {};\n        datas = e.originalDatas.draggable;\n    }\n    return { ...e, datas };\n}\nexport default makeAble(\"edgeDraggable\", {\n    css: [\n        `.edge.edgeDraggable.line {\n    cursor: move;\n}`,\n    ],\n    render(moveable: MoveableManagerInterface<DraggableProps>, React: Renderer) {\n        const props = moveable.props;\n        const edge = props.edgeDraggable!;\n\n        if (!edge) {\n            return [];\n        }\n        return renderEdgeLines(\n            React,\n            \"edgeDraggable\",\n            edge,\n            moveable.state.renderPoses,\n            props.zoom!,\n        );\n    },\n    dragControlCondition(moveable: MoveableManagerInterface<DraggableProps>, e: any) {\n        if (!moveable.props.edgeDraggable || !e.inputEvent) {\n            return false;\n        }\n        const target = e.inputEvent.target;\n        return hasClass(target, prefix(\"direction\"))\n            && hasClass(target, prefix(\"edge\"))\n            && hasClass(target, prefix(\"edgeDraggable\"));\n    },\n    dragControlStart(moveable: MoveableManagerInterface<DraggableProps>, e: any) {\n        (moveable.state as any).snapRenderInfo = {\n            request: e.isRequest,\n            snap: true,\n            center: true,\n        };\n        return Draggable.dragStart(moveable, getDraggableEvent(e));\n    },\n    dragControl(moveable: MoveableManagerInterface<DraggableProps>, e: any) {\n        return Draggable.drag(moveable, getDraggableEvent(e));\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<DraggableProps, any>, e: any) {\n        return Draggable.dragEnd(moveable, getDraggableEvent(e));\n    },\n    dragGroupControlCondition(moveable: MoveableGroupInterface<DraggableProps>, e: any) {\n        if (!moveable.props.edgeDraggable || !e.inputEvent) {\n            return false;\n        }\n        const target = e.inputEvent.target;\n        return hasClass(target, prefix(\"direction\")) && hasClass(target, prefix(\"line\"));\n    },\n    dragGroupControlStart(moveable: MoveableGroupInterface<DraggableProps>, e: any) {\n        return Draggable.dragGroupStart(moveable, getDraggableEvent(e));\n    },\n    dragGroupControl(moveable: MoveableGroupInterface<DraggableProps>, e: any) {\n        return Draggable.dragGroup(moveable, getDraggableEvent(e));\n    },\n    dragGroupControlEnd(moveable: MoveableGroupInterface<DraggableProps, any>, e: any) {\n        return Draggable.dragGroupEnd(moveable, getDraggableEvent(e));\n    },\n    unset(moveable: any) {\n        return Draggable.unset(moveable);\n    },\n});\n\n/**\n * Whether to move by dragging the edge line (default: false)\n * @name Moveable.Draggable#edgeDraggable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  draggable: true,\n *  edgeDraggable: false,\n * });\n *\n * moveable.edgeDraggable = true;\n */\n","export default {\n    name: \"individualGroupable\",\n    props: {\n        individualGroupable: Boolean,\n    } as const,\n    events: {} as const,\n} as const;\n","import Pinchable from \"./Pinchable\";\nimport Rotatable from \"./Rotatable\";\nimport Draggable from \"./Draggable\";\nimport Resizable from \"./Resizable\";\nimport Scalable from \"./Scalable\";\nimport Warpable from \"./Warpable\";\nimport Snappable from \"./Snappable\";\nimport DragArea from \"./DragArea\";\nimport Origin from \"./Origin\";\nimport Scrollable from \"./Scrollable\";\nimport Default from \"./Default\";\nimport Padding from \"./Padding\";\nimport Clippable from \"./Clippable\";\nimport OriginDraggable from \"./OriginDraggable\";\nimport Roundable from \"./Roundable\";\nimport { UnionToIntersection } from \"../types\";\nimport { invertObject } from \"../utils\";\nimport Groupable from \"./Groupable\";\nimport BeforeRenderable from \"./BeforeRenderable\";\nimport Renderable from \"./Renderable\";\nimport Clickable from \"./Clickable\";\nimport edgeDraggable from \"./edgeDraggable\";\nimport IndividualGroupable from \"./IndividualGroupable\";\n\nexport const MOVEABLE_ABLES = /*#__PURE__*/[\n    BeforeRenderable,\n    Default, Snappable, Pinchable, Draggable, edgeDraggable,\n    Resizable, Scalable, Warpable, Rotatable, Scrollable, Padding, Origin,\n    OriginDraggable,\n    Clippable, Roundable, Groupable, IndividualGroupable,\n    Clickable,\n    DragArea,\n    Renderable,\n] as const;\n\nexport const MOVEABLE_EVENTS_PROPS_MAP = /*#__PURE__*/MOVEABLE_ABLES.reduce((current, able) => {\n    return {...current, ...(\"events\" in able ? able.events : {})};\n}, {}) as UnionToIntersection<typeof MOVEABLE_ABLES[number][\"events\"]>;\nexport const MOVEABLE_PROPS_MAP = /*#__PURE__*/MOVEABLE_ABLES.reduce((current, able) => {\n    return {...current, ...able.props};\n}, {}) as UnionToIntersection<typeof MOVEABLE_ABLES[number][\"props\"]>;\n\nexport const MOVEABLE_EVENTS_MAP = /*#__PURE__*/invertObject(MOVEABLE_EVENTS_PROPS_MAP);\nexport const MOVEABLE_EVENTS: string[] = /*#__PURE__*/Object.keys(MOVEABLE_EVENTS_MAP);\nexport const MOVEABLE_PROPS: string[] = /*#__PURE__*/Object.keys(MOVEABLE_PROPS_MAP);\n","import MoveableManager from \"./MoveableManager\";\nimport { GroupableProps, RectInfo } from \"./types\";\nimport ChildrenDiffer from \"@egjs/children-differ\";\nimport { getAbleGesto, getTargetAbleGesto } from \"./gesto/getAbleGesto\";\nimport Groupable from \"./ables/Groupable\";\nimport { MIN_NUM, MAX_NUM, TINY_NUM } from \"./consts\";\nimport { getAbsolutePosesByState, equals, unset } from \"./utils\";\nimport { minus, plus, rotate } from \"@scena/matrix\";\nimport { getMinMaxs } from \"overlap-area\";\nimport { throttle } from \"@daybrush/utils\";\nimport { getMoveableTargetInfo } from \"./utils/getMoveableTargetInfo\";\n\nfunction getMaxPos(poses: number[][][], index: number) {\n    return Math.max(...poses.map(([pos1, pos2, pos3, pos4]) => {\n        return Math.max(pos1[index], pos2[index], pos3[index], pos4[index]);\n    }));\n}\nfunction getMinPos(poses: number[][][], index: number) {\n    return Math.min(...poses.map(([pos1, pos2, pos3, pos4]) => {\n        return Math.min(pos1[index], pos2[index], pos3[index], pos4[index]);\n    }));\n}\nfunction getGroupRect(moveables: MoveableManager[], rotation: number) {\n    if (!moveables.length) {\n        return [0, 0, 0, 0];\n    }\n\n    const moveablePoses = moveables.map(({ state }) => getAbsolutePosesByState(state));\n    let minX = MAX_NUM;\n    let minY = MAX_NUM;\n    let groupWidth = 0;\n    let groupHeight = 0;\n    const fixedRotation = throttle(rotation, TINY_NUM);\n\n    if (fixedRotation % 90) {\n        const rad = fixedRotation / 180 * Math.PI;\n        const a1 = Math.tan(rad);\n        const a2 = -1 / a1;\n        const b1MinMax = [MIN_NUM, MAX_NUM];\n        const b2MinMax = [MIN_NUM, MAX_NUM];\n\n        moveablePoses.forEach(poses => {\n            poses.forEach(pos => {\n                // ax + b = y\n                // b = y - ax\n                const b1 = pos[1] - a1 * pos[0];\n                const b2 = pos[1] - a2 * pos[0];\n\n                b1MinMax[0] = Math.max(b1MinMax[0], b1);\n                b1MinMax[1] = Math.min(b1MinMax[1], b1);\n                b2MinMax[0] = Math.max(b2MinMax[0], b2);\n                b2MinMax[1] = Math.min(b2MinMax[1], b2);\n            });\n        });\n\n        b1MinMax.forEach(b1 => {\n            // a1x + b1 = a2x + b2\n            b2MinMax.forEach(b2 => {\n                // (a1 - a2)x = b2 - b1\n                const x = (b2 - b1) / (a1 - a2);\n                const y = a1 * x + b1;\n\n                minX = Math.min(minX, x);\n                minY = Math.min(minY, y);\n            });\n        });\n        const rotatePoses = moveablePoses.map(([pos1, pos2, pos3, pos4]) => {\n            return [\n                rotate(pos1, -rad),\n                rotate(pos2, -rad),\n                rotate(pos3, -rad),\n                rotate(pos4, -rad),\n            ];\n        });\n\n        groupWidth = getMaxPos(rotatePoses, 0) - getMinPos(rotatePoses, 0);\n        groupHeight = getMaxPos(rotatePoses, 1) - getMinPos(rotatePoses, 1);\n    } else {\n        minX = getMinPos(moveablePoses, 0);\n        minY = getMinPos(moveablePoses, 1);\n        groupWidth = getMaxPos(moveablePoses, 0) - minX;\n        groupHeight = getMaxPos(moveablePoses, 1) - minY;\n\n        if (fixedRotation % 180) {\n            const changedWidth = groupWidth;\n\n            groupWidth = groupHeight;\n            groupHeight = changedWidth;\n        }\n    }\n    return [minX, minY, groupWidth, groupHeight];\n}\n/**\n * @namespace Moveable.Group\n * @description You can make targets moveable.\n */\nclass MoveableGroup extends MoveableManager<GroupableProps> {\n    public static defaultProps = {\n        ...MoveableManager.defaultProps,\n        transformOrigin: [\"50%\", \"50%\"],\n        groupable: true,\n        dragArea: true,\n        keepRatio: true,\n        targets: [],\n        defaultGroupRotate: 0,\n        defaultGroupOrigin: \"50% 50%\",\n    };\n    public differ: ChildrenDiffer<HTMLElement | SVGElement> = new ChildrenDiffer();\n    public moveables: MoveableManager[] = [];\n    public transformOrigin = \"50% 50%\";\n\n    public checkUpdate() {\n        this.updateAbles();\n    }\n\n    public updateRect(type?: \"Start\" | \"\" | \"End\", isTarget?: boolean, isSetState = true) {\n        if (!this.controlBox) {\n            return;\n        }\n        this.moveables.forEach(moveable => {\n            moveable.updateRect(type, false, false);\n        });\n\n        const state = this.state;\n        const props = this.props;\n        const target = state.target! || props.target!;\n\n        if (!isTarget || (type !== \"\" && props.updateGroup)) {\n            // reset rotataion\n            this.rotation = props.defaultGroupRotate!;\n            this.transformOrigin = props.defaultGroupOrigin || \"50% 50%\";\n            this.scale = [1, 1];\n\n        }\n        const rotation = this.rotation;\n        const scale = this.scale;\n        const [left, top, width, height] = getGroupRect(this.moveables, rotation);\n\n        // tslint:disable-next-line: max-line-length\n        const transform = `rotate(${rotation}deg) scale(${scale[0] >= 0 ? 1 : -1}, ${scale[1] >= 0 ? 1 : -1})`;\n        target.style.cssText += `left:0px;top:0px; transform-origin: ${this.transformOrigin}; width:${width}px; height:${height}px;`\n            + `transform:${transform}`;\n        state.width = width;\n        state.height = height;\n\n        const container = this.getContainer();\n        const info = getMoveableTargetInfo(\n            this.controlBox.getElement(),\n            target,\n            this.controlBox.getElement(),\n            this.getContainer(),\n            this.props.rootContainer || container,\n            // state,\n        );\n        const pos = [info.left!, info.top!];\n        const [\n            pos1,\n            pos2,\n            pos3,\n            pos4,\n        ] = getAbsolutePosesByState(info); // info.left + info.pos(1 ~ 4)\n\n        const minPos = getMinMaxs([pos1, pos2, pos3, pos4]);\n        const delta = [minPos.minX, minPos.minY];\n        info.pos1 = minus(pos1, delta);\n        info.pos2 = minus(pos2, delta);\n        info.pos3 = minus(pos3, delta);\n        info.pos4 = minus(pos4, delta);\n        info.left = left - info.left! + delta[0];\n        info.top = top - info.top! + delta[1];\n        info.origin = minus(plus(pos, info.origin!), delta);\n        info.beforeOrigin = minus(plus(pos, info.beforeOrigin!), delta);\n        info.originalBeforeOrigin = plus(pos, info.originalBeforeOrigin!);\n        // info.transformOrigin = minus(plus(pos, info.transformOrigin!), delta);\n\n        const clientRect = info.targetClientRect!;\n        const direction = scale[0] * scale[1] > 0 ? 1 : -1;\n\n        clientRect.top += info.top - state.top;\n        clientRect.left += info.left - state.left;\n\n        target.style.transform = `translate(${-delta[0]}px, ${-delta[1]}px) ${transform}`;\n\n        this.updateState(\n            {\n                ...info,\n                direction,\n                beforeDirection: direction,\n            },\n            isSetState,\n        );\n    }\n    public getRect(): RectInfo {\n        return {\n            ...super.getRect(),\n            children: this.moveables.map(child => child.getRect()),\n        };\n    }\n    public triggerEvent(name: string, e: any, isManager?: boolean): any {\n        if (isManager || name.indexOf(\"Group\") > -1) {\n            return super.triggerEvent(name as any, e);\n        } else {\n            this._emitter.trigger(name, e);\n        }\n    }\n    protected updateAbles() {\n        super.updateAbles([...this.props.ables!, Groupable], \"Group\");\n    }\n    protected _updateTargets() {\n        super._updateTargets();\n        this._prevTarget = this.props.dragTarget || this.areaElement;\n    }\n    protected _updateEvents() {\n        const state = this.state;\n        const props = this.props;\n\n        const prevTarget = this._prevTarget;\n        const nextTarget = props.dragTarget || this.areaElement;\n\n        if (prevTarget !== nextTarget) {\n            unset(this, \"targetGesto\");\n            unset(this, \"controlGesto\");\n            state.target = null;\n        }\n        if (!state.target) {\n            state.target = this.areaElement;\n            this.controlBox.getElement().style.display = \"block\";\n        }\n        if (state.target) {\n            if (!this.targetGesto) {\n                this.targetGesto = getTargetAbleGesto(this, nextTarget, \"Group\");\n            }\n            if (!this.controlGesto) {\n                this.controlGesto = getAbleGesto(this, this.controlBox.getElement(), \"controlAbles\", \"GroupControl\");\n            }\n        }\n        const isContainerChanged = !equals(state.container, props.container);\n\n        if (isContainerChanged) {\n            state.container = props.container;\n        }\n        const { added, changed, removed } = this.differ.update(props.targets!);\n\n        if (isContainerChanged || added.length || changed.length || removed.length) {\n            this.updateRect();\n        }\n    }\n    protected _updateObserver() {}\n}\n\n/**\n * Sets the initial rotation of the group.\n * @name Moveable.Group#defaultGroupRotate\n * @default 0\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   target: [].slice.call(document.querySelectorAll(\".target\")),\n *   defaultGroupRotate: 0,\n * });\n *\n * moveable.defaultGroupRotate = 40;\n */\n\n/**\n * Sets the initial origin of the group.\n * @name Moveable.Group#defaultGroupOrigin\n * @default 0\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   target: [].slice.call(document.querySelectorAll(\".target\")),\n *   defaultGroupOrigin: \"50% 50%\",\n * });\n *\n * moveable.defaultGroupOrigin = \"20% 40%\";\n */\n\n\n/**\n * Whether to hide the line in child moveable for group corresponding to the rect of the target.\n * @name Moveable.Group#hideChildMoveableDefaultLines\n * @default false\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   target: [].slice.call(document.querySelectorAll(\".target\")),\n *   hideChildMoveableDefaultLines: false,\n * });\n *\n * moveable.hideChildMoveableDefaultLines = true;\n */\nexport default MoveableGroup;\n","import { ref, refs } from \"framework-utils\";\nimport * as React from \"react\";\nimport MoveableManager from \"./MoveableManager\";\nimport { GroupableProps, RectInfo } from \"./types\";\nimport { prefix } from \"./utils\";\n\n/**\n * @namespace Moveable.IndividualGroup\n * @description Create targets individually, not as a group.Create targets individually, not as a group.\n */\nclass MoveableIndividualGroup extends MoveableManager<GroupableProps> {\n    public moveables: MoveableManager[] = [];\n    public render() {\n        const {\n            cspNonce,\n            cssStyled: ControlBoxElement,\n            targets,\n        } = this.props;\n\n        return <ControlBoxElement\n            cspNonce={cspNonce}\n            ref={ref(this, \"controlBox\")}\n            className={prefix(\"control-box\")}>\n            {targets!.map((target, i) => {\n                return <MoveableManager\n                    key={\"moveable\" + i}\n                    ref={refs(this, \"moveables\", i)}\n                    {...this.props}\n                    target={target}\n                    wrapperMoveable={this}\n                />;\n            })}\n        </ControlBoxElement>;\n    }\n    public componentDidUpdate() {}\n    public updateRect(type?: \"Start\" | \"\" | \"End\", isTarget?: boolean, isSetState: boolean = true) {\n        this.moveables.forEach(moveable => {\n            moveable.updateRect(type, isTarget, isSetState);\n        });\n    }\n    public getRect(): RectInfo {\n        return {\n            ...super.getRect(),\n            children: this.moveables.map(child => child.getRect()),\n        };\n    }\n    public request() {\n        return {\n            request() {\n                return this;\n            },\n            requestEnd() {\n                return this;\n            },\n        };\n    }\n    public dragStart() {\n        return this;\n    }\n    public hitTest() {\n        return 0;\n    }\n    public isInside() {\n        return false;\n    }\n    public isDragging() {\n        return false;\n    }\n    public updateRenderPoses() { }\n    public checkUpdate() { }\n    public triggerEvent() { }\n    protected updateAbles() { }\n    protected _updateEvents() { }\n    protected _updateObserver() {}\n}\n\n/**\n * Create targets individually, not as a group.\n * @name Moveable.IndividualGroup#individualGroupable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   target: [].slice.call(document.querySelectorAll(\".target\")),\n *   individualGroupable: true,\n * });\n */\nexport default MoveableIndividualGroup;\n","import * as React from \"react\";\nimport {\n    Able, MoveableInterface, GroupableProps, MoveableDefaultProps,\n    IndividualGroupableProps, MoveableManagerInterface,\n} from \"./types\";\nimport MoveableManager from \"./MoveableManager\";\nimport MoveableGroup from \"./MoveableGroup\";\nimport { ref, withMethods, prefixCSS } from \"framework-utils\";\nimport { getKeys, IObject, isString } from \"@daybrush/utils\";\nimport { MOVEABLE_METHODS, PREFIX, MOVEABLE_CSS } from \"./consts\";\nimport Default from \"./ables/Default\";\nimport Groupable from \"./ables/Groupable\";\nimport DragArea from \"./ables/DragArea\";\nimport styled from \"react-css-styled\";\nimport { getRefTargets, getElementTargets } from \"./utils\";\nimport IndividualGroupable from \"./ables/IndividualGroupable\";\nimport MoveableIndividualGroup from \"./MoveableIndividualGroup\";\n\n\nexport class InitialMoveable<T = {}>\n    extends React.PureComponent<MoveableDefaultProps & GroupableProps & IndividualGroupableProps & T> {\n    public static defaultAbles: Able[] = [];\n    public static customStyledMap: Record<string, any> = {};\n    public static defaultStyled: any = null;\n    public static makeStyled() {\n        const cssMap: IObject<boolean> = {};\n\n        const ables = this.getTotalAbles();\n        ables.forEach(({ css }: Able) => {\n            if (!css) {\n                return;\n            }\n            css.forEach(text => {\n                cssMap[text] = true;\n            });\n        });\n        const style = getKeys(cssMap).join(\"\\n\");\n\n        this.defaultStyled = styled(\"div\", prefixCSS(PREFIX, MOVEABLE_CSS + style));\n    }\n    public static getTotalAbles(): Able[] {\n\n        return [Default, Groupable, IndividualGroupable, DragArea, ...this.defaultAbles];\n    }\n    @withMethods(MOVEABLE_METHODS)\n    public moveable!: MoveableManager | MoveableGroup | MoveableIndividualGroup;\n    public refTargets: Array<HTMLElement | SVGElement | string | undefined | null> = [];\n    public selectorMap: IObject<Array<HTMLElement | SVGElement>> = {};\n    public render() {\n        const moveableContructor = (this.constructor as typeof InitialMoveable);\n\n        if (!moveableContructor.defaultStyled) {\n            moveableContructor.makeStyled();\n        }\n        const {\n            ables: userAbles,\n            props: userProps,\n            ...props\n        } = this.props;\n        const refTargets = this._updateRefs(true);\n        const elementTargets = getElementTargets(refTargets, this.selectorMap);\n\n        const isGroup = elementTargets.length > 1;\n        const totalAbles = moveableContructor.getTotalAbles();\n        const ables = [\n            ...totalAbles,\n            ...(userAbles as any || []),\n        ];\n        const nextProps = {\n            ...props,\n            ...(userProps || {}),\n            ables,\n            cssStyled: moveableContructor.defaultStyled,\n            customStyledMap: moveableContructor.customStyledMap,\n        };\n\n        if (isGroup) {\n            if (props.individualGroupable) {\n                return <MoveableIndividualGroup key=\"individual-group\" ref={ref(this, \"moveable\")}\n                    {...nextProps}\n                    target={null}\n                    targets={elementTargets} />;\n            }\n            return <MoveableGroup key=\"group\" ref={ref(this, \"moveable\")}\n                {...nextProps}\n                target={null}\n                targets={elementTargets}  />;\n        } else {\n            return <MoveableManager<any> key=\"single\" ref={ref(this, \"moveable\")}\n                {...nextProps}\n                target={elementTargets[0]} />;\n        }\n    }\n    public componentDidMount() {\n        this._updateRefs();\n    }\n    public componentDidUpdate() {\n        this._updateRefs();\n    }\n    public componentWillUnmount() {\n        this.selectorMap = {};\n        this.refTargets = [];\n    }\n    public getManager(): MoveableManagerInterface<any, any> {\n        return this.moveable;\n    }\n    private _updateRefs(isRender?: boolean) {\n        const prevRefTargets = this.refTargets;\n        const nextRefTargets = getRefTargets((this.props.target || this.props.targets) as any);\n        const isBrowser = typeof document !== \"undefined\";\n\n        let isUpdate = (prevRefTargets.length !== nextRefTargets.length) || prevRefTargets.some((target, i) => {\n            const nextTarget = nextRefTargets[i];\n\n            if (!target && !nextTarget) {\n                return false;\n            } else if (target !== nextTarget) {\n                return true;\n            }\n            return false;\n        });\n        const selectorMap = this.selectorMap;\n        const nextSelectorMap: IObject<Array<HTMLElement | SVGElement>> = {};\n\n        this.refTargets.forEach(target => {\n            if (isString(target)) {\n                const selectorTarget = selectorMap[target];\n\n                if (selectorTarget) {\n                    nextSelectorMap[target] = selectorMap[target];\n                } else if (isBrowser) {\n                    isUpdate = true;\n                    nextSelectorMap[target] = [].slice.call(document.querySelectorAll(target));\n                }\n            }\n        });\n\n        this.refTargets = nextRefTargets;\n        this.selectorMap = nextSelectorMap;\n\n        if (!isRender && isUpdate) {\n            // this.forceUpdate();\n        }\n        return nextRefTargets;\n    }\n}\nexport interface InitialMoveable<T = {}>\n    extends React.PureComponent<MoveableDefaultProps & GroupableProps & IndividualGroupableProps & T>,\n    MoveableInterface {\n    setState(state: any, callback?: () => any): any;\n    forceUpdate(callback?: () => any): any;\n}\n","import { MoveableProps, Able } from \"./types\";\nimport { MOVEABLE_ABLES } from \"./ables/consts\";\nimport { InitialMoveable } from \"./InitialMoveable\";\n\nexport default class Moveable<T = {}> extends InitialMoveable<MoveableProps & T> {\n    public static defaultAbles: Able[] = MOVEABLE_ABLES as any;\n}\n","import { Able } from \"./types\";\nimport { InitialMoveable } from \"./InitialMoveable\";\n\nexport function makeMoveable<T = {}>(\n    ables: Array<Able<T>>): typeof InitialMoveable & (new (...args: any[]) => InitialMoveable<T>) {\n    return class Moveable extends InitialMoveable<T> {\n        public static defaultAbles = ables;\n    };\n}\n"],"names":["makeAble","name","able","__assign","events","props","_a","Boolean","getSVGCursor","scale","degree","getCursorCSS","x1","degree45","Math","round","defaultCursor","agent","getAgent","IS_WEBKIT","browser","webkit","IS_WEBKIT605","navi","window","userAgent","navigator","res","exec","toLowerCase","parseFloat","IS_SAFARI_ABOVE15","parseInt","webkitVersion","version","PREFIX","MOVEABLE_CSS","map","join","NEARBY_POS","FLOAT_POINT_NUM","TINY_NUM","MIN_SCALE","MAX_NUM","pow","MIN_NUM","DIRECTIONS4","DIRECTIONS","DIRECTION_REGION_TO_DIRECTION","n","e","s","w","nw","ne","sw","se","DIRECTION_INDEXES","DIRECTION_ROTATIONS","MOVEABLE_METHODS","setCustomDrag","state","delta","isPinch","isConvert","ableName","result","gestos","move","inputEvent","datas","originalDatas","ableDatas","convertDragDist","parentEvent","draggable","client","isDrag","isFlag","type","prevX","prevY","clientX","clientY","startX","startY","distX","distY","deltaX","deltaY","parentGesto","calculatePointerDist","moveable","moveableClientRect","rootMatrix","is3d","pos1","left","top","_b","minus","calculateInversePosition","posX","posY","_c","getDragDist","setDragStart","allMatrix","beforeMatrix","origin","offsetMatrix","targetMatrix","transformOrigin","matrix","inverseMatrix","invert","inverseBeforeMatrix","absoluteOrigin","convertPositionMatrix","plus","startDragBeforeDist","calculate","startDragDist","getTransformDirection","calculateMoveablePosition","beforeTransform","direction","resolveTransformEvent","event","functionName","index","transformIndex","nextTransforms","length","nextTransformAppendedIndexes","nextIndex","find","info","filter","convertTransformInfo","targetFunction","matFunctionName","beforeFunctionTexts","afterFunctionTexts","beforeFunctionMatrix","beforeTransform2","beforeFunctionMatrix2","targetTansform","targetFunctionMatrix","afterTransform","afterFunctionMatrix","afterTransform2","afterFunctionMatrix2","targetAllTransform","allFunctionMatrix","splice","isAppendTransform","isAppend","convertTransformFormat","value","dist","getTransformDist","getBeforeDragDist","bx","by","getTransfromMatrix","fromTranslation","isAfter","nextTargetMatrix","multiply","res1","afterTargetMatrix","isBefore","getInverseDragDist","calculateTransformOrigin","width","height","prevWidth","prevHeight","prevOrigin","pos","i","splitUnit","unit","prevSize","size","isNaN","measureRatio","getPosIndexesByDirection","indexes","push","getPosesByDirection","poses","getPosByDirection","xRatio","yRatio","dot","bottom","getDist","startPos","fixedDirection","calculatePoses","fixedPos","getNextMatrix","getAbsoluteMatrix","getNextTransformMatrix","transform","targetTransform","parseMat","convertDimension","scaleMatrix","createScaleMatrix","fillTransformStartEvent","getBeforeRenderableDatas","setTransform","startTransforms","isArray","splitSpace","setTransformIndex","setDefaultTransformIndex","property","findIndex","func","indexOf","parse","startValue","functionValue","fillOriginalTransform","beforeRenderable","getNextTransforms","getNextTransformText","getNextStyle","nextStyle","fillTransformEvent","nextTransform","drag","Draggable","fillCSSObject","getTranslateDist","fixedPosition","groupable","nextMatrix","groupLeft","groupTop","nextFixedPosition","getDirectionOffset","getScaleDist","scaleDist","getOriginDirection","nextFixedOffset","calculatePosition","getRotateDist","rotateDist","getResizeDist","nextOrigin","getAbsolutePosition","getAbsolutePosesByState","multiply2","pos2","prefix","_i","classNames","prefixNames","defaultSync","fn","getTransformMatrix","isObject","multiplies","createOriginMatrix","a","measureSVGSize","el","isHorizontal","viewBox","getSVGViewBox","ownerSVGElement","getBeforeTransformOrigin","relativeOrigin","getTransformOrigin","getComputedStyle","o","style","split","getElementTransform","target","computedStyle","computedTransform","list","baseVal","matrixes","chr","getOffsetInfo","lastParent","isParent","body","document","assignedSlot","parentElement","isCustomElement","isEnd","position","tagName","willChange","parentNode","nodeType","host","isStatic","offsetParent","getOffsetPosInfo","offsetLeft","offsetTop","isSVG","isUndefined","hasOffset","targetOrigin","slice","getSVGGraphicsOffset","offset","getBodyOffset","bodyStyle","bodyPosition","marginLeft","marginTop","right","convert3DMatrixes","forEach","getBodyScrollPos","documentElement","scrollLeft","scrollTop","getPositionFixedInfo","fixedContainer","hasTransform","getMatrixStackInfo","container","checkContainer","requestEnd","targetTransformOrigin","hasFixed","offsetContainer","convertCSStoMatrix","isFixed","fixedInfo","offsetPos","getSVGMatrix","createIdentityMatrix","isOffsetEnd","offsetInfo","parentClientLeft","parentClientTop","fixedClientLeft","fixedClientTop","clientLeft","clientTop","margin","makeMatrixCSS","convertMatrixtoCSS","clientWidth","clientHeight","x","y","viewBoxWidth","viewBoxHeight","scaleX","scaleY","preserveAspectRatio","align","meetOrSlice","svgOrigin","translate","xAlign","yAlign","floor","scaleDimension","max","min","getBBox","bbox","getRect","posesX","posesY","rectWidth","rectHeight","calculateRect","getSVGOffset","targetInfo","getSize","containerClientRect","getBoundingClientRect","rect","rectLeft","rectTop","mat","prevLeft","prevTop","posOrigin","rectOrigin","count","mat2","_d","nextLeft","nextTop","distLeft","distTop","abs","p","calculateMoveableClientPositions","rootClientRect","rootPoses","y1","x2","y2","x3","y3","x4","y4","_e","originX","originY","getShapeDirection","pos3","pos4","getDistSize","vec","sqrt","getDiagonalSize","getLineStyle","zoom","rad","getRad","getControlTransform","rotation","reduce","prev","getProps","self","offsetWidth","offsetHeight","cssWidth","cssHeight","contentWidth","contentHeight","minWidth","minHeight","minOffsetWidth","minOffsetHeight","maxWidth","Infinity","maxHeight","maxOffsetWidth","maxOffsetHeight","svg","targetStyle","boxSizing","borderLeft","borderLeftWidth","borderRight","borderRightWidth","borderTop","borderTopWidth","borderBottom","borderBottomWidth","paddingLeft","paddingRight","paddingTop","paddingBottom","horizontalPadding","verticalPadding","horizontalBorder","verticalBorder","horizontalOffset","verticalOffset","convertUnitSize","inlineCSSWidth","inlineCSSHeight","computedWidth","computedHeight","between","getRotationRad","resetClientRect","scrollWidth","scrollHeight","getClientRect","isExtends","innerWidth","innerHeight","scrollPos","clientRect","overflow","getDirection","direciton","getAttribute","dir","getAbsolutePoses","roundSign","num","unset","resolvedEvent","cssText","getKeys","fillAfterTransform","prevEvent","nextEvent","fillParams","params","isBeforeEvent","nextParams","currentTarget","isStartEvent","lastEvent","fillEndParams","isDouble","catchEvent","callback","_emitter","on","triggerEvent","isManager","pseudoElt","filterAbles","ables","methods","triggerAblesSimultaneously","enabledAbles","ableGroups","some","method","ableGroup","equals","a1","a2","selectValue","values","groupBy","arr","groups","groupKeys","groupKey","keyIndex","group","groupByMap","flat","cur","concat","maxOffset","args","sort","b","calculatePadding","convertCSSSize","isRelative","getTinyDist","v","getDirectionCondition","checkAbles","isRequest","requestAble","parentDirection","hasClass","invertObject","obj","nextObj","transforms","undefined","beforeFunctionTexts2","targetFunctionText","afterFunctionTexts2","beforeFunctions","beforeFunctions2","targetFunctions","afterFunctions","afterFunctions2","toMat","isArrayFormat","Element","getRefTarget","isSelector","isString","querySelector","isFunction","current","getRefTargets","targets","userTargets","call","querySelectorAll","getElementTargets","selectorMap","elementTargets","getAbsoluteRotation","deg","PI","getDragDistByState","calculateMatrixDist","getSizeDistByDist","startSize","ratio","keepRatio","startOffsetWidth","startOffsetHeight","distWidth","distHeight","standardRad","signSize","cos","startWidthSize","startHeightSize","distSize","ratioRad","sin","getOffsetSizeDist","sizeDirection","parentDistance","parentDist","parentScale","startFixedDirection","directionsDists","directionRatios","ratioDistance","dist_1","onPinchStart","onPinch","onPinchEnd","onPinchGroupStart","onPinchGroup","onPinchGroupEnd","dragStart","pinchStart","angle","pinchable","eventName","controlEventName","pinchAbles","controlAbles","canPinch","ableEvent","parentRotate","snapRenderInfo","request","pinch","pinchScale","distance","pinchEnd","pinchGroupStart","pinchGroup","pinchGroupEnd","fillChildEvents","groupableDatas","childDatas","moveables","_","triggerChildGesto","isStart","match","childs","ev","childMoveable","childEvent","CustomGesto","childGestos","parentFlag","child","triggerChildAbles","eachEvent","VERTICAL_NAMES","HORIZONTAL_NAMES","VERTICAL_NAMES_MAP","start","end","center","HORIZONTAL_NAMES_MAP","hasGuidelines","snappable","bounds","innerBounds","verticalGuidelines","horizontalGuidelines","snapGridWidth","snapGridHeight","guidelines","enableSnap","getSnapDirections","snapDirections","mapSnapDirectionPoses","snapPoses","nextSnapDirections","nextSnapPoses","splitSnapDirectionPoses","horizontalNames","verticalNames","horizontal","vertical","calculateContainerPos","containerRect","clientPos","solveLineConstants","point1","point2","dx","dy","c","throttle","checkMoveableSnapPoses","customSnapThreshold","snapThreshold","checkSnapPoses","checkSnap","checkSnapKeepRatio","endPos","endX","endY","isBottom","isRight","verticalInfo","isSnap","horizontalInfo","verticalSnapInfo","horizontalSnapInfo","posInfos","getNearestSnapGuidelineInfo","isVerticalSnap","verticalGuideline","isHorizontalSnap","horizontalGuideline","horizontalPos","verticalPos","checkSnaps","snapInfo","guideline","posInfo","guidelineInfo","guidelineInfos","targetType","targetPoses","isVertical","posType","snapPosInfos","targetPos","snapPosInfo","getSnapInfosByDirection","snapDirection","nextPoses","alignPoses","checkSnapBoundPriority","aDist","bDist","isBound","getNearOffsetInfo","offsets","aSign","sign","bSign","aOffset","bOffset","getCheckSnapDirections","directions","endDirection_1","signX","signY","nextDirection","signs","isStartLine","line","cx","average","cy","hitTestLine","test1","test2","isSameStartLine","dots","centerSign","error","every","checkInnerBoundDot","threshold","checkInnerBound","verticalSign","horizontalSign","lineConstants","isAllBound","isVerticalBound","isHorizontalBound","leftLine","topLine","rightLine","bottomLine","topBoundInfo","checkLineBoundCollision","bottomBoundInfo","leftBoundInfo","rightBoundInfo","isAllVerticalBound","isAllHorizontalBound","boundLine","isRender","dot1","boundDot1","boundDot2","dy2","dx2","hasDx","hasDy","slope","getInnerBoundInfo","lineInfos","multiple","sizeOffset","getInnerBoundDragInfo","lines","getCheckInnerBoundLineInfos","innerBoundInfo","widthOffsetInfo","heightOffsetInfo","getCheckSnapLineDirections","lineDirections","virtualPoses","dir1","dir2","virtualLine","isBoundRotate","relativePoses","boundDots","rotate","getDistPointLine","solveReverseLine","checkRotateInnerBounds","prevPoses","relativeLeft","relativeRight","relativeTop","relativeBottom","dotInfos","lineRad","lineDist","dotDist","dotRad","distRad","acos","nextRad1","nextRad2","nextRad","checkInnerBoundPoses","horizontalPoses","verticalPoses","boundMap","lineInfo","isHorizontalStart","isVerticalStart","checkBoundPoses","_f","nextBounds","checkBounds","getBounds","externalBounds","containerHeight","containerWidth","snapOffsetLeft","snapOffsetTop","snapOffsetRight","snapOffsetBottom","isCSS","_g","checkBoundKeepRatio","startBoundPos","endBoundPos","minPos","maxPos","boundInfos","boundRect","boundRotate","boundPos","r","nextPos","checkRotateBounds","relativeRad1","relativeRad2","renderGuideline","React","key","scaleType","createElement","className","renderInnerGuideline","__spreadArray","sizeValue","posValue","renderSnapPoses","renderPos","renderGuidelines","targetRect","isDisplayInnerSnapDigit","mainNames","targetStart","targetEnd","hide","elementRect","element","renderDigitLine","lineType","gap","snapDigit","isDisplaySnapDigit","snapDistFormat","sizeName","absGap","snapSize","toFixed","groupByElementGuidelines","otherIndex","names","nextGuidelines","inner","elementRect1","elementRect2","nextPos1","nextPos2","total","renderDashedGuidelines","rendered","sideNames","sidePos","prevRect","nextRect","size1","size2","renderPos1","renderPos2","renderGapGuidelines","targetSideStart","targetSideEnd","gapRects","sideStartPos","sideEndPos","sideCenterPos","solveEquation","snapOffset","solveNextOffset","isOutside","dist1","dist2","widthOffset","heightOffset","getSnapBound","boundInfo","checkThrottleDragRotate","throttleDragRotate","offsetX","offsetY","adjustPoses","adjustPos","prevDistY","checkSnapBoundsDrag","absolutePoses","boundPoses","middle","checkMoveableSnapBounds","verticalSnapBoundInfo","horizontalSnapBoundInfo","verticalInnerBoundInfo","horizontalInnerBoundInfo","horizontalBoundInfos","verticalBoundInfos","horizontalDist","verticalDist","snapIndex","snap","checkSnapBounds","guideines","checkSnapRightLine","snapBoundInfo","rad180","isHorizontalLine","isVerticalLine","getSnapBoundInfo","startDirection","endDirection","otherStartPos","otherEndPos","checkSnapBoundsKeepRatio","otherHorizontalOffset","isOtherHorizontalBound","isOtherHorizontalSnap","otherVerticalOffset","isOtherVerticalBound","isOtherVerticalSnap","snapLine","getSnapBoundOffset","horizontalBoundInfo","verticalBoundInfo","checkMaxBounds","left_1","top_1","right_1","bottom_1","otherDirection","isCheckVertical","isCheckHorizontal","otherPos","nextOtherPos","isHeightOutside","isWidthOutside","getTotalGuidelines","containerClientHeight","containerClientWidth","snapGap","_h","maxSnapElementGuidelineDistance","_j","elementGuidelines","getElementGuidelines","totalGuidelines","getGapGuidelines","getGridGuidelines","getDefaultGuidelines","checkBetweenRects","elementRects","gapGuidelines","targetCenter","targetStart2","targetEnd2","nextElementRects","snapRect1","snapRect2","rect1","rect2","rect1Start","rect1End","rect2Start","rect2End","isCenter","prevValues","snapRect","refresh","nextElementGuidelines","diff","maintained","added","nextValues","prevIndex","getSnapElementRects","elementSnapDirections","topValue","leftValue","rightValue","bottomValue","centerValue","middleValue","sizes","snapWidth","snapHeight","nextPosInfo","containerLeft","containerTop","getMinMaxs","targetLeft","targetTop","elementLeft","elementTop","elementRight","elementBottom","snapStart","snapContainer","snapContainerTarget","snapContainerRect","offset1","offset2","getNextFixedPoses","nextFixedPos","getSizeOffsetInfo","innerBoundLineInfos","recheckSizeByTwoDirection","snapPos","nextWidthOffset","nextHeightOffset","nextWidth","nextHeight","checkSizeDist","getNextPoses","isWidthBound","isHeightBound","widthDist","heightDist","isGetWidthOffset","checkSnapRotate","checkSnapResize","nextAllMatrix","checkSnapScale","sizeDist","startCheckSnapDrag","getSnapGuidelines","addBoundGuidelines","verticalSnapPoses","horizontalSnapPoses","verticalInnerBoundPoses","horizontalInnerBoundPoses","innerPos","directionCondition","dragRelation","Array","Object","Number","Function","onSnap","css","render","minLeft","minTop","externalPoses","snapInfos","hasExternalPoses","externalRect","verticalPosInfos","horizontalPosInfos","allGuidelines","elements","gaps","dragEnd","dragControlCondition","rotatableDragControlCondtion","dragControlStart","dragControl","dragControlEnd","dragGroupStart","dragGroup","dragGroupEnd","dragGroupControlStart","dragGroupControl","dragGroupControlEnd","renderDirectionControlsByInfos","renderDirections","renderPoses","rotationRad","degRotation","directionMap","renderState","renderDirectionMap","data","directionRotation","dataAttrs","renderDirectionControls","defaultDirections","renderAroundControls","renderLine","renderEdgeLines","edge","index1","index2","getRenderDirections","renderDiagonalDirections","renderAllDirections","throttleDrag","startDragRotate","edgeDraggable","onDragStart","onDrag","onDragEnd","onDragGroupStart","onDragGroup","onDragGroupEnd","dragInfo","beforeOrigin","targetGesto","prevDist","prevBeforeDist","deltaOffset","set","startRect","parentMoveable","dragRotateRad","ry","rx","beforeTranslate","throttleArray","beforeDist","beforeDelta","passDelta","passDist","dragAfter","param","isControl","requestStart","resizable","throttleResize","resizeFormat","keepRatioFinally","onResizeStart","onBeforeResize","onResize","onResizeEnd","onResizeGroupStart","onBeforeResizeGroup","onResizeGroup","onResizeGroupEnd","isGroup","parentFixedDirection","controlGesto","minSize","startWidth","startHeight","maxSize","startOffsetMatrix","startTransformOrigin","isWidth","parentIsWidth","setRatio","isFinite","startPositions","setFixedDirection","setMin","setMax","nextMaxSize","isNumber","startRatio","setOrigin","isResize","parentKeepRatio","dragClient","resolveMatrix","targetN","getNextBoundingSize","nextSize","boundingWidth","boundingHeight","nextFixedDirection","setSize","snapDist","computeSize","isNoSnap","calculateBoundSize","inverseDelta","dragControlAfter","errorWidth","errorHeight","isErrorWidth","isErrorHeight","dragGroupControlCondition","originalEvents","setDist","createRotateMatrix","originalX","originalY","parentStartOffsetWidth","parentStartOffsetHeight","updateGroupMin","originalMinSize","childMinSize","childStartOffsetWidth","childStartOffsetHeight","parentMinWidth","parentMinHeight","updateGroupMax","originalMaxSize","childMaxSize","parentMaxWidth","parentMaxHeight","deltaWidth","deltaHeight","setRotateStartInfo","startAbsoluteOrigin","prevDeg","defaultDeg","prevSnapDeg","loop","startDist","getAbsoluteDist","normalizedPrevDeg","getAbsoluteDistByClient","getRotateInfo","moveableRect","throttleRotate","nextDist","snapRotation","snapDeg","getRotationPositions","rotationPosition","radPoses","isReverse","rotationTarget","contains","directionCSS","rotatable","String","rotateAroundControls","resolveAblesWithRotatable","onRotateStart","onBeforeRotate","onRotate","onRotateEnd","onRotateGroupStart","onBeforeRotateGroup","onRotateGroup","onRotateGroupEnd","positions","jsxs","resolveMap_1","directionControlInfos","resolve","beforeDirection","resizeStart","startClientX","startClientY","externalRotate","beforeInfo","afterInfo","absoluteInfo","inputTarget","regionDirection","controlDirection","isAroundControl","resolveAble","clientPoses","originalFixedDirection_1","originalPosition","getOrigin","fixedBeforeOrigin","fixedAfterOrigin","Resizable","rotatation","isRotate","groupDelta","targetDirection","beforeRotation","absoluteDelta","absoluteDist","absoluteRotation","startRotation","absoluteStartRotation","nextClientX","nextClientY","setRotation","nextRotation","inverseDist","prevInverseDist","requestValue","dragEvent","transformEvent","resize","resizeEvent","beforeRotate","absoluteRotate","parentLeft","parentTop","parentBeforeOrigin","childClient","groupClient","rotateMatrix","setGroupRotation","distRotate","getRotation","deltaRotate","scalable","throttleScale","onScaleStart","onBeforeScale","onScale","onScaleEnd","onScaleGroupStart","onBeforeScaleGroup","onScaleGroup","onScaleGroupEnd","scaleWidth","scaleHeight","scaleXRatio","scaleYRatio","isScale","getNextScale","stateDirection","setScale","nextScale","moveableScale","getMiddleLinePos","getTriangleRad","rad1","rad2","isValidPos","poses1","poses2","pi","warpable","onWarpStart","onWarp","onWarpEnd","linePosFrom1","linePosFrom2","linePosFrom3","linePosFrom4","linePosTo1","linePosTo2","linePosTo3","linePosTo4","warpTargetMatrix","targetInverseMatrix","ignoreDimension","prevMatrix","posIndexes","isWarp","selectedPoses","nearByPoses","h","createWarpMatrix","afterMatrix","totalMatrix","AREA_PIECES","AREA_PIECE","AVOID","restoreStyle","areaElement","removeClass","renderPieces","dragArea","passDragArea","onClick","onClickGroup","ref","isDragArea","rects","children","nextElementSibling","addClass","disableNativeEvent","enableNativeEvent","requestAnimationFrame","getDefaultScrollPosition","scrollContainer","scrollable","scrollThreshold","getScrollPosition","onScroll","onScrollGroup","getContainer","dragScroll","DragScroll","scrollContainerElement","gestoName","scrollBy","checkScroll","dragGroupContro","dragGroupControEnd","dragTarget","portalContainer","rootContainer","useResizeObserver","pinchThreshold","pinchOutside","checkInput","cspNonce","translateZ","hideDefaultLines","flushSync","stopPropagation","preventClickEventOnDrag","preventClickDefault","padding","paddingDirections","paddingPos1","paddingPos2","paddingPos3","paddingPos4","RADIUS_DIRECTIONS","calculateRatio","sumSize","sumRatio","HORIZONTAL_RADIUS_ORDER","VERTICAL_RADIUS_ORDER","HORIZONTAL_RADIUS_DIRECTIONS","VERTICAL_RADIUS_DIRECTIONS","getRadiusStyles","controlPoses","clipStyles","raws","rawPos","styles","getRadiusRange","horizontalRange","verticalRange","clipPose","sub","getRadiusValues","minCounts","splitIndex","splitLength","horizontalValues","verticalValues","nwValue","neValue","seValue","swValue","wnValue","_k","enValue","_l","esValue","_m","wsValue","horizontalRawPoses","verticalRawPoses","nextHorizontalPoses","nextVerticalPoses","raw","removeRadiusPos","startIndex","radiuslIndex","deleteCount","addRadiusPos","horizontalIndex","verticalIndex","radiusX","radiusY","startVerticalIndex","splitRadiusPoses","horizontals","verticals","CLIP_DIRECTIONS","CLIP_RECT_DIRECTIONS","getClipStyles","clipPath","clipRelative","clipType","clipPoses","isRect","isCircle","subWidth","subHeight","getRectPoses","xs","ys","dirx","diry","getControlSize","xRange","yRange","moveControlPos","dists","verticalDirections","horizontalDirections","verticalDirection_1","horizontalDirection_1","fixedIndex","nextControlPoses_1","controlPose","controlDir","dirDir","dirHorizontal","dirVertical","getClipPath","defaultClip","customClip","clipText","clip","splitBracket","clipPrefix","splitter","splitComma","xPos","yPos","radiusX_1","radiusY_1","radius","xRadius","yRadius","centerPos_1","roundIndex","rectLength","radiusValues","_o","_p","_q","_r","nextRight","nextBottom","radiusPoses","_s","addClipPath","clipIndex","clipEventType","clipStyle","removeClipPath","clippable","defaultClipPath","customClipPath","clipArea","dragWithClip","clipTargetBounds","clipVerticalGuidelines","clipHorizontalGuidelines","clipSnapThreshold","onClipStart","onClip","onClipEnd","clipPathState","snapBoundInfos","calculatedPos","controls","isInset","isPolygon","linePoses_1","to","from","clipLeft","clipTop","ellipseClipPath","piece","areaPoses","allWidth","allHeight","allLeft_1","allTop_1","directionType","snapPos1","snapPos2","isDragTarget","isClipStart","isLine","isArea","originalDraggable","originalDist","firstDist","isDragWithTarget","isAll","guidePoses","isEllipse","guideRect","guideXPoses","guideYPoses","rectPoses","rectDists_1","boundDelta","snapOffsetY","snapOffsetX","distSnapX","distSnapY","width_1","height_1","nextControlPoses_2","j","nextClipStyles","dragDist","originDraggable","originRelative","onDragOriginStart","onDragOrigin","onDragOriginEnd","startOrigin","startTargetOrigin","isDragOrigin","distOrigin","dragDelta","deltaOrigin","addBorderRadius","lineIndex","horizontalsLength","verticalsLength","getBorderRadius","borderRadius","triggerRoundEvent","roundRelative","borderRadiusState","roundable","minRoundControls","maxRoundControls","roundClickable","onRoundStart","onRound","onRoundEnd","verticalCount","horizontalCount","isDisplay","display","controlIndex","isRound","selectedControlPose","selectedVertical","selectedHorizontal","pose","poseDist","isIdentityMatrix","identityMatrix","onBeforeRenderStart","onBeforeRender","onBeforeRenderEnd","onBeforeRenderGroupStart","onBeforeRenderGroup","onBeforeRenderGroupEnd","cssMatrix","startTransform","resetStyle","fillDragStartParams","fillDragParams","_this","onRenderStart","onRender","onRenderEnd","onRenderGroupStart","onRenderGroup","onRenderGroupEnd","resultCount","fillDragEndParams","triggerAble","ableType","eventOperation","eventAffix","eventType","requestInstant","conditionName","isFirstStart","updateRect","requestAble_1","eventAbles","BeforeRenderable","Renderable","elementFromPoint","results","nextDatas","isEventStart","off","isUpdate","isForceEnd","preventDefault","isUnmounted","forceUpdate","getTargetAbleGesto","moveableTarget","controlBox","getElement","startFunc","eventTarget","isMoveableElement","getAbleGesto","conditionFunctions","isTargetAbles","options","preventRightClick","preventWheelClick","preventClickEventOnDragStart","gesto","Gesto","stop","addEventListener","_onEvent","removeEventListener","calculateMatrixStack","isAbsolute3d","prevTargetMatrix","rootMatrixes","isRoot3d","offsetRootContainer","isNext3d","isSVGGraphicElement","reverse","originalRootContainer","endContainer","rootMatrixBeforeOffset","nextInfo","isMatrix3d","calculateElementInfo","allResult","getElementInfo","getMoveableTargetInfo","moveableElement","parentContainer","targetClientRect","rootContainerClientRect","beforePosition","originalBeforeOrigin","__extends","EventEmitter","isDragging","checkUpdateRect","cancelAnimationFrame","_observerId","parentPosition","propsTarget","ControlBoxElement","checkUpdate","updateRenderPoses","stateTarget","groupTargets","ableAttributes","getEnabledAbles","onPreventClick","renderAbles","_renderLines","wrapperMoveable","_updateTargets","_updateNativeEvents","_updateEvents","updateCheckInput","_updateObserver","prevProps","manager","destroy","triggerDragStart","points","fitPoints","getOverlapSize","totalSize","getAreaSize","isInside","isTarget","isSetState","updateState","statePos","isInstant","requsetAble","ableRequester","requester","ableParam","componentWillUnmount","stateLeft","stateTop","stateContainer","updateAbles","isChanged","moveableContainer","unsetAbles","trigger","tag","customStyleMap","customStyledMap","styled","targetAbles","always","nextState","setState","Renderer","ResizeObserver","_observer","disconnect","observer","observe","box","controlBoxElement","hasTargetAble","hasControlAble","isUnset","_isTargetChanged","_prevTarget","_prevDragArea","hideChildMoveableDefaultLines","useDragArea","prevTarget","prevDragArea","isTargetChanged","isDragAreaChanged","eventKeys","hasAbles","EventManager","setAbles","MoveableManager","cssStyled","defaultGroupRotate","defaultGroupOrigin","refs","clickable","containsElement","containsTarget","targetIndex","parentTarget","getDraggableEvent","individualGroupable","MOVEABLE_ABLES","Default","Snappable","Pinchable","Scalable","Warpable","Rotatable","Scrollable","Padding","Origin","OriginDraggable","Clippable","Roundable","Groupable","IndividualGroupable","Clickable","DragArea","MOVEABLE_EVENTS_PROPS_MAP","MOVEABLE_PROPS_MAP","MOVEABLE_EVENTS_MAP","MOVEABLE_EVENTS","keys","MOVEABLE_PROPS","getMaxPos","getMinPos","getGroupRect","moveablePoses","minX","minY","groupWidth","groupHeight","fixedRotation","rad_1","a1_1","tan","a2_1","b1MinMax_1","b2MinMax_1","b1","b2","rotatePoses","changedWidth","ChildrenDiffer","updateGroup","_super","nextTarget","isContainerChanged","differ","update","changed","removed","MoveableGroup","defaultProps","InitialMoveable","cssMap","getTotalAbles","text","defaultStyled","prefixCSS","defaultAbles","moveableContructor","constructor","makeStyled","userAbles","userProps","refTargets","_updateRefs","totalAbles","nextProps","MoveableIndividualGroup","prevRefTargets","nextRefTargets","isBrowser","nextSelectorMap","selectorTarget","__decorate","withMethods","Moveable","makeMoveable"],"mappings":"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"}